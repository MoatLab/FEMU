#!/bin/sh
#
# qemu configure script (c) 2003 Fabrice Bellard
#

# Unset some variables known to interfere with behavior of common tools,
# just as autoconf does.
CLICOLOR_FORCE= GREP_OPTIONS=
unset CLICOLOR_FORCE GREP_OPTIONS

# Don't allow CCACHE, if present, to use cached results of compile tests!
export CCACHE_RECACHE=yes

# make source path absolute
source_path=$(cd "$(dirname -- "$0")"; pwd)

if test "$PWD" = "$source_path"
then
    echo "Using './build' as the directory for build output"

    MARKER=build/auto-created-by-configure

    if test -e build
    then
        if test -f $MARKER
        then
           rm -rf build
        else
            echo "ERROR: ./build dir already exists and was not previously created by configure"
            exit 1
        fi
    fi

    mkdir build
    touch $MARKER

    cat > GNUmakefile <<'EOF'
# This file is auto-generated by configure to support in-source tree
# 'make' command invocation

ifeq ($(MAKECMDGOALS),)
recurse: all
endif

.NOTPARALLEL: %
%: force
	@echo 'changing dir to build for $(MAKE) "$(MAKECMDGOALS)"...'
	@$(MAKE) -C build -f Makefile $(MAKECMDGOALS)
	@if test "$(MAKECMDGOALS)" = "distclean" && \
	    test -e build/auto-created-by-configure ; \
	then \
	    rm -rf build GNUmakefile ; \
	fi
force: ;
.PHONY: force
GNUmakefile: ;

EOF
    cd build
    exec $source_path/configure "$@"
fi

# Temporary directory used for files created while
# configure runs. Since it is in the build directory
# we can safely blow away any previous version of it
# (and we need not jump through hoops to try to delete
# it when configure exits.)
TMPDIR1="config-temp"
rm -rf "${TMPDIR1}"
mkdir -p "${TMPDIR1}"
if [ $? -ne 0 ]; then
    echo "ERROR: failed to create temporary directory"
    exit 1
fi

TMPB="qemu-conf"
TMPC="${TMPDIR1}/${TMPB}.c"
TMPO="${TMPDIR1}/${TMPB}.o"
TMPCXX="${TMPDIR1}/${TMPB}.cxx"
TMPM="${TMPDIR1}/${TMPB}.m"
TMPE="${TMPDIR1}/${TMPB}.exe"

rm -f config.log

# Print a helpful header at the top of config.log
echo "# QEMU configure log $(date)" >> config.log
printf "# Configured with:" >> config.log
printf " '%s'" "$0" "$@" >> config.log
echo >> config.log
echo "#" >> config.log

quote_sh() {
    printf "%s" "$1" | sed "s,','\\\\'',g; s,.*,'&',"
}

print_error() {
    (echo
    echo "ERROR: $1"
    while test -n "$2"; do
        echo "       $2"
        shift
    done
    echo) >&2
}

error_exit() {
    print_error "$@"
    exit 1
}

do_compiler() {
    # Run the compiler, capturing its output to the log. First argument
    # is compiler binary to execute.
    compiler="$1"
    shift
    if test -n "$BASH_VERSION"; then eval '
        echo >>config.log "
funcs: ${FUNCNAME[*]}
lines: ${BASH_LINENO[*]}"
    '; fi
    echo $compiler "$@" >> config.log
    $compiler "$@" >> config.log 2>&1 || return $?
    # Test passed. If this is an --enable-werror build, rerun
    # the test with -Werror and bail out if it fails. This
    # makes warning-generating-errors in configure test code
    # obvious to developers.
    if test "$werror" != "yes"; then
        return 0
    fi
    # Don't bother rerunning the compile if we were already using -Werror
    case "$*" in
        *-Werror*)
           return 0
        ;;
    esac
    echo $compiler -Werror "$@" >> config.log
    $compiler -Werror "$@" >> config.log 2>&1 && return $?
    error_exit "configure test passed without -Werror but failed with -Werror." \
        "This is probably a bug in the configure script. The failing command" \
        "will be at the bottom of config.log." \
        "You can run configure with --disable-werror to bypass this check."
}

do_cc() {
    do_compiler "$cc" $CPU_CFLAGS "$@"
}

do_cxx() {
    do_compiler "$cxx" $CPU_CFLAGS "$@"
}

do_objc() {
    do_compiler "$objcc" $CPU_CFLAGS "$@"
}

# Append $2 to the variable named $1, with space separation
add_to() {
    eval $1=\${$1:+\"\$$1 \"}\$2
}

update_cxxflags() {
    # Set QEMU_CXXFLAGS from QEMU_CFLAGS by filtering out those
    # options which some versions of GCC's C++ compiler complain about
    # because they only make sense for C programs.
    QEMU_CXXFLAGS="-D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS"
    CONFIGURE_CXXFLAGS=$(echo "$CONFIGURE_CFLAGS" | sed s/-std=gnu11/-std=gnu++11/)
    for arg in $QEMU_CFLAGS; do
        case $arg in
            -Wstrict-prototypes|-Wmissing-prototypes|-Wnested-externs|\
            -Wold-style-declaration|-Wold-style-definition|-Wredundant-decls)
                ;;
            *)
                QEMU_CXXFLAGS=${QEMU_CXXFLAGS:+$QEMU_CXXFLAGS }$arg
                ;;
        esac
    done
}

compile_object() {
  local_cflags="$1"
  do_cc $CFLAGS $EXTRA_CFLAGS $CONFIGURE_CFLAGS $QEMU_CFLAGS $local_cflags -c -o $TMPO $TMPC
}

compile_prog() {
  local_cflags="$1"
  local_ldflags="$2"
  do_cc $CFLAGS $EXTRA_CFLAGS $CONFIGURE_CFLAGS $QEMU_CFLAGS $local_cflags -o $TMPE $TMPC \
      $LDFLAGS $EXTRA_LDFLAGS $CONFIGURE_LDFLAGS $QEMU_LDFLAGS $local_ldflags
}

# symbolically link $1 to $2.  Portable version of "ln -sf".
symlink() {
  rm -rf "$2"
  mkdir -p "$(dirname "$2")"
  ln -s "$1" "$2"
}

# check whether a command is available to this shell (may be either an
# executable or a builtin)
has() {
    type "$1" >/dev/null 2>&1
}

version_ge () {
    local_ver1=$(expr "$1" : '\([0-9.]*\)' | tr . ' ')
    local_ver2=$(echo "$2" | tr . ' ')
    while true; do
        set x $local_ver1
        local_first=${2-0}
        # 'shift 2' if $2 is set, or 'shift' if $2 is not set
        shift ${2:+2}
        local_ver1=$*
        set x $local_ver2
        # the second argument finished, the first must be greater or equal
        test $# = 1 && return 0
        test $local_first -lt $2 && return 1
        test $local_first -gt $2 && return 0
        shift ${2:+2}
        local_ver2=$*
    done
}

glob() {
    eval test -z '"${1#'"$2"'}"'
}

ld_has() {
    $ld --help 2>/dev/null | grep ".$1" >/dev/null 2>&1
}

if printf %s\\n "$source_path" "$PWD" | grep -q "[[:space:]:]";
then
  error_exit "main directory cannot contain spaces nor colons"
fi

# default parameters
cpu=""
iasl="iasl"
interp_prefix="/usr/gnemul/qemu-%M"
static="no"
cross_compile="no"
cross_prefix=""
audio_drv_list="default"
block_drv_rw_whitelist=""
block_drv_ro_whitelist=""
host_cc="cc"
debug_info="yes"
lto="false"
stack_protector=""
safe_stack=""
use_containers="yes"
gdb_bin=$(command -v "gdb-multiarch" || command -v "gdb")

if test -e "$source_path/.git"
then
    git_submodules_action="update"
else
    git_submodules_action="ignore"
fi

git_submodules="ui/keycodemapdb"
git="git"

# Don't accept a target_list environment variable.
unset target_list
unset target_list_exclude

# Default value for a variable defining feature "foo".
#  * foo="no"  feature will only be used if --enable-foo arg is given
#  * foo=""    feature will be searched for, and if found, will be used
#              unless --disable-foo is given
#  * foo="yes" this value will only be set by --enable-foo flag.
#              feature will searched for,
#              if not found, configure exits with error
#
# Always add --enable-foo and --disable-foo command line args.
# Distributions want to ensure that several features are compiled in, and it
# is impossible without a --enable-foo that exits if a feature is not found.

default_feature=""
# parse CC options second
for opt do
  optarg=$(expr "x$opt" : 'x[^=]*=\(.*\)')
  case "$opt" in
      --without-default-features)
          default_feature="no"
  ;;
  esac
done

EXTRA_CFLAGS=""
EXTRA_CXXFLAGS=""
EXTRA_OBJCFLAGS=""
EXTRA_LDFLAGS=""

xen_ctrl_version="$default_feature"
vhost_kernel="$default_feature"
vhost_net="$default_feature"
vhost_crypto="$default_feature"
vhost_scsi="$default_feature"
vhost_vsock="$default_feature"
vhost_user="no"
vhost_user_fs="$default_feature"
vhost_vdpa="$default_feature"
rdma="$default_feature"
pvrdma="$default_feature"
debug_tcg="no"
debug="no"
sanitizers="no"
tsan="no"
fortify_source="$default_feature"
gcov="no"
EXESUF=""
modules="no"
module_upgrades="no"
prefix="/usr/local"
qemu_suffix="qemu"
softmmu="yes"
linux_user=""
bsd_user=""
pkgversion=""
pie=""
trace_backends="log"
trace_file="trace"
opengl="$default_feature"
coroutine=""
tls_priority="NORMAL"
plugins="$default_feature"
secret_keyring="$default_feature"
meson=""
meson_args=""
ninja=""
gio="$default_feature"
skip_meson=no

# The following Meson options are handled manually (still they
# are included in the automatically generated help message)

# 1. Track which submodules are needed
if test "$default_feature" = no ; then
  capstone="disabled"
  slirp="disabled"
else
  capstone="auto"
  slirp="auto"
fi
fdt="auto"

# 2. Support --with/--without option
default_devices="true"

# 3. Automatically enable/disable other options
tcg="enabled"
cfi="false"

# 4. Detection partly done in configure
xen=${default_feature:+disabled}

# parse CC options second
for opt do
  optarg=$(expr "x$opt" : 'x[^=]*=\(.*\)')
  case "$opt" in
  --cross-prefix=*) cross_prefix="$optarg"
                    cross_compile="yes"
  ;;
  --cc=*) CC="$optarg"
  ;;
  --cxx=*) CXX="$optarg"
  ;;
  --cpu=*) cpu="$optarg"
  ;;
  --extra-cflags=*)
    EXTRA_CFLAGS="$EXTRA_CFLAGS $optarg"
    EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS $optarg"
    EXTRA_OBJCFLAGS="$EXTRA_OBJCFLAGS $optarg"
    ;;
  --extra-cxxflags=*) EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS $optarg"
  ;;
  --extra-objcflags=*) EXTRA_OBJCFLAGS="$EXTRA_OBJCFLAGS $optarg"
  ;;
  --extra-ldflags=*) EXTRA_LDFLAGS="$EXTRA_LDFLAGS $optarg"
  ;;
  --enable-debug-info) debug_info="yes"
  ;;
  --disable-debug-info) debug_info="no"
  ;;
  --cross-cc-*[!a-zA-Z0-9_-]*=*) error_exit "Passed bad --cross-cc-FOO option"
  ;;
  --cross-cc-cflags-*) cc_arch=${opt#--cross-cc-cflags-}; cc_arch=${cc_arch%%=*}
                      eval "cross_cc_cflags_${cc_arch}=\$optarg"
                      cross_cc_vars="$cross_cc_vars cross_cc_cflags_${cc_arch}"
  ;;
  --cross-cc-*) cc_arch=${opt#--cross-cc-}; cc_arch=${cc_arch%%=*}
                cc_archs="$cc_archs $cc_arch"
                eval "cross_cc_${cc_arch}=\$optarg"
                cross_cc_vars="$cross_cc_vars cross_cc_${cc_arch}"
  ;;
  esac
done
# OS specific
# Using uname is really, really broken.  Once we have the right set of checks
# we can eliminate its usage altogether.

# Preferred compiler:
#  ${CC} (if set)
#  ${cross_prefix}gcc (if cross-prefix specified)
#  system compiler
if test -z "${CC}${cross_prefix}"; then
  cc="$host_cc"
else
  cc="${CC-${cross_prefix}gcc}"
fi

if test -z "${CXX}${cross_prefix}"; then
  cxx="c++"
else
  cxx="${CXX-${cross_prefix}g++}"
fi

ar="${AR-${cross_prefix}ar}"
as="${AS-${cross_prefix}as}"
ccas="${CCAS-$cc}"
cpp="${CPP-$cc -E}"
objcopy="${OBJCOPY-${cross_prefix}objcopy}"
ld="${LD-${cross_prefix}ld}"
ranlib="${RANLIB-${cross_prefix}ranlib}"
nm="${NM-${cross_prefix}nm}"
smbd="$SMBD"
strip="${STRIP-${cross_prefix}strip}"
windres="${WINDRES-${cross_prefix}windres}"
pkg_config_exe="${PKG_CONFIG-${cross_prefix}pkg-config}"
query_pkg_config() {
    "${pkg_config_exe}" ${QEMU_PKG_CONFIG_FLAGS} "$@"
}
pkg_config=query_pkg_config
sdl2_config="${SDL2_CONFIG-${cross_prefix}sdl2-config}"

# default flags for all hosts
# We use -fwrapv to tell the compiler that we require a C dialect where
# left shift of signed integers is well defined and has the expected
# 2s-complement style results. (Both clang and gcc agree that it
# provides these semantics.)
QEMU_CFLAGS="-fno-strict-aliasing -fno-common -fwrapv"
QEMU_CFLAGS="-Wundef -Wwrite-strings -Wmissing-prototypes $QEMU_CFLAGS"
QEMU_CFLAGS="-Wstrict-prototypes -Wredundant-decls $QEMU_CFLAGS"
QEMU_CFLAGS="-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE $QEMU_CFLAGS"

QEMU_LDFLAGS=

# Flags that are needed during configure but later taken care of by Meson
CONFIGURE_CFLAGS="-std=gnu11 -Wall"
CONFIGURE_LDFLAGS=


check_define() {
cat > $TMPC <<EOF
#if !defined($1)
#error $1 not defined
#endif
int main(void) { return 0; }
EOF
  compile_object
}

check_include() {
cat > $TMPC <<EOF
#include <$1>
int main(void) { return 0; }
EOF
  compile_object
}

write_c_skeleton() {
    cat > $TMPC <<EOF
int main(void) { return 0; }
EOF
}

if check_define __linux__ ; then
  targetos=linux
elif check_define _WIN32 ; then
  targetos=windows
elif check_define __OpenBSD__ ; then
  targetos=openbsd
elif check_define __sun__ ; then
  targetos=sunos
elif check_define __HAIKU__ ; then
  targetos=haiku
elif check_define __FreeBSD__ ; then
  targetos=freebsd
elif check_define __FreeBSD_kernel__ && check_define __GLIBC__; then
  targetos=gnu/kfreebsd
elif check_define __DragonFly__ ; then
  targetos=dragonfly
elif check_define __NetBSD__; then
  targetos=netbsd
elif check_define __APPLE__; then
  targetos=darwin
else
  # This is a fatal error, but don't report it yet, because we
  # might be going to just print the --help text, or it might
  # be the result of a missing compiler.
  targetos=bogus
fi

# OS specific

mingw32="no"
bsd="no"
linux="no"
solaris="no"
case $targetos in
windows)
  mingw32="yes"
  plugins="no"
  pie="no"
;;
gnu/kfreebsd)
  bsd="yes"
;;
freebsd)
  bsd="yes"
  make="${MAKE-gmake}"
  # needed for kinfo_getvmmap(3) in libutil.h
;;
dragonfly)
  bsd="yes"
  make="${MAKE-gmake}"
;;
netbsd)
  bsd="yes"
  make="${MAKE-gmake}"
;;
openbsd)
  bsd="yes"
  make="${MAKE-gmake}"
;;
darwin)
  bsd="yes"
  darwin="yes"
  # Disable attempts to use ObjectiveC features in os/object.h since they
  # won't work when we're compiling with gcc as a C compiler.
  QEMU_CFLAGS="-DOS_OBJECT_USE_OBJC=0 $QEMU_CFLAGS"
;;
sunos)
  solaris="yes"
  make="${MAKE-gmake}"
# needed for CMSG_ macros in sys/socket.h
  QEMU_CFLAGS="-D_XOPEN_SOURCE=600 $QEMU_CFLAGS"
# needed for TIOCWIN* defines in termios.h
  QEMU_CFLAGS="-D__EXTENSIONS__ $QEMU_CFLAGS"
  # $(uname -m) returns i86pc even on an x86_64 box, so default based on isainfo
  # Note that this check is broken for cross-compilation: if you're
  # cross-compiling to one of these OSes then you'll need to specify
  # the correct CPU with the --cpu option.
  if test -z "$cpu" && test "$(isainfo -k)" = "amd64"; then
    cpu="x86_64"
  fi
;;
haiku)
  pie="no"
  QEMU_CFLAGS="-DB_USE_POSITIVE_POSIX_ERRORS -D_BSD_SOURCE -fPIC $QEMU_CFLAGS"
;;
linux)
  linux="yes"
  vhost_user=${default_feature:-yes}
;;
esac

if test ! -z "$cpu" ; then
  # command line argument
  :
elif check_define __i386__ ; then
  cpu="i386"
elif check_define __x86_64__ ; then
  if check_define __ILP32__ ; then
    cpu="x32"
  else
    cpu="x86_64"
  fi
elif check_define __sparc__ ; then
  if check_define __arch64__ ; then
    cpu="sparc64"
  else
    cpu="sparc"
  fi
elif check_define _ARCH_PPC ; then
  if check_define _ARCH_PPC64 ; then
    if check_define _LITTLE_ENDIAN ; then
      cpu="ppc64le"
    else
      cpu="ppc64"
    fi
  else
    cpu="ppc"
  fi
elif check_define __mips__ ; then
  cpu="mips"
elif check_define __s390__ ; then
  if check_define __s390x__ ; then
    cpu="s390x"
  else
    cpu="s390"
  fi
elif check_define __riscv ; then
  cpu="riscv"
elif check_define __arm__ ; then
  cpu="arm"
elif check_define __aarch64__ ; then
  cpu="aarch64"
elif check_define __loongarch64 ; then
  cpu="loongarch64"
else
  cpu=$(uname -m)
fi

# Normalise host CPU name, set multilib cflags
# Note that this case should only have supported host CPUs, not guests.
case "$cpu" in
  armv*b|armv*l|arm)
    cpu="arm" ;;

  i386|i486|i586|i686|i86pc|BePC)
    cpu="i386"
    CPU_CFLAGS="-m32" ;;
  x32)
    cpu="x86_64"
    CPU_CFLAGS="-mx32" ;;
  x86_64|amd64)
    cpu="x86_64"
    # ??? Only extremely old AMD cpus do not have cmpxchg16b.
    # If we truly care, we should simply detect this case at
    # runtime and generate the fallback to serial emulation.
    CPU_CFLAGS="-m64 -mcx16" ;;

  mips*)
    cpu="mips" ;;

  ppc)
    CPU_CFLAGS="-m32" ;;
  ppc64)
    CPU_CFLAGS="-m64 -mbig-endian" ;;
  ppc64le)
    cpu="ppc64"
    CPU_CFLAGS="-m64 -mlittle-endian" ;;

  s390)
    CPU_CFLAGS="-m31" ;;
  s390x)
    CPU_CFLAGS="-m64" ;;

  sparc|sun4[cdmuv])
    cpu="sparc"
    CPU_CFLAGS="-m32 -mv8plus -mcpu=ultrasparc" ;;
  sparc64)
    CPU_CFLAGS="-m64 -mcpu=ultrasparc" ;;
esac

: ${make=${MAKE-make}}

# We prefer python 3.x. A bare 'python' is traditionally
# python 2.x, but some distros have it as python 3.x, so
# we check that too
python=
explicit_python=no
for binary in "${PYTHON-python3}" python
do
    if has "$binary"
    then
        python=$(command -v "$binary")
        break
    fi
done


# Check for ancillary tools used in testing
genisoimage=
for binary in genisoimage mkisofs
do
    if has $binary
    then
        genisoimage=$(command -v "$binary")
        break
    fi
done

# Default objcc to clang if available, otherwise use CC
if has clang; then
  objcc=clang
else
  objcc="$cc"
fi

if test "$mingw32" = "yes" ; then
  EXESUF=".exe"
  # MinGW needs -mthreads for TLS and macro _MT.
  CONFIGURE_CFLAGS="-mthreads $CONFIGURE_CFLAGS"
  write_c_skeleton;
  prefix="/qemu"
  qemu_suffix=""
fi

werror=""

. $source_path/scripts/meson-buildoptions.sh

meson_options=
meson_option_parse() {
  meson_options="$meson_options $(_meson_option_parse "$@")"
  if test $? -eq 1; then
    echo "ERROR: unknown option $1"
    echo "Try '$0 --help' for more information"
    exit 1
  fi
}

for opt do
  optarg=$(expr "x$opt" : 'x[^=]*=\(.*\)')
  case "$opt" in
  --help|-h) show_help=yes
  ;;
  --version|-V) exec cat $source_path/VERSION
  ;;
  --prefix=*) prefix="$optarg"
  ;;
  --interp-prefix=*) interp_prefix="$optarg"
  ;;
  --cross-prefix=*)
  ;;
  --cc=*)
  ;;
  --host-cc=*) host_cc="$optarg"
  ;;
  --cxx=*)
  ;;
  --iasl=*) iasl="$optarg"
  ;;
  --objcc=*) objcc="$optarg"
  ;;
  --make=*) make="$optarg"
  ;;
  --install=*)
  ;;
  --python=*) python="$optarg" ; explicit_python=yes
  ;;
  --sphinx-build=*) sphinx_build="$optarg"
  ;;
  --skip-meson) skip_meson=yes
  ;;
  --meson=*) meson="$optarg"
  ;;
  --ninja=*) ninja="$optarg"
  ;;
  --smbd=*) smbd="$optarg"
  ;;
  --extra-cflags=*)
  ;;
  --extra-cxxflags=*)
  ;;
  --extra-objcflags=*)
  ;;
  --extra-ldflags=*)
  ;;
  --enable-debug-info)
  ;;
  --disable-debug-info)
  ;;
  --cross-cc-*)
  ;;
  --enable-modules)
      modules="yes"
  ;;
  --disable-modules)
      modules="no"
  ;;
  --disable-module-upgrades) module_upgrades="no"
  ;;
  --enable-module-upgrades) module_upgrades="yes"
  ;;
  --cpu=*)
  ;;
  --target-list=*) target_list="$optarg"
                   if test "$target_list_exclude"; then
                       error_exit "Can't mix --target-list with --target-list-exclude"
                   fi
  ;;
  --target-list-exclude=*) target_list_exclude="$optarg"
                   if test "$target_list"; then
                       error_exit "Can't mix --target-list-exclude with --target-list"
                   fi
  ;;
  --with-trace-file=*) trace_file="$optarg"
  ;;
  --with-default-devices) default_devices="true"
  ;;
  --without-default-devices) default_devices="false"
  ;;
  --with-devices-*[!a-zA-Z0-9_-]*=*) error_exit "Passed bad --with-devices-FOO option"
  ;;
  --with-devices-*) device_arch=${opt#--with-devices-};
                    device_arch=${device_arch%%=*}
                    cf=$source_path/configs/devices/$device_arch-softmmu/$optarg.mak
                    if test -f "$cf"; then
                        device_archs="$device_archs $device_arch"
                        eval "devices_${device_arch}=\$optarg"
                    else
                        error_exit "File $cf does not exist"
                    fi
  ;;
  --without-default-features) # processed above
  ;;
  --enable-gcov) gcov="yes"
  ;;
  --static)
    static="yes"
    QEMU_PKG_CONFIG_FLAGS="--static $QEMU_PKG_CONFIG_FLAGS"
  ;;
  --mandir=*) mandir="$optarg"
  ;;
  --bindir=*) bindir="$optarg"
  ;;
  --libdir=*) libdir="$optarg"
  ;;
  --libexecdir=*) libexecdir="$optarg"
  ;;
  --includedir=*) includedir="$optarg"
  ;;
  --datadir=*) datadir="$optarg"
  ;;
  --with-suffix=*) qemu_suffix="$optarg"
  ;;
  --docdir=*) docdir="$optarg"
  ;;
  --localedir=*) localedir="$optarg"
  ;;
  --sysconfdir=*) sysconfdir="$optarg"
  ;;
  --localstatedir=*) local_statedir="$optarg"
  ;;
  --firmwarepath=*) firmwarepath="$optarg"
  ;;
  --host=*|--build=*|\
  --disable-dependency-tracking|\
  --sbindir=*|--sharedstatedir=*|\
  --oldincludedir=*|--datarootdir=*|--infodir=*|\
  --htmldir=*|--dvidir=*|--pdfdir=*|--psdir=*)
    # These switches are silently ignored, for compatibility with
    # autoconf-generated configure scripts. This allows QEMU's
    # configure to be used by RPM and similar macros that set
    # lots of directory switches by default.
  ;;
  --audio-drv-list=*) audio_drv_list="$optarg"
  ;;
  --block-drv-rw-whitelist=*|--block-drv-whitelist=*) block_drv_rw_whitelist=$(echo "$optarg" | sed -e 's/,/ /g')
  ;;
  --block-drv-ro-whitelist=*) block_drv_ro_whitelist=$(echo "$optarg" | sed -e 's/,/ /g')
  ;;
  --enable-debug-tcg) debug_tcg="yes"
  ;;
  --disable-debug-tcg) debug_tcg="no"
  ;;
  --enable-debug)
      # Enable debugging options that aren't excessively noisy
      debug_tcg="yes"
      meson_option_parse --enable-debug-mutex ""
      debug="yes"
      fortify_source="no"
  ;;
  --enable-sanitizers) sanitizers="yes"
  ;;
  --disable-sanitizers) sanitizers="no"
  ;;
  --enable-tsan) tsan="yes"
  ;;
  --disable-tsan) tsan="no"
  ;;
  --disable-slirp) slirp="disabled"
  ;;
  --enable-slirp) slirp="enabled"
  ;;
  --enable-slirp=git) slirp="internal"
  ;;
  --enable-slirp=*) slirp="$optarg"
  ;;
  --disable-xen) xen="disabled"
  ;;
  --enable-xen) xen="enabled"
  ;;
  --disable-tcg) tcg="disabled"
                 plugins="no"
  ;;
  --enable-tcg) tcg="enabled"
  ;;
  --disable-system) softmmu="no"
  ;;
  --enable-system) softmmu="yes"
  ;;
  --disable-user)
      linux_user="no" ;
      bsd_user="no" ;
  ;;
  --enable-user) ;;
  --disable-linux-user) linux_user="no"
  ;;
  --enable-linux-user) linux_user="yes"
  ;;
  --disable-bsd-user) bsd_user="no"
  ;;
  --enable-bsd-user) bsd_user="yes"
  ;;
  --enable-pie) pie="yes"
  ;;
  --disable-pie) pie="no"
  ;;
  --enable-werror) werror="yes"
  ;;
  --disable-werror) werror="no"
  ;;
  --enable-lto) lto="true"
  ;;
  --disable-lto) lto="false"
  ;;
  --enable-stack-protector) stack_protector="yes"
  ;;
  --disable-stack-protector) stack_protector="no"
  ;;
  --enable-safe-stack) safe_stack="yes"
  ;;
  --disable-safe-stack) safe_stack="no"
  ;;
  --enable-cfi)
      cfi="true";
      lto="true";
  ;;
  --disable-cfi) cfi="false"
  ;;
  --disable-fdt) fdt="disabled"
  ;;
  --enable-fdt) fdt="enabled"
  ;;
  --enable-fdt=git) fdt="internal"
  ;;
  --enable-fdt=*) fdt="$optarg"
  ;;
  --with-pkgversion=*) pkgversion="$optarg"
  ;;
  --with-coroutine=*) coroutine="$optarg"
  ;;
  --disable-vhost-net) vhost_net="no"
  ;;
  --enable-vhost-net) vhost_net="yes"
  ;;
  --disable-vhost-crypto) vhost_crypto="no"
  ;;
  --enable-vhost-crypto) vhost_crypto="yes"
  ;;
  --disable-vhost-scsi) vhost_scsi="no"
  ;;
  --enable-vhost-scsi) vhost_scsi="yes"
  ;;
  --disable-vhost-vsock) vhost_vsock="no"
  ;;
  --enable-vhost-vsock) vhost_vsock="yes"
  ;;
  --disable-vhost-user-fs) vhost_user_fs="no"
  ;;
  --enable-vhost-user-fs) vhost_user_fs="yes"
  ;;
  --disable-opengl) opengl="no"
  ;;
  --enable-opengl) opengl="yes"
  ;;
  --disable-zlib-test)
  ;;
  --disable-virtio-blk-data-plane|--enable-virtio-blk-data-plane)
      echo "$0: $opt is obsolete, virtio-blk data-plane is always on" >&2
  ;;
  --enable-vhdx|--disable-vhdx)
      echo "$0: $opt is obsolete, VHDX driver is always built" >&2
  ;;
  --enable-uuid|--disable-uuid)
      echo "$0: $opt is obsolete, UUID support is always built" >&2
  ;;
  --tls-priority=*) tls_priority="$optarg"
  ;;
  --enable-rdma) rdma="yes"
  ;;
  --disable-rdma) rdma="no"
  ;;
  --enable-pvrdma) pvrdma="yes"
  ;;
  --disable-pvrdma) pvrdma="no"
  ;;
  --disable-vhost-user) vhost_user="no"
  ;;
  --enable-vhost-user) vhost_user="yes"
  ;;
  --disable-vhost-vdpa) vhost_vdpa="no"
  ;;
  --enable-vhost-vdpa) vhost_vdpa="yes"
  ;;
  --disable-vhost-kernel) vhost_kernel="no"
  ;;
  --enable-vhost-kernel) vhost_kernel="yes"
  ;;
  --disable-capstone) capstone="disabled"
  ;;
  --enable-capstone) capstone="enabled"
  ;;
  --enable-capstone=git) capstone="internal"
  ;;
  --enable-capstone=*) capstone="$optarg"
  ;;
  --with-git=*) git="$optarg"
  ;;
  --with-git-submodules=*)
      git_submodules_action="$optarg"
  ;;
  --enable-plugins) if test "$mingw32" = "yes"; then
                        error_exit "TCG plugins not currently supported on Windows platforms"
                    else
                        plugins="yes"
                    fi
  ;;
  --disable-plugins) plugins="no"
  ;;
  --enable-containers) use_containers="yes"
  ;;
  --disable-containers) use_containers="no"
  ;;
  --gdb=*) gdb_bin="$optarg"
  ;;
  --enable-keyring) secret_keyring="yes"
  ;;
  --disable-keyring) secret_keyring="no"
  ;;
  --enable-gio) gio=yes
  ;;
  --disable-gio) gio=no
  ;;
  # backwards compatibility options
  --enable-trace-backend=*) meson_option_parse "--enable-trace-backends=$optarg" "$optarg"
  ;;
  --disable-blobs) meson_option_parse --disable-install-blobs ""
  ;;
  --enable-tcmalloc) meson_option_parse --enable-malloc=tcmalloc tcmalloc
  ;;
  --enable-jemalloc) meson_option_parse --enable-malloc=jemalloc jemalloc
  ;;
  # everything else has the same name in configure and meson
  --enable-* | --disable-*) meson_option_parse "$opt" "$optarg"
  ;;
  *)
      echo "ERROR: unknown option $opt"
      echo "Try '$0 --help' for more information"
      exit 1
  ;;
  esac
done

# test for any invalid configuration combinations
if test "$plugins" = "yes" -a "$tcg" = "disabled"; then
    error_exit "Can't enable plugins on non-TCG builds"
fi

case $git_submodules_action in
    update|validate)
        if test ! -e "$source_path/.git"; then
            echo "ERROR: cannot $git_submodules_action git submodules without .git"
            exit 1
        fi
    ;;
    ignore)
        if ! test -f "$source_path/ui/keycodemapdb/README"
        then
            echo
            echo "ERROR: missing GIT submodules"
            echo
            if test -e "$source_path/.git"; then
                echo "--with-git-submodules=ignore specified but submodules were not"
                echo "checked out.  Please initialize and update submodules."
            else
                echo "This is not a GIT checkout but module content appears to"
                echo "be missing. Do not use 'git archive' or GitHub download links"
                echo "to acquire QEMU source archives. Non-GIT builds are only"
                echo "supported with source archives linked from:"
                echo
                echo "  https://www.qemu.org/download/#source"
                echo
                echo "Developers working with GIT can use scripts/archive-source.sh"
                echo "if they need to create valid source archives."
            fi
            echo
            exit 1
        fi
    ;;
    *)
        echo "ERROR: invalid --with-git-submodules= value '$git_submodules_action'"
        exit 1
    ;;
esac

libdir="${libdir:-$prefix/lib}"
libexecdir="${libexecdir:-$prefix/libexec}"
includedir="${includedir:-$prefix/include}"

if test "$mingw32" = "yes" ; then
    bindir="${bindir:-$prefix}"
else
    bindir="${bindir:-$prefix/bin}"
fi
mandir="${mandir:-$prefix/share/man}"
datadir="${datadir:-$prefix/share}"
docdir="${docdir:-$prefix/share/doc}"
sysconfdir="${sysconfdir:-$prefix/etc}"
local_statedir="${local_statedir:-$prefix/var}"
firmwarepath="${firmwarepath:-$datadir/qemu-firmware}"
localedir="${localedir:-$datadir/locale}"

if eval test -z "\${cross_cc_$cpu}"; then
    eval "cross_cc_${cpu}=\$cc"
    cross_cc_vars="$cross_cc_vars cross_cc_${cpu}"
fi

default_target_list=""
mak_wilds=""

if [ "$linux_user" != no ]; then
    if [ "$targetos" = linux ] && [ -d $source_path/linux-user/include/host/$cpu ]; then
        linux_user=yes
    elif [ "$linux_user" = yes ]; then
        error_exit "linux-user not supported on this architecture"
    fi
fi
if [ "$bsd_user" != no ]; then
    if [ "$bsd_user" = "" ]; then
        test $targetos = freebsd && bsd_user=yes
    fi
    if [ "$bsd_user" = yes ] && ! [ -d $source_path/bsd-user/$targetos ]; then
        error_exit "bsd-user not supported on this host OS"
    fi
fi
if [ "$softmmu" = "yes" ]; then
    mak_wilds="${mak_wilds} $source_path/configs/targets/*-softmmu.mak"
fi
if [ "$linux_user" = "yes" ]; then
    mak_wilds="${mak_wilds} $source_path/configs/targets/*-linux-user.mak"
fi
if [ "$bsd_user" = "yes" ]; then
    mak_wilds="${mak_wilds} $source_path/configs/targets/*-bsd-user.mak"
fi

for config in $mak_wilds; do
    target="$(basename "$config" .mak)"
    if echo "$target_list_exclude" | grep -vq "$target"; then
        default_target_list="${default_target_list} $target"
    fi
done

if test x"$show_help" = x"yes" ; then
cat << EOF

Usage: configure [options]
Options: [defaults in brackets after descriptions]

Standard options:
  --help                   print this message
  --prefix=PREFIX          install in PREFIX [$prefix]
  --interp-prefix=PREFIX   where to find shared libraries, etc.
                           use %M for cpu name [$interp_prefix]
  --target-list=LIST       set target list (default: build all)
$(echo Available targets: $default_target_list | \
  fold -s -w 53 | sed -e 's/^/                           /')
  --target-list-exclude=LIST exclude a set of targets from the default target-list

Advanced options (experts only):
  --cross-prefix=PREFIX    use PREFIX for compile tools, PREFIX can be blank [$cross_prefix]
  --cc=CC                  use C compiler CC [$cc]
  --iasl=IASL              use ACPI compiler IASL [$iasl]
  --host-cc=CC             use C compiler CC [$host_cc] for code run at
                           build time
  --cxx=CXX                use C++ compiler CXX [$cxx]
  --objcc=OBJCC            use Objective-C compiler OBJCC [$objcc]
  --extra-cflags=CFLAGS    append extra C compiler flags CFLAGS
  --extra-cxxflags=CXXFLAGS append extra C++ compiler flags CXXFLAGS
  --extra-objcflags=OBJCFLAGS append extra Objective C compiler flags OBJCFLAGS
  --extra-ldflags=LDFLAGS  append extra linker flags LDFLAGS
  --cross-cc-ARCH=CC       use compiler when building ARCH guest test cases
  --cross-cc-cflags-ARCH=  use compiler flags when building ARCH guest tests
  --make=MAKE              use specified make [$make]
  --python=PYTHON          use specified python [$python]
  --sphinx-build=SPHINX    use specified sphinx-build [$sphinx_build]
  --meson=MESON            use specified meson [$meson]
  --ninja=NINJA            use specified ninja [$ninja]
  --smbd=SMBD              use specified smbd [$smbd]
  --with-git=GIT           use specified git [$git]
  --with-git-submodules=update   update git submodules (default if .git dir exists)
  --with-git-submodules=validate fail if git submodules are not up to date
  --with-git-submodules=ignore   do not update or check git submodules (default if no .git dir)
  --static                 enable static build [$static]
  --mandir=PATH            install man pages in PATH
  --datadir=PATH           install firmware in PATH/$qemu_suffix
  --localedir=PATH         install translation in PATH/$qemu_suffix
  --docdir=PATH            install documentation in PATH/$qemu_suffix
  --bindir=PATH            install binaries in PATH
  --libdir=PATH            install libraries in PATH
  --libexecdir=PATH        install helper binaries in PATH
  --sysconfdir=PATH        install config in PATH/$qemu_suffix
  --localstatedir=PATH     install local state in PATH (set at runtime on win32)
  --firmwarepath=PATH      search PATH for firmware files
  --efi-aarch64=PATH       PATH of efi file to use for aarch64 VMs.
  --with-suffix=SUFFIX     suffix for QEMU data inside datadir/libdir/sysconfdir/docdir [$qemu_suffix]
  --with-pkgversion=VERS   use specified string as sub-version of the package
  --without-default-features default all --enable-* options to "disabled"
  --without-default-devices  do not include any device that is not needed to
                           start the emulator (only use if you are including
                           desired devices in configs/devices/)
  --with-devices-ARCH=NAME override default configs/devices
  --enable-debug           enable common debug build options
  --enable-sanitizers      enable default sanitizers
  --enable-tsan            enable thread sanitizer
  --disable-werror         disable compilation abort on warning
  --disable-stack-protector disable compiler-provided stack protection
  --audio-drv-list=LIST    set audio drivers to try if -audiodev is not used
  --block-drv-whitelist=L  Same as --block-drv-rw-whitelist=L
  --block-drv-rw-whitelist=L
                           set block driver read-write whitelist
                           (by default affects only QEMU, not tools like qemu-img)
  --block-drv-ro-whitelist=L
                           set block driver read-only whitelist
                           (by default affects only QEMU, not tools like qemu-img)
  --with-trace-file=NAME   Full PATH,NAME of file to store traces
                           Default:trace-<pid>
  --cpu=CPU                Build for host CPU [$cpu]
  --with-coroutine=BACKEND coroutine backend. Supported options:
                           ucontext, sigaltstack, windows
  --enable-gcov            enable test coverage analysis with gcov
  --tls-priority           default TLS protocol/cipher priority string
  --enable-plugins
                           enable plugins via shared library loading
  --disable-containers     don't use containers for cross-building
  --gdb=GDB-path           gdb to use for gdbstub tests [$gdb_bin]
EOF
  meson_options_help
cat << EOF
  system          all system emulation targets
  user            supported user emulation targets
  linux-user      all linux usermode emulation targets
  bsd-user        all BSD usermode emulation targets
  pie             Position Independent Executables
  modules         modules support (non-Windows)
  module-upgrades try to load modules from alternate paths for upgrades
  debug-tcg       TCG debugging (default is disabled)
  debug-info      debugging information
  lto             Enable Link-Time Optimization.
  safe-stack      SafeStack Stack Smash Protection. Depends on
                  clang/llvm >= 3.7 and requires coroutine backend ucontext.
  rdma            Enable RDMA-based migration
  pvrdma          Enable PVRDMA support
  vhost-net       vhost-net kernel acceleration support
  vhost-vsock     virtio sockets device support
  vhost-scsi      vhost-scsi kernel target support
  vhost-crypto    vhost-user-crypto backend support
  vhost-kernel    vhost kernel backend support
  vhost-user      vhost-user backend support
  vhost-vdpa      vhost-vdpa kernel backend support
  opengl          opengl support
  gio             libgio support

NOTE: The object files are built at the place where configure is launched
EOF
exit 0
fi

# Remove old dependency files to make sure that they get properly regenerated
rm -f */config-devices.mak.d

if test -z "$python"
then
    error_exit "Python not found. Use --python=/path/to/python"
fi
if ! has "$make"
then
    error_exit "GNU make ($make) not found"
fi

# Note that if the Python conditional here evaluates True we will exit
# with status 1 which is a shell 'false' value.
if ! $python -c 'import sys; sys.exit(sys.version_info < (3,6))'; then
  error_exit "Cannot use '$python', Python >= 3.6 is required." \
      "Use --python=/path/to/python to specify a supported Python."
fi

# Preserve python version since some functionality is dependent on it
python_version=$($python -c 'import sys; print("%d.%d.%d" % (sys.version_info[0], sys.version_info[1], sys.version_info[2]))' 2>/dev/null)

# Suppress writing compiled files
python="$python -B"

if test -z "$meson"; then
    if test "$explicit_python" = no && has meson && version_ge "$(meson --version)" 0.59.3; then
        meson=meson
    elif test $git_submodules_action != 'ignore' ; then
        meson=git
    elif test -e "${source_path}/meson/meson.py" ; then
        meson=internal
    else
        if test "$explicit_python" = yes; then
            error_exit "--python requires using QEMU's embedded Meson distribution, but it was not found."
        else
            error_exit "Meson not found.  Use --meson=/path/to/meson"
        fi
    fi
else
    # Meson uses its own Python interpreter to invoke other Python scripts,
    # but the user wants to use the one they specified with --python.
    #
    # We do not want to override the distro Python interpreter (and sometimes
    # cannot: for example in Homebrew /usr/bin/meson is a bash script), so
    # just require --meson=git|internal together with --python.
    if test "$explicit_python" = yes; then
        case "$meson" in
            git | internal) ;;
            *) error_exit "--python requires using QEMU's embedded Meson distribution." ;;
        esac
    fi
fi

if test "$meson" = git; then
    git_submodules="${git_submodules} meson"
fi

case "$meson" in
    git | internal)
        meson="$python ${source_path}/meson/meson.py"
        ;;
    *) meson=$(command -v "$meson") ;;
esac

# Probe for ninja

if test -z "$ninja"; then
    for c in ninja ninja-build samu; do
        if has $c; then
            ninja=$(command -v "$c")
            break
        fi
    done
    if test -z "$ninja"; then
      error_exit "Cannot find Ninja"
    fi
fi

# Check that the C compiler works. Doing this here before testing
# the host CPU ensures that we had a valid CC to autodetect the
# $cpu var (and we should bail right here if that's not the case).
# It also allows the help message to be printed without a CC.
write_c_skeleton;
if compile_object ; then
  : C compiler works ok
else
    error_exit "\"$cc\" either does not exist or does not work"
fi
if ! compile_prog ; then
    error_exit "\"$cc\" cannot build an executable (is your linker broken?)"
fi

# Consult white-list to determine whether to enable werror
# by default.  Only enable by default for git builds
if test -z "$werror" ; then
    if test "$git_submodules_action" != "ignore" && \
        { test "$linux" = "yes" || test "$mingw32" = "yes"; }; then
        werror="yes"
    else
        werror="no"
    fi
fi

if test "$targetos" = "bogus"; then
    # Now that we know that we're not printing the help and that
    # the compiler works (so the results of the check_defines we used
    # to identify the OS are reliable), if we didn't recognize the
    # host OS we should stop now.
    error_exit "Unrecognized host OS (uname -s reports '$(uname -s)')"
fi

# Check whether the compiler matches our minimum requirements:
cat > $TMPC << EOF
#if defined(__clang_major__) && defined(__clang_minor__)
# ifdef __apple_build_version__
#  if __clang_major__ < 10 || (__clang_major__ == 10 && __clang_minor__ < 0)
#   error You need at least XCode Clang v10.0 to compile QEMU
#  endif
# else
#  if __clang_major__ < 6 || (__clang_major__ == 6 && __clang_minor__ < 0)
#   error You need at least Clang v6.0 to compile QEMU
#  endif
# endif
#elif defined(__GNUC__) && defined(__GNUC_MINOR__)
# if __GNUC__ < 7 || (__GNUC__ == 7 && __GNUC_MINOR__ < 4)
#  error You need at least GCC v7.4.0 to compile QEMU
# endif
#else
# error You either need GCC or Clang to compiler QEMU
#endif
int main (void) { return 0; }
EOF
if ! compile_prog "" "" ; then
    error_exit "You need at least GCC v7.4 or Clang v6.0 (or XCode Clang v10.0)"
fi

# Accumulate -Wfoo and -Wno-bar separately.
# We will list all of the enable flags first, and the disable flags second.
# Note that we do not add -Werror, because that would enable it for all
# configure tests. If a configure test failed due to -Werror this would
# just silently disable some features, so it's too error prone.

warn_flags=
add_to warn_flags -Wold-style-declaration
add_to warn_flags -Wold-style-definition
add_to warn_flags -Wtype-limits
add_to warn_flags -Wformat-security
add_to warn_flags -Wformat-y2k
add_to warn_flags -Winit-self
add_to warn_flags -Wignored-qualifiers
add_to warn_flags -Wempty-body
add_to warn_flags -Wnested-externs
add_to warn_flags -Wendif-labels
add_to warn_flags -Wexpansion-to-defined
add_to warn_flags -Wimplicit-fallthrough=2

nowarn_flags=
add_to nowarn_flags -Wno-initializer-overrides
add_to nowarn_flags -Wno-missing-include-dirs
add_to nowarn_flags -Wno-shift-negative-value
add_to nowarn_flags -Wno-string-plus-int
add_to nowarn_flags -Wno-typedef-redefinition
add_to nowarn_flags -Wno-tautological-type-limit-compare
add_to nowarn_flags -Wno-psabi

gcc_flags="$warn_flags $nowarn_flags"

cc_has_warning_flag() {
    write_c_skeleton;

    # Use the positive sense of the flag when testing for -Wno-wombat
    # support (gcc will happily accept the -Wno- form of unknown
    # warning options).
    optflag="$(echo $1 | sed -e 's/^-Wno-/-W/')"
    compile_prog "-Werror $optflag" ""
}

objcc_has_warning_flag() {
    cat > $TMPM <<EOF
int main(void) { return 0; }
EOF

    # Use the positive sense of the flag when testing for -Wno-wombat
    # support (gcc will happily accept the -Wno- form of unknown
    # warning options).
    optflag="$(echo $1 | sed -e 's/^-Wno-/-W/')"
    do_objc -Werror $optflag \
      $OBJCFLAGS $EXTRA_OBJCFLAGS $CONFIGURE_OBJCFLAGS $QEMU_OBJCFLAGS \
      -o $TMPE $TMPM $QEMU_LDFLAGS
}

for flag in $gcc_flags; do
    if cc_has_warning_flag $flag ; then
        QEMU_CFLAGS="$QEMU_CFLAGS $flag"
    fi
    if objcc_has_warning_flag $flag ; then
        QEMU_OBJCFLAGS="$QEMU_OBJCFLAGS $flag"
    fi
done

if test "$stack_protector" != "no"; then
  cat > $TMPC << EOF
int main(int argc, char *argv[])
{
    char arr[64], *p = arr, *c = argv[0];
    while (*c) {
        *p++ = *c++;
    }
    return 0;
}
EOF
  gcc_flags="-fstack-protector-strong -fstack-protector-all"
  sp_on=0
  for flag in $gcc_flags; do
    # We need to check both a compile and a link, since some compiler
    # setups fail only on a .c->.o compile and some only at link time
    if compile_object "-Werror $flag" &&
       compile_prog "-Werror $flag" ""; then
      QEMU_CFLAGS="$QEMU_CFLAGS $flag"
      QEMU_LDFLAGS="$QEMU_LDFLAGS $flag"
      sp_on=1
      break
    fi
  done
  if test "$stack_protector" = yes; then
    if test $sp_on = 0; then
      error_exit "Stack protector not supported"
    fi
  fi
fi

# Disable -Wmissing-braces on older compilers that warn even for
# the "universal" C zero initializer {0}.
cat > $TMPC << EOF
struct {
  int a[2];
} x = {0};
EOF
if compile_object "-Werror" "" ; then
  :
else
  QEMU_CFLAGS="$QEMU_CFLAGS -Wno-missing-braces"
fi

# Our module code doesn't support Windows
if test "$modules" = "yes" && test "$mingw32" = "yes" ; then
  error_exit "Modules are not available for Windows"
fi

# module_upgrades is only reasonable if modules are enabled
if test "$modules" = "no" && test "$module_upgrades" = "yes" ; then
  error_exit "Can't enable module-upgrades as Modules are not enabled"
fi

# Static linking is not possible with plugins, modules or PIE
if test "$static" = "yes" ; then
  if test "$modules" = "yes" ; then
    error_exit "static and modules are mutually incompatible"
  fi
  if test "$plugins" = "yes"; then
    error_exit "static and plugins are mutually incompatible"
  else
    plugins="no"
  fi
fi
test "$plugins" = "" && plugins=yes

cat > $TMPC << EOF

#ifdef __linux__
#  define THREAD __thread
#else
#  define THREAD
#endif
static THREAD int tls_var;
int main(void) { return tls_var; }
EOF

# Check we support -fno-pie and -no-pie first; we will need the former for
# building ROMs, and both for everything if --disable-pie is passed.
if compile_prog "-Werror -fno-pie" "-no-pie"; then
  CFLAGS_NOPIE="-fno-pie"
  LDFLAGS_NOPIE="-no-pie"
fi

if test "$static" = "yes"; then
  if test "$pie" != "no" && compile_prog "-Werror -fPIE -DPIE" "-static-pie"; then
    CONFIGURE_CFLAGS="-fPIE -DPIE $CONFIGURE_CFLAGS"
    QEMU_LDFLAGS="-static-pie $QEMU_LDFLAGS"
    pie="yes"
  elif test "$pie" = "yes"; then
    error_exit "-static-pie not available due to missing toolchain support"
  else
    QEMU_LDFLAGS="-static $QEMU_LDFLAGS"
    pie="no"
  fi
elif test "$pie" = "no"; then
  CONFIGURE_CFLAGS="$CFLAGS_NOPIE $CONFIGURE_CFLAGS"
  CONFIGURE_LDFLAGS="$LDFLAGS_NOPIE $CONFIGURE_LDFLAGS"
elif compile_prog "-Werror -fPIE -DPIE" "-pie"; then
  CONFIGURE_CFLAGS="-fPIE -DPIE $CONFIGURE_CFLAGS"
  CONFIGURE_LDFLAGS="-pie $CONFIGURE_LDFLAGS"
  pie="yes"
elif test "$pie" = "yes"; then
  error_exit "PIE not available due to missing toolchain support"
else
  echo "Disabling PIE due to missing toolchain support"
  pie="no"
fi

# Detect support for PT_GNU_RELRO + DT_BIND_NOW.
# The combination is known as "full relro", because .got.plt is read-only too.
if compile_prog "" "-Wl,-z,relro -Wl,-z,now" ; then
  QEMU_LDFLAGS="-Wl,-z,relro -Wl,-z,now $QEMU_LDFLAGS"
fi

##########################################
# __sync_fetch_and_and requires at least -march=i486. Many toolchains
# use i686 as default anyway, but for those that don't, an explicit
# specification is necessary

if test "$cpu" = "i386"; then
  cat > $TMPC << EOF
static int sfaa(int *ptr)
{
  return __sync_fetch_and_and(ptr, 0);
}

int main(void)
{
  int val = 42;
  val = __sync_val_compare_and_swap(&val, 0, 1);
  sfaa(&val);
  return val;
}
EOF
  if ! compile_prog "" "" ; then
    QEMU_CFLAGS="-march=i486 $QEMU_CFLAGS"
  fi
fi

if test "$tcg" = "enabled"; then
    git_submodules="$git_submodules tests/fp/berkeley-testfloat-3"
    git_submodules="$git_submodules tests/fp/berkeley-softfloat-3"
fi

if test -z "${target_list+xxx}" ; then
    default_targets=yes
    for target in $default_target_list; do
        target_list="$target_list $target"
    done
    target_list="${target_list# }"
else
    default_targets=no
    target_list=$(echo "$target_list" | sed -e 's/,/ /g')
    for target in $target_list; do
        # Check that we recognised the target name; this allows a more
        # friendly error message than if we let it fall through.
        case " $default_target_list " in
            *" $target "*)
                ;;
            *)
                error_exit "Unknown target name '$target'"
                ;;
        esac
    done
fi

# see if system emulation was really requested
case " $target_list " in
  *"-softmmu "*) softmmu=yes
  ;;
  *) softmmu=no
  ;;
esac

feature_not_found() {
  feature=$1
  remedy=$2

  error_exit "User requested feature $feature" \
      "configure was not able to find it." \
      "$remedy"
}

# ---
# big/little endian test
cat > $TMPC << EOF
#include <stdio.h>
short big_endian[] = { 0x4269, 0x4765, 0x4e64, 0x4961, 0x4e00, 0, };
short little_endian[] = { 0x694c, 0x7454, 0x654c, 0x6e45, 0x6944, 0x6e41, 0, };
int main(int argc, char *argv[])
{
    return printf("%s %s\n", (char *)big_endian, (char *)little_endian);
}
EOF

if compile_prog ; then
    if strings -a $TMPE | grep -q BiGeNdIaN ; then
        bigendian="yes"
    elif strings -a $TMPE | grep -q LiTtLeEnDiAn ; then
        bigendian="no"
    else
        echo big/little test failed
        exit 1
    fi
else
    echo big/little test failed
    exit 1
fi

#########################################
# vhost interdependencies and host support

# vhost backends
if test "$vhost_user" = "yes" && test "$mingw32" = "yes"; then
  error_exit "vhost-user is not available on Windows"
fi
test "$vhost_vdpa" = "" && vhost_vdpa=$linux
if test "$vhost_vdpa" = "yes" && test "$linux" != "yes"; then
  error_exit "vhost-vdpa is only available on Linux"
fi
test "$vhost_kernel" = "" && vhost_kernel=$linux
if test "$vhost_kernel" = "yes" && test "$linux" != "yes"; then
  error_exit "vhost-kernel is only available on Linux"
fi

# vhost-kernel devices
test "$vhost_scsi" = "" && vhost_scsi=$vhost_kernel
if test "$vhost_scsi" = "yes" && test "$vhost_kernel" != "yes"; then
  error_exit "--enable-vhost-scsi requires --enable-vhost-kernel"
fi
test "$vhost_vsock" = "" && vhost_vsock=$vhost_kernel
if test "$vhost_vsock" = "yes" && test "$vhost_kernel" != "yes"; then
  error_exit "--enable-vhost-vsock requires --enable-vhost-kernel"
fi

# vhost-user backends
test "$vhost_net_user" = "" && vhost_net_user=$vhost_user
if test "$vhost_net_user" = "yes" && test "$vhost_user" = "no"; then
  error_exit "--enable-vhost-net-user requires --enable-vhost-user"
fi
test "$vhost_crypto" = "" && vhost_crypto=$vhost_user
if test "$vhost_crypto" = "yes" && test "$vhost_user" = "no"; then
  error_exit "--enable-vhost-crypto requires --enable-vhost-user"
fi
test "$vhost_user_fs" = "" && vhost_user_fs=$vhost_user
if test "$vhost_user_fs" = "yes" && test "$vhost_user" = "no"; then
  error_exit "--enable-vhost-user-fs requires --enable-vhost-user"
fi
#vhost-vdpa backends
test "$vhost_net_vdpa" = "" && vhost_net_vdpa=$vhost_vdpa
if test "$vhost_net_vdpa" = "yes" && test "$vhost_vdpa" = "no"; then
  error_exit "--enable-vhost-net-vdpa requires --enable-vhost-vdpa"
fi

# OR the vhost-kernel, vhost-vdpa and vhost-user values for simplicity
if test "$vhost_net" = ""; then
  test "$vhost_net_user" = "yes" && vhost_net=yes
  test "$vhost_net_vdpa" = "yes" && vhost_net=yes
  test "$vhost_kernel" = "yes" && vhost_net=yes
fi

##########################################
# pkg-config probe

if ! has "$pkg_config_exe"; then
  error_exit "pkg-config binary '$pkg_config_exe' not found"
fi

##########################################
# xen probe

if test "$xen" != "disabled" ; then
  # Check whether Xen library path is specified via --extra-ldflags to avoid
  # overriding this setting with pkg-config output. If not, try pkg-config
  # to obtain all needed flags.

  if ! echo $EXTRA_LDFLAGS | grep tools/libxc > /dev/null && \
     $pkg_config --exists xencontrol ; then
    xen_ctrl_version="$(printf '%d%02d%02d' \
      $($pkg_config --modversion xencontrol | sed 's/\./ /g') )"
    xen=enabled
    xen_pc="xencontrol xenstore xenforeignmemory xengnttab"
    xen_pc="$xen_pc xenevtchn xendevicemodel"
    if $pkg_config --exists xentoolcore; then
      xen_pc="$xen_pc xentoolcore"
    fi
    xen_cflags="$($pkg_config --cflags $xen_pc)"
    xen_libs="$($pkg_config --libs $xen_pc)"
  else

    xen_libs="-lxenstore -lxenctrl"
    xen_stable_libs="-lxenforeignmemory -lxengnttab -lxenevtchn"

    # First we test whether Xen headers and libraries are available.
    # If no, we are done and there is no Xen support.
    # If yes, more tests are run to detect the Xen version.

    # Xen (any)
    cat > $TMPC <<EOF
#include <xenctrl.h>
int main(void) {
  return 0;
}
EOF
    if ! compile_prog "" "$xen_libs" ; then
      # Xen not found
      if test "$xen" = "enabled" ; then
        feature_not_found "xen" "Install xen devel"
      fi
      xen=disabled

    # Xen unstable
    elif
        cat > $TMPC <<EOF &&
#undef XC_WANT_COMPAT_DEVICEMODEL_API
#define __XEN_TOOLS__
#include <xendevicemodel.h>
#include <xenforeignmemory.h>
int main(void) {
  xendevicemodel_handle *xd;
  xenforeignmemory_handle *xfmem;

  xd = xendevicemodel_open(0, 0);
  xendevicemodel_pin_memory_cacheattr(xd, 0, 0, 0, 0);

  xfmem = xenforeignmemory_open(0, 0);
  xenforeignmemory_map_resource(xfmem, 0, 0, 0, 0, 0, NULL, 0, 0);

  return 0;
}
EOF
        compile_prog "" "$xen_libs -lxendevicemodel $xen_stable_libs -lxentoolcore"
      then
      xen_stable_libs="-lxendevicemodel $xen_stable_libs -lxentoolcore"
      xen_ctrl_version=41100
      xen=enabled
    elif
        cat > $TMPC <<EOF &&
#undef XC_WANT_COMPAT_MAP_FOREIGN_API
#include <xenforeignmemory.h>
#include <xentoolcore.h>
int main(void) {
  xenforeignmemory_handle *xfmem;

  xfmem = xenforeignmemory_open(0, 0);
  xenforeignmemory_map2(xfmem, 0, 0, 0, 0, 0, 0, 0);
  xentoolcore_restrict_all(0);

  return 0;
}
EOF
        compile_prog "" "$xen_libs -lxendevicemodel $xen_stable_libs -lxentoolcore"
      then
      xen_stable_libs="-lxendevicemodel $xen_stable_libs -lxentoolcore"
      xen_ctrl_version=41000
      xen=enabled
    elif
        cat > $TMPC <<EOF &&
#undef XC_WANT_COMPAT_DEVICEMODEL_API
#define __XEN_TOOLS__
#include <xendevicemodel.h>
int main(void) {
  xendevicemodel_handle *xd;

  xd = xendevicemodel_open(0, 0);
  xendevicemodel_close(xd);

  return 0;
}
EOF
        compile_prog "" "$xen_libs -lxendevicemodel $xen_stable_libs"
      then
      xen_stable_libs="-lxendevicemodel $xen_stable_libs"
      xen_ctrl_version=40900
      xen=enabled
    elif
        cat > $TMPC <<EOF &&
/*
 * If we have stable libs the we don't want the libxc compat
 * layers, regardless of what CFLAGS we may have been given.
 *
 * Also, check if xengnttab_grant_copy_segment_t is defined and
 * grant copy operation is implemented.
 */
#undef XC_WANT_COMPAT_EVTCHN_API
#undef XC_WANT_COMPAT_GNTTAB_API
#undef XC_WANT_COMPAT_MAP_FOREIGN_API
#include <xenctrl.h>
#include <xenstore.h>
#include <xenevtchn.h>
#include <xengnttab.h>
#include <xenforeignmemory.h>
#include <stdint.h>
#include <xen/hvm/hvm_info_table.h>
#if !defined(HVM_MAX_VCPUS)
# error HVM_MAX_VCPUS not defined
#endif
int main(void) {
  xc_interface *xc = NULL;
  xenforeignmemory_handle *xfmem;
  xenevtchn_handle *xe;
  xengnttab_handle *xg;
  xengnttab_grant_copy_segment_t* seg = NULL;

  xs_daemon_open();

  xc = xc_interface_open(0, 0, 0);
  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);
  xc_domain_add_to_physmap(0, 0, XENMAPSPACE_gmfn, 0, 0);
  xc_hvm_inject_msi(xc, 0, 0xf0000000, 0x00000000);
  xc_hvm_create_ioreq_server(xc, 0, HVM_IOREQSRV_BUFIOREQ_ATOMIC, NULL);

  xfmem = xenforeignmemory_open(0, 0);
  xenforeignmemory_map(xfmem, 0, 0, 0, 0, 0);

  xe = xenevtchn_open(0, 0);
  xenevtchn_fd(xe);

  xg = xengnttab_open(0, 0);
  xengnttab_grant_copy(xg, 0, seg);

  return 0;
}
EOF
        compile_prog "" "$xen_libs $xen_stable_libs"
      then
      xen_ctrl_version=40800
      xen=enabled
    elif
        cat > $TMPC <<EOF &&
/*
 * If we have stable libs the we don't want the libxc compat
 * layers, regardless of what CFLAGS we may have been given.
 */
#undef XC_WANT_COMPAT_EVTCHN_API
#undef XC_WANT_COMPAT_GNTTAB_API
#undef XC_WANT_COMPAT_MAP_FOREIGN_API
#include <xenctrl.h>
#include <xenstore.h>
#include <xenevtchn.h>
#include <xengnttab.h>
#include <xenforeignmemory.h>
#include <stdint.h>
#include <xen/hvm/hvm_info_table.h>
#if !defined(HVM_MAX_VCPUS)
# error HVM_MAX_VCPUS not defined
#endif
int main(void) {
  xc_interface *xc = NULL;
  xenforeignmemory_handle *xfmem;
  xenevtchn_handle *xe;
  xengnttab_handle *xg;

  xs_daemon_open();

  xc = xc_interface_open(0, 0, 0);
  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);
  xc_domain_add_to_physmap(0, 0, XENMAPSPACE_gmfn, 0, 0);
  xc_hvm_inject_msi(xc, 0, 0xf0000000, 0x00000000);
  xc_hvm_create_ioreq_server(xc, 0, HVM_IOREQSRV_BUFIOREQ_ATOMIC, NULL);

  xfmem = xenforeignmemory_open(0, 0);
  xenforeignmemory_map(xfmem, 0, 0, 0, 0, 0);

  xe = xenevtchn_open(0, 0);
  xenevtchn_fd(xe);

  xg = xengnttab_open(0, 0);
  xengnttab_map_grant_ref(xg, 0, 0, 0);

  return 0;
}
EOF
        compile_prog "" "$xen_libs $xen_stable_libs"
      then
      xen_ctrl_version=40701
      xen=enabled

    # Xen 4.6
    elif
        cat > $TMPC <<EOF &&
#include <xenctrl.h>
#include <xenstore.h>
#include <stdint.h>
#include <xen/hvm/hvm_info_table.h>
#if !defined(HVM_MAX_VCPUS)
# error HVM_MAX_VCPUS not defined
#endif
int main(void) {
  xc_interface *xc;
  xs_daemon_open();
  xc = xc_interface_open(0, 0, 0);
  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);
  xc_gnttab_open(NULL, 0);
  xc_domain_add_to_physmap(0, 0, XENMAPSPACE_gmfn, 0, 0);
  xc_hvm_inject_msi(xc, 0, 0xf0000000, 0x00000000);
  xc_hvm_create_ioreq_server(xc, 0, HVM_IOREQSRV_BUFIOREQ_ATOMIC, NULL);
  xc_reserved_device_memory_map(xc, 0, 0, 0, 0, NULL, 0);
  return 0;
}
EOF
        compile_prog "" "$xen_libs"
      then
      xen_ctrl_version=40600
      xen=enabled

    # Xen 4.5
    elif
        cat > $TMPC <<EOF &&
#include <xenctrl.h>
#include <xenstore.h>
#include <stdint.h>
#include <xen/hvm/hvm_info_table.h>
#if !defined(HVM_MAX_VCPUS)
# error HVM_MAX_VCPUS not defined
#endif
int main(void) {
  xc_interface *xc;
  xs_daemon_open();
  xc = xc_interface_open(0, 0, 0);
  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);
  xc_gnttab_open(NULL, 0);
  xc_domain_add_to_physmap(0, 0, XENMAPSPACE_gmfn, 0, 0);
  xc_hvm_inject_msi(xc, 0, 0xf0000000, 0x00000000);
  xc_hvm_create_ioreq_server(xc, 0, 0, NULL);
  return 0;
}
EOF
        compile_prog "" "$xen_libs"
      then
      xen_ctrl_version=40500
      xen=enabled

    elif
        cat > $TMPC <<EOF &&
#include <xenctrl.h>
#include <xenstore.h>
#include <stdint.h>
#include <xen/hvm/hvm_info_table.h>
#if !defined(HVM_MAX_VCPUS)
# error HVM_MAX_VCPUS not defined
#endif
int main(void) {
  xc_interface *xc;
  xs_daemon_open();
  xc = xc_interface_open(0, 0, 0);
  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);
  xc_gnttab_open(NULL, 0);
  xc_domain_add_to_physmap(0, 0, XENMAPSPACE_gmfn, 0, 0);
  xc_hvm_inject_msi(xc, 0, 0xf0000000, 0x00000000);
  return 0;
}
EOF
        compile_prog "" "$xen_libs"
      then
      xen_ctrl_version=40200
      xen=enabled

    else
      if test "$xen" = "enabled" ; then
        feature_not_found "xen (unsupported version)" \
                          "Install a supported xen (xen 4.2 or newer)"
      fi
      xen=disabled
    fi

    if test "$xen" = enabled; then
      if test $xen_ctrl_version -ge 40701  ; then
        xen_libs="$xen_libs $xen_stable_libs "
      fi
    fi
  fi
fi

##########################################
# RDMA needs OpenFabrics libraries
if test "$rdma" != "no" ; then
  cat > $TMPC <<EOF
#include <rdma/rdma_cma.h>
int main(void) { return 0; }
EOF
  rdma_libs="-lrdmacm -libverbs -libumad"
  if compile_prog "" "$rdma_libs" ; then
    rdma="yes"
  else
    if test "$rdma" = "yes" ; then
        error_exit \
            " OpenFabrics librdmacm/libibverbs/libibumad not present." \
            " Your options:" \
            "  (1) Fast: Install infiniband packages (devel) from your distro." \
            "  (2) Cleanest: Install libraries from www.openfabrics.org" \
            "  (3) Also: Install softiwarp if you don't have RDMA hardware"
    fi
    rdma="no"
  fi
fi

##########################################
# PVRDMA detection

cat > $TMPC <<EOF &&
#include <sys/mman.h>

int
main(void)
{
    char buf = 0;
    void *addr = &buf;
    addr = mremap(addr, 0, 1, MREMAP_MAYMOVE | MREMAP_FIXED);

    return 0;
}
EOF

if test "$rdma" = "yes" ; then
    case "$pvrdma" in
    "")
        if compile_prog "" ""; then
            pvrdma="yes"
        else
            pvrdma="no"
        fi
        ;;
    "yes")
        if ! compile_prog "" ""; then
            error_exit "PVRDMA is not supported since mremap is not implemented"
        fi
        pvrdma="yes"
        ;;
    "no")
        pvrdma="no"
        ;;
    esac
else
    if test "$pvrdma" = "yes" ; then
        error_exit "PVRDMA requires rdma suppport"
    fi
    pvrdma="no"
fi

# Let's see if enhanced reg_mr is supported
if test "$pvrdma" = "yes" ; then

cat > $TMPC <<EOF &&
#include <infiniband/verbs.h>

int
main(void)
{
    struct ibv_mr *mr;
    struct ibv_pd *pd = NULL;
    size_t length = 10;
    uint64_t iova = 0;
    int access = 0;
    void *addr = NULL;

    mr = ibv_reg_mr_iova(pd, addr, length, iova, access);

    ibv_dereg_mr(mr);

    return 0;
}
EOF
    if ! compile_prog "" "-libverbs"; then
        QEMU_CFLAGS="$QEMU_CFLAGS -DLEGACY_RDMA_REG_MR"
    fi
fi

##########################################
# glib support probe

glib_req_ver=2.56
glib_modules=gthread-2.0
if test "$modules" = yes; then
    glib_modules="$glib_modules gmodule-export-2.0"
elif test "$plugins" = "yes"; then
    glib_modules="$glib_modules gmodule-no-export-2.0"
fi

for i in $glib_modules; do
    if $pkg_config --atleast-version=$glib_req_ver $i; then
        glib_cflags=$($pkg_config --cflags $i)
        glib_libs=$($pkg_config --libs $i)
    else
        error_exit "glib-$glib_req_ver $i is required to compile QEMU"
    fi
done

# This workaround is required due to a bug in pkg-config file for glib as it
# doesn't define GLIB_STATIC_COMPILATION for pkg-config --static

if test "$static" = yes && test "$mingw32" = yes; then
    glib_cflags="-DGLIB_STATIC_COMPILATION $glib_cflags"
fi

if ! test "$gio" = "no"; then
    pass=no
    if $pkg_config --atleast-version=$glib_req_ver gio-2.0; then
        gio_cflags=$($pkg_config --cflags gio-2.0)
        gio_libs=$($pkg_config --libs gio-2.0)
        gdbus_codegen=$($pkg_config --variable=gdbus_codegen gio-2.0)
        if ! has "$gdbus_codegen"; then
            gdbus_codegen=
        fi
        # Check that the libraries actually work -- Ubuntu 18.04 ships
        # with pkg-config --static --libs data for gio-2.0 that is missing
        # -lblkid and will give a link error.
        cat > $TMPC <<EOF
#include <gio/gio.h>
int main(void)
{
    g_dbus_proxy_new_sync(0, 0, 0, 0, 0, 0, 0, 0);
    return 0;
}
EOF
        if compile_prog "$gio_cflags" "$gio_libs" ; then
            pass=yes
        else
            pass=no
        fi

        if test "$pass" = "yes" &&
            $pkg_config --atleast-version=$glib_req_ver gio-unix-2.0; then
            gio_cflags="$gio_cflags $($pkg_config --cflags gio-unix-2.0)"
            gio_libs="$gio_libs $($pkg_config --libs gio-unix-2.0)"
        fi
    fi

    if test "$pass" = "no"; then
        if test "$gio" = "yes"; then
            feature_not_found "gio" "Install libgio >= 2.0"
        else
            gio=no
        fi
    else
        gio=yes
    fi
fi

# Sanity check that the current size_t matches the
# size that glib thinks it should be. This catches
# problems on multi-arch where people try to build
# 32-bit QEMU while pointing at 64-bit glib headers
cat > $TMPC <<EOF
#include <glib.h>
#include <unistd.h>

#define QEMU_BUILD_BUG_ON(x) \
  typedef char qemu_build_bug_on[(x)?-1:1] __attribute__((unused));

int main(void) {
   QEMU_BUILD_BUG_ON(sizeof(size_t) != GLIB_SIZEOF_SIZE_T);
   return 0;
}
EOF

if ! compile_prog "$glib_cflags" "$glib_libs" ; then
    error_exit "sizeof(size_t) doesn't match GLIB_SIZEOF_SIZE_T."\
               "You probably need to set PKG_CONFIG_LIBDIR"\
	       "to point to the right pkg-config files for your"\
	       "build target"
fi

# Silence clang warnings triggered by glib < 2.57.2
cat > $TMPC << EOF
#include <glib.h>
typedef struct Foo {
    int i;
} Foo;
static void foo_free(Foo *f)
{
    g_free(f);
}
G_DEFINE_AUTOPTR_CLEANUP_FUNC(Foo, foo_free)
int main(void) { return 0; }
EOF
if ! compile_prog "$glib_cflags -Werror" "$glib_libs" ; then
    if cc_has_warning_flag "-Wno-unused-function"; then
        glib_cflags="$glib_cflags -Wno-unused-function"
        CONFIGURE_CFLAGS="$CONFIGURE_CFLAGS -Wno-unused-function"
    fi
fi

##########################################
# SHA command probe for modules
if test "$modules" = yes; then
    shacmd_probe="sha1sum sha1 shasum"
    for c in $shacmd_probe; do
        if has $c; then
            shacmd="$c"
            break
        fi
    done
    if test "$shacmd" = ""; then
        error_exit "one of the checksum commands is required to enable modules: $shacmd_probe"
    fi
fi

##########################################
# fdt probe

case "$fdt" in
  auto | enabled | internal)
    # Simpler to always update submodule, even if not needed.
    git_submodules="${git_submodules} dtc"
    ;;
esac

##########################################
# opengl probe (for sdl2, gtk)

if test "$opengl" != "no" ; then
  epoxy=no
  if $pkg_config epoxy; then
    cat > $TMPC << EOF
#include <epoxy/egl.h>
int main(void) { return 0; }
EOF
    if compile_prog "" "" ; then
      epoxy=yes
    fi
  fi

  if test "$epoxy" = "yes" ; then
    opengl_cflags="$($pkg_config --cflags epoxy)"
    opengl_libs="$($pkg_config --libs epoxy)"
    opengl=yes
  else
    if test "$opengl" = "yes" ; then
      feature_not_found "opengl" "Please install epoxy with EGL"
    fi
    opengl_cflags=""
    opengl_libs=""
    opengl=no
  fi
fi

# check for usbfs
have_usbfs=no
if test "$linux_user" = "yes"; then
  cat > $TMPC << EOF
#include <linux/usbdevice_fs.h>

#ifndef USBDEVFS_GET_CAPABILITIES
#error "USBDEVFS_GET_CAPABILITIES undefined"
#endif

#ifndef USBDEVFS_DISCONNECT_CLAIM
#error "USBDEVFS_DISCONNECT_CLAIM undefined"
#endif

int main(void)
{
    return 0;
}
EOF
  if compile_prog "" ""; then
    have_usbfs=yes
  fi
fi

##########################################
# capstone

case "$capstone" in
  auto | enabled | internal)
    # Simpler to always update submodule, even if not needed.
    git_submodules="${git_submodules} capstone"
    ;;
esac

##########################################
# check and set a backend for coroutine

# We prefer ucontext, but it's not always possible. The fallback
# is sigcontext. On Windows the only valid backend is the Windows
# specific one.

ucontext_works=no
if test "$darwin" != "yes"; then
  cat > $TMPC << EOF
#include <ucontext.h>
#ifdef __stub_makecontext
#error Ignoring glibc stub makecontext which will always fail
#endif
int main(void) { makecontext(0, 0, 0); return 0; }
EOF
  if compile_prog "" "" ; then
    ucontext_works=yes
  fi
fi

if test "$coroutine" = ""; then
  if test "$mingw32" = "yes"; then
    coroutine=win32
  elif test "$ucontext_works" = "yes"; then
    coroutine=ucontext
  else
    coroutine=sigaltstack
  fi
else
  case $coroutine in
  windows)
    if test "$mingw32" != "yes"; then
      error_exit "'windows' coroutine backend only valid for Windows"
    fi
    # Unfortunately the user visible backend name doesn't match the
    # coroutine-*.c filename for this case, so we have to adjust it here.
    coroutine=win32
    ;;
  ucontext)
    if test "$ucontext_works" != "yes"; then
      feature_not_found "ucontext"
    fi
    ;;
  sigaltstack)
    if test "$mingw32" = "yes"; then
      error_exit "only the 'windows' coroutine backend is valid for Windows"
    fi
    ;;
  *)
    error_exit "unknown coroutine backend $coroutine"
    ;;
  esac
fi

##################################################
# SafeStack


if test "$safe_stack" = "yes"; then
cat > $TMPC << EOF
int main(int argc, char *argv[])
{
#if ! __has_feature(safe_stack)
#error SafeStack Disabled
#endif
    return 0;
}
EOF
  flag="-fsanitize=safe-stack"
  # Check that safe-stack is supported and enabled.
  if compile_prog "-Werror $flag" "$flag"; then
    # Flag needed both at compilation and at linking
    QEMU_CFLAGS="$QEMU_CFLAGS $flag"
    QEMU_LDFLAGS="$QEMU_LDFLAGS $flag"
  else
    error_exit "SafeStack not supported by your compiler"
  fi
  if test "$coroutine" != "ucontext"; then
    error_exit "SafeStack is only supported by the coroutine backend ucontext"
  fi
else
cat > $TMPC << EOF
int main(int argc, char *argv[])
{
#if defined(__has_feature)
#if __has_feature(safe_stack)
#error SafeStack Enabled
#endif
#endif
    return 0;
}
EOF
if test "$safe_stack" = "no"; then
  # Make sure that safe-stack is disabled
  if ! compile_prog "-Werror" ""; then
    # SafeStack was already enabled, try to explicitly remove the feature
    flag="-fno-sanitize=safe-stack"
    if ! compile_prog "-Werror $flag" "$flag"; then
      error_exit "Configure cannot disable SafeStack"
    fi
    QEMU_CFLAGS="$QEMU_CFLAGS $flag"
    QEMU_LDFLAGS="$QEMU_LDFLAGS $flag"
  fi
else # "$safe_stack" = ""
  # Set safe_stack to yes or no based on pre-existing flags
  if compile_prog "-Werror" ""; then
    safe_stack="no"
  else
    safe_stack="yes"
    if test "$coroutine" != "ucontext"; then
      error_exit "SafeStack is only supported by the coroutine backend ucontext"
    fi
  fi
fi
fi

########################################
# check if ccache is interfering with
# semantic analysis of macros

unset CCACHE_CPP2
ccache_cpp2=no
cat > $TMPC << EOF
static const int Z = 1;
#define fn() ({ Z; })
#define TAUT(X) ((X) == Z)
#define PAREN(X, Y) (X == Y)
#define ID(X) (X)
int main(int argc, char *argv[])
{
    int x = 0, y = 0;
    x = ID(x);
    x = fn();
    fn();
    if (PAREN(x, y)) return 0;
    if (TAUT(Z)) return 0;
    return 0;
}
EOF

if ! compile_object "-Werror"; then
    ccache_cpp2=yes
fi

#################################################
# clang does not support glibc + FORTIFY_SOURCE.

if test "$fortify_source" != "no"; then
  if echo | $cc -dM -E - | grep __clang__ > /dev/null 2>&1 ; then
    fortify_source="no";
  elif test -n "$cxx" && has $cxx &&
       echo | $cxx -dM -E - | grep __clang__ >/dev/null 2>&1 ; then
    fortify_source="no";
  else
    fortify_source="yes"
  fi
fi

##########################################
# checks for sanitizers

have_asan=no
have_ubsan=no
have_asan_iface_h=no
have_asan_iface_fiber=no

if test "$sanitizers" = "yes" ; then
  write_c_skeleton
  if compile_prog "$CPU_CFLAGS -Werror -fsanitize=address" ""; then
      have_asan=yes
  fi

  # we could use a simple skeleton for flags checks, but this also
  # detect the static linking issue of ubsan, see also:
  # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=84285
  cat > $TMPC << EOF
#include <stdlib.h>
int main(void) {
    void *tmp = malloc(10);
    if (tmp != NULL) {
        return *(int *)(tmp + 2);
    }
    return 1;
}
EOF
  if compile_prog "$CPU_CFLAGS -Werror -fsanitize=undefined" ""; then
      have_ubsan=yes
  fi

  if check_include "sanitizer/asan_interface.h" ; then
      have_asan_iface_h=yes
  fi

  cat > $TMPC << EOF
#include <sanitizer/asan_interface.h>
int main(void) {
  __sanitizer_start_switch_fiber(0, 0, 0);
  return 0;
}
EOF
  if compile_prog "$CPU_CFLAGS -Werror -fsanitize=address" "" ; then
      have_asan_iface_fiber=yes
  fi
fi

# Thread sanitizer is, for now, much noisier than the other sanitizers;
# keep it separate until that is not the case.
if test "$tsan" = "yes" && test "$sanitizers" = "yes"; then
  error_exit "TSAN is not supported with other sanitiziers."
fi
have_tsan=no
have_tsan_iface_fiber=no
if test "$tsan" = "yes" ; then
  write_c_skeleton
  if compile_prog "$CPU_CFLAGS -Werror -fsanitize=thread" "" ; then
      have_tsan=yes
  fi
  cat > $TMPC << EOF
#include <sanitizer/tsan_interface.h>
int main(void) {
  __tsan_create_fiber(0);
  return 0;
}
EOF
  if compile_prog "$CPU_CFLAGS -Werror -fsanitize=thread" "" ; then
      have_tsan_iface_fiber=yes
  fi
fi

##########################################
# check for slirp

case "$slirp" in
  auto | enabled | internal)
    # Simpler to always update submodule, even if not needed.
    git_submodules="${git_submodules} slirp"
    ;;
esac

##########################################
# check for usable __NR_keyctl syscall

if test "$linux" = "yes" ; then

    have_keyring=no
    cat > $TMPC << EOF
#include <errno.h>
#include <asm/unistd.h>
#include <linux/keyctl.h>
#include <unistd.h>
int main(void) {
    return syscall(__NR_keyctl, KEYCTL_READ, 0, NULL, NULL, 0);
}
EOF
    if compile_prog "" "" ; then
        have_keyring=yes
    fi
fi
if test "$secret_keyring" != "no"
then
    if test "$have_keyring" = "yes"
    then
	secret_keyring=yes
    else
	if test "$secret_keyring" = "yes"
	then
	    error_exit "syscall __NR_keyctl requested, \
but not implemented on your system"
	else
	    secret_keyring=no
	fi
    fi
fi

##########################################
# End of CC checks
# After here, no more $cc or $ld runs

write_c_skeleton

if test "$gcov" = "yes" ; then
  :
elif test "$fortify_source" = "yes" ; then
  QEMU_CFLAGS="-U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2 $QEMU_CFLAGS"
  debug=no
fi

case "$ARCH" in
alpha)
  # Ensure there's only a single GP
  QEMU_CFLAGS="-msmall-data $QEMU_CFLAGS"
;;
esac

if test "$have_asan" = "yes"; then
  QEMU_CFLAGS="-fsanitize=address $QEMU_CFLAGS"
  QEMU_LDFLAGS="-fsanitize=address $QEMU_LDFLAGS"
  if test "$have_asan_iface_h" = "no" ; then
      echo "ASAN build enabled, but ASAN header missing." \
           "Without code annotation, the report may be inferior."
  elif test "$have_asan_iface_fiber" = "no" ; then
      echo "ASAN build enabled, but ASAN header is too old." \
           "Without code annotation, the report may be inferior."
  fi
fi
if test "$have_tsan" = "yes" ; then
  if test "$have_tsan_iface_fiber" = "yes" ; then
    QEMU_CFLAGS="-fsanitize=thread $QEMU_CFLAGS"
    QEMU_LDFLAGS="-fsanitize=thread $QEMU_LDFLAGS"
  else
    error_exit "Cannot enable TSAN due to missing fiber annotation interface."
  fi
elif test "$tsan" = "yes" ; then
  error_exit "Cannot enable TSAN due to missing sanitize thread interface."
fi
if test "$have_ubsan" = "yes"; then
  QEMU_CFLAGS="-fsanitize=undefined $QEMU_CFLAGS"
  QEMU_LDFLAGS="-fsanitize=undefined $QEMU_LDFLAGS"
fi

##########################################

# Exclude --warn-common with TSan to suppress warnings from the TSan libraries.
if test "$solaris" = "no" && test "$tsan" = "no"; then
    if $ld --version 2>/dev/null | grep "GNU ld" >/dev/null 2>/dev/null ; then
        QEMU_LDFLAGS="-Wl,--warn-common $QEMU_LDFLAGS"
    fi
fi

# Use ASLR, no-SEH and DEP if available
if test "$mingw32" = "yes" ; then
    flags="--no-seh --nxcompat"

    # Disable ASLR for debug builds to allow debugging with gdb
    if test "$debug" = "no" ; then
        flags="--dynamicbase $flags"
    fi

    for flag in $flags; do
        if ld_has $flag ; then
            QEMU_LDFLAGS="-Wl,$flag $QEMU_LDFLAGS"
        fi
    done
fi

# Guest agent Windows MSI package

if test "$QEMU_GA_MANUFACTURER" = ""; then
  QEMU_GA_MANUFACTURER=QEMU
fi
if test "$QEMU_GA_DISTRO" = ""; then
  QEMU_GA_DISTRO=Linux
fi
if test "$QEMU_GA_VERSION" = ""; then
    QEMU_GA_VERSION=$(cat $source_path/VERSION)
fi

QEMU_GA_MSI_MINGW_DLL_PATH="$($pkg_config --variable=prefix glib-2.0)/bin"

# Mac OS X ships with a broken assembler
roms=
if { test "$cpu" = "i386" || test "$cpu" = "x86_64"; } && \
        test "$targetos" != "darwin" && test "$targetos" != "sunos" && \
        test "$targetos" != "haiku" && test "$softmmu" = yes ; then
    # Different host OS linkers have different ideas about the name of the ELF
    # emulation. Linux and OpenBSD/amd64 use 'elf_i386'; FreeBSD uses the _fbsd
    # variant; OpenBSD/i386 uses the _obsd variant; and Windows uses i386pe.
    for emu in elf_i386 elf_i386_fbsd elf_i386_obsd i386pe; do
        if "$ld" -verbose 2>&1 | grep -q "^[[:space:]]*$emu[[:space:]]*$"; then
            ld_i386_emulation="$emu"
            roms="optionrom"
            break
        fi
    done
fi

# Only build s390-ccw bios if we're on s390x and the compiler has -march=z900
# or -march=z10 (which is the lowest architecture level that Clang supports)
if test "$cpu" = "s390x" ; then
  write_c_skeleton
  compile_prog "-march=z900" ""
  has_z900=$?
  if [ $has_z900 = 0 ] || compile_object "-march=z10 -msoft-float -Werror"; then
    if [ $has_z900 != 0 ]; then
      echo "WARNING: Your compiler does not support the z900!"
      echo "         The s390-ccw bios will only work with guest CPUs >= z10."
    fi
    roms="$roms s390-ccw"
    # SLOF is required for building the s390-ccw firmware on s390x,
    # since it is using the libnet code from SLOF for network booting.
    git_submodules="${git_submodules} roms/SLOF"
  fi
fi

# Check that the C++ compiler exists and works with the C compiler.
# All the QEMU_CXXFLAGS are based on QEMU_CFLAGS. Keep this at the end to don't miss any other that could be added.
if has $cxx; then
    cat > $TMPC <<EOF
int c_function(void);
int main(void) { return c_function(); }
EOF

    compile_object

    cat > $TMPCXX <<EOF
extern "C" {
   int c_function(void);
}
int c_function(void) { return 42; }
EOF

    update_cxxflags

    if do_cxx $CXXFLAGS $EXTRA_CXXFLAGS $CONFIGURE_CXXFLAGS $QEMU_CXXFLAGS -o $TMPE $TMPCXX $TMPO $QEMU_LDFLAGS; then
        # C++ compiler $cxx works ok with C compiler $cc
        :
    else
        echo "C++ compiler $cxx does not work with C compiler $cc"
        echo "Disabling C++ specific optional code"
        cxx=
    fi
else
    echo "No C++ compiler available; disabling C++ specific optional code"
    cxx=
fi

if !(GIT="$git" "$source_path/scripts/git-submodule.sh" "$git_submodules_action" "$git_submodules"); then
    exit 1
fi

config_host_mak="config-host.mak"

echo "# Automatically generated by configure - do not modify" > $config_host_mak
echo >> $config_host_mak

echo all: >> $config_host_mak
echo "GIT=$git" >> $config_host_mak
echo "GIT_SUBMODULES=$git_submodules" >> $config_host_mak
echo "GIT_SUBMODULES_ACTION=$git_submodules_action" >> $config_host_mak

if test "$debug_tcg" = "yes" ; then
  echo "CONFIG_DEBUG_TCG=y" >> $config_host_mak
fi
if test "$mingw32" = "yes" ; then
  echo "CONFIG_WIN32=y" >> $config_host_mak
  echo "QEMU_GA_MSI_MINGW_DLL_PATH=${QEMU_GA_MSI_MINGW_DLL_PATH}" >> $config_host_mak
  echo "QEMU_GA_MANUFACTURER=${QEMU_GA_MANUFACTURER}" >> $config_host_mak
  echo "QEMU_GA_DISTRO=${QEMU_GA_DISTRO}" >> $config_host_mak
  echo "QEMU_GA_VERSION=${QEMU_GA_VERSION}" >> $config_host_mak
else
  echo "CONFIG_POSIX=y" >> $config_host_mak
fi

if test "$linux" = "yes" ; then
  echo "CONFIG_LINUX=y" >> $config_host_mak
fi

if test "$darwin" = "yes" ; then
  echo "CONFIG_DARWIN=y" >> $config_host_mak
fi

if test "$solaris" = "yes" ; then
  echo "CONFIG_SOLARIS=y" >> $config_host_mak
fi
if test "$static" = "yes" ; then
  echo "CONFIG_STATIC=y" >> $config_host_mak
fi
echo "CONFIG_BDRV_RW_WHITELIST=$block_drv_rw_whitelist" >> $config_host_mak
echo "CONFIG_BDRV_RO_WHITELIST=$block_drv_ro_whitelist" >> $config_host_mak
qemu_version=$(head $source_path/VERSION)
echo "PKGVERSION=$pkgversion" >>$config_host_mak
echo "SRC_PATH=$source_path" >> $config_host_mak
echo "TARGET_DIRS=$target_list" >> $config_host_mak
if test "$modules" = "yes"; then
  # $shacmd can generate a hash started with digit, which the compiler doesn't
  # like as an symbol. So prefix it with an underscore
  echo "CONFIG_STAMP=_$( (echo $qemu_version; echo $pkgversion; cat $0) | $shacmd - | cut -f1 -d\ )" >> $config_host_mak
  echo "CONFIG_MODULES=y" >> $config_host_mak
fi
if test "$module_upgrades" = "yes"; then
  echo "CONFIG_MODULE_UPGRADES=y" >> $config_host_mak
fi
if test "$have_usbfs" = "yes" ; then
  echo "CONFIG_USBFS=y" >> $config_host_mak
fi
if test "$gio" = "yes" ; then
    echo "CONFIG_GIO=y" >> $config_host_mak
    echo "GIO_CFLAGS=$gio_cflags" >> $config_host_mak
    echo "GIO_LIBS=$gio_libs" >> $config_host_mak
fi
if test "$gdbus_codegen" != "" ; then
    echo "GDBUS_CODEGEN=$gdbus_codegen" >> $config_host_mak
fi
echo "CONFIG_TLS_PRIORITY=\"$tls_priority\"" >> $config_host_mak

if test "$xen" = "enabled" ; then
  echo "CONFIG_XEN_BACKEND=y" >> $config_host_mak
  echo "CONFIG_XEN_CTRL_INTERFACE_VERSION=$xen_ctrl_version" >> $config_host_mak
  echo "XEN_CFLAGS=$xen_cflags" >> $config_host_mak
  echo "XEN_LIBS=$xen_libs" >> $config_host_mak
fi
if test "$vhost_scsi" = "yes" ; then
  echo "CONFIG_VHOST_SCSI=y" >> $config_host_mak
fi
if test "$vhost_net" = "yes" ; then
  echo "CONFIG_VHOST_NET=y" >> $config_host_mak
fi
if test "$vhost_net_user" = "yes" ; then
  echo "CONFIG_VHOST_NET_USER=y" >> $config_host_mak
fi
if test "$vhost_net_vdpa" = "yes" ; then
  echo "CONFIG_VHOST_NET_VDPA=y" >> $config_host_mak
fi
if test "$vhost_crypto" = "yes" ; then
  echo "CONFIG_VHOST_CRYPTO=y" >> $config_host_mak
fi
if test "$vhost_vsock" = "yes" ; then
  echo "CONFIG_VHOST_VSOCK=y" >> $config_host_mak
  if test "$vhost_user" = "yes" ; then
    echo "CONFIG_VHOST_USER_VSOCK=y" >> $config_host_mak
  fi
fi
if test "$vhost_kernel" = "yes" ; then
  echo "CONFIG_VHOST_KERNEL=y" >> $config_host_mak
fi
if test "$vhost_user" = "yes" ; then
  echo "CONFIG_VHOST_USER=y" >> $config_host_mak
fi
if test "$vhost_vdpa" = "yes" ; then
  echo "CONFIG_VHOST_VDPA=y" >> $config_host_mak
fi
if test "$vhost_user_fs" = "yes" ; then
  echo "CONFIG_VHOST_USER_FS=y" >> $config_host_mak
fi
if test "$tcg" = "enabled" -a "$tcg_interpreter" = "true" ; then
  echo "CONFIG_TCG_INTERPRETER=y" >> $config_host_mak
fi

if test "$opengl" = "yes" ; then
  echo "CONFIG_OPENGL=y" >> $config_host_mak
  echo "OPENGL_CFLAGS=$opengl_cflags" >> $config_host_mak
  echo "OPENGL_LIBS=$opengl_libs" >> $config_host_mak
fi

# XXX: suppress that
if [ "$bsd" = "yes" ] ; then
  echo "CONFIG_BSD=y" >> $config_host_mak
fi

echo "CONFIG_COROUTINE_BACKEND=$coroutine" >> $config_host_mak

if test "$have_asan_iface_fiber" = "yes" ; then
    echo "CONFIG_ASAN_IFACE_FIBER=y" >> $config_host_mak
fi

if test "$have_tsan" = "yes" && test "$have_tsan_iface_fiber" = "yes" ; then
    echo "CONFIG_TSAN=y" >> $config_host_mak
fi

if test "$rdma" = "yes" ; then
  echo "CONFIG_RDMA=y" >> $config_host_mak
  echo "RDMA_LIBS=$rdma_libs" >> $config_host_mak
fi

if test "$pvrdma" = "yes" ; then
  echo "CONFIG_PVRDMA=y" >> $config_host_mak
fi

if test "$plugins" = "yes" ; then
    echo "CONFIG_PLUGIN=y" >> $config_host_mak
fi

if test -n "$gdb_bin"; then
    gdb_version=$($gdb_bin --version | head -n 1)
    if version_ge ${gdb_version##* } 9.1; then
        echo "HAVE_GDB_BIN=$gdb_bin" >> $config_host_mak
    fi
fi

if test "$secret_keyring" = "yes" ; then
  echo "CONFIG_SECRET_KEYRING=y" >> $config_host_mak
fi

echo "ROMS=$roms" >> $config_host_mak
echo "MAKE=$make" >> $config_host_mak
echo "PYTHON=$python" >> $config_host_mak
echo "GENISOIMAGE=$genisoimage" >> $config_host_mak
echo "MESON=$meson" >> $config_host_mak
echo "NINJA=$ninja" >> $config_host_mak
echo "CC=$cc" >> $config_host_mak
echo "HOST_CC=$host_cc" >> $config_host_mak
echo "AR=$ar" >> $config_host_mak
echo "AS=$as" >> $config_host_mak
echo "CCAS=$ccas" >> $config_host_mak
echo "CPP=$cpp" >> $config_host_mak
echo "OBJCOPY=$objcopy" >> $config_host_mak
echo "LD=$ld" >> $config_host_mak
echo "CFLAGS_NOPIE=$CFLAGS_NOPIE" >> $config_host_mak
echo "QEMU_CFLAGS=$QEMU_CFLAGS" >> $config_host_mak
echo "QEMU_CXXFLAGS=$QEMU_CXXFLAGS" >> $config_host_mak
echo "QEMU_OBJCFLAGS=$QEMU_OBJCFLAGS" >> $config_host_mak
echo "GLIB_CFLAGS=$glib_cflags" >> $config_host_mak
echo "GLIB_LIBS=$glib_libs" >> $config_host_mak
echo "GLIB_VERSION=$(pkg-config --modversion glib-2.0)" >> $config_host_mak
echo "QEMU_LDFLAGS=$QEMU_LDFLAGS" >> $config_host_mak
echo "LD_I386_EMULATION=$ld_i386_emulation" >> $config_host_mak
echo "STRIP=$strip" >> $config_host_mak
echo "EXESUF=$EXESUF" >> $config_host_mak

# use included Linux headers
if test "$linux" = "yes" ; then
  mkdir -p linux-headers
  case "$cpu" in
  i386|x86_64)
    linux_arch=x86
    ;;
  ppc|ppc64)
    linux_arch=powerpc
    ;;
  s390x)
    linux_arch=s390
    ;;
  aarch64)
    linux_arch=arm64
    ;;
  loongarch*)
    linux_arch=loongarch
    ;;
  mips64)
    linux_arch=mips
    ;;
  *)
    # For most CPUs the kernel architecture name and QEMU CPU name match.
    linux_arch="$cpu"
    ;;
  esac
    # For non-KVM architectures we will not have asm headers
    if [ -e "$source_path/linux-headers/asm-$linux_arch" ]; then
      symlink "$source_path/linux-headers/asm-$linux_arch" linux-headers/asm
    fi
fi

for target in $target_list; do
    target_dir="$target"
    target_name=$(echo $target | cut -d '-' -f 1)$EXESUF
    mkdir -p $target_dir
    case $target in
        *-user) symlink "../qemu-$target_name" "$target_dir/qemu-$target_name" ;;
        *) symlink "../qemu-system-$target_name" "$target_dir/qemu-system-$target_name" ;;
    esac
done

echo "CONFIG_QEMU_INTERP_PREFIX=$interp_prefix" | sed 's/%M/@0@/' >> $config_host_mak
if test "$default_targets" = "yes"; then
  echo "CONFIG_DEFAULT_TARGETS=y" >> $config_host_mak
fi

if test "$ccache_cpp2" = "yes"; then
  echo "export CCACHE_CPP2=y" >> $config_host_mak
fi

if test "$safe_stack" = "yes"; then
  echo "CONFIG_SAFESTACK=y" >> $config_host_mak
fi

# If we're using a separate build tree, set it up now.
# LINKS are things to symlink back into the source tree
# (these can be both files and directories).
# Caution: do not add files or directories here using wildcards. This
# will result in problems later if a new file matching the wildcard is
# added to the source tree -- nothing will cause configure to be rerun
# so the build tree will be missing the link back to the new file, and
# tests might fail. Prefer to keep the relevant files in their own
# directory and symlink the directory instead.
LINKS="Makefile"
LINKS="$LINKS tests/tcg/Makefile.target"
LINKS="$LINKS pc-bios/optionrom/Makefile"
LINKS="$LINKS pc-bios/s390-ccw/Makefile"
LINKS="$LINKS roms/seabios/Makefile"
LINKS="$LINKS pc-bios/qemu-icon.bmp"
LINKS="$LINKS .gdbinit scripts" # scripts needed by relative path in .gdbinit
LINKS="$LINKS tests/avocado tests/data"
LINKS="$LINKS tests/qemu-iotests/check"
LINKS="$LINKS python"
LINKS="$LINKS contrib/plugins/Makefile "
for bios_file in \
    $source_path/pc-bios/*.bin \
    $source_path/pc-bios/*.elf \
    $source_path/pc-bios/*.lid \
    $source_path/pc-bios/*.rom \
    $source_path/pc-bios/*.dtb \
    $source_path/pc-bios/*.img \
    $source_path/pc-bios/openbios-* \
    $source_path/pc-bios/u-boot.* \
    $source_path/pc-bios/palcode-* \
    $source_path/pc-bios/qemu_vga.ndrv

do
    LINKS="$LINKS pc-bios/$(basename $bios_file)"
done
for f in $LINKS ; do
    if [ -e "$source_path/$f" ]; then
        mkdir -p `dirname ./$f`
        symlink "$source_path/$f" "$f"
    fi
done

(for i in $cross_cc_vars; do
  export $i
done
export target_list source_path use_containers cpu
$source_path/tests/tcg/configure.sh)

# temporary config to build submodules
if test -f $source_path/roms/seabios/Makefile; then
  for rom in seabios; do
    config_mak=roms/$rom/config.mak
    echo "# Automatically generated by configure - do not modify" > $config_mak
    echo "SRC_PATH=$source_path/roms/$rom" >> $config_mak
    echo "AS=$as" >> $config_mak
    echo "CCAS=$ccas" >> $config_mak
    echo "CC=$cc" >> $config_mak
    echo "BCC=bcc" >> $config_mak
    echo "CPP=$cpp" >> $config_mak
    echo "OBJCOPY=objcopy" >> $config_mak
    echo "IASL=$iasl" >> $config_mak
    echo "LD=$ld" >> $config_mak
    echo "RANLIB=$ranlib" >> $config_mak
  done
fi

config_mak=pc-bios/optionrom/config.mak
echo "# Automatically generated by configure - do not modify" > $config_mak
echo "TOPSRC_DIR=$source_path" >> $config_mak

if test "$skip_meson" = no; then
  cross="config-meson.cross.new"
  meson_quote() {
    test $# = 0 && return
    echo "'$(echo $* | sed "s/ /','/g")'"
  }

  echo "# Automatically generated by configure - do not modify" > $cross
  echo "[properties]" >> $cross

  # unroll any custom device configs
  for a in $device_archs; do
      eval "c=\$devices_${a}"
      echo "${a}-softmmu = '$c'" >> $cross
  done

  test -z "$cxx" && echo "link_language = 'c'" >> $cross
  echo "[built-in options]" >> $cross
  echo "c_args = [$(meson_quote $CFLAGS $EXTRA_CFLAGS)]" >> $cross
  echo "cpp_args = [$(meson_quote $CXXFLAGS $EXTRA_CXXFLAGS)]" >> $cross
  test -n "$objcc" && echo "objc_args = [$(meson_quote $OBJCFLAGS $EXTRA_OBJCFLAGS)]" >> $cross
  echo "c_link_args = [$(meson_quote $CFLAGS $LDFLAGS $EXTRA_CFLAGS $EXTRA_LDFLAGS)]" >> $cross
  echo "cpp_link_args = [$(meson_quote $CXXFLAGS $LDFLAGS $EXTRA_CXXFLAGS $EXTRA_LDFLAGS)]" >> $cross
  echo "[binaries]" >> $cross
  echo "c = [$(meson_quote $cc $CPU_CFLAGS)]" >> $cross
  test -n "$cxx" && echo "cpp = [$(meson_quote $cxx $CPU_CFLAGS)]" >> $cross
  test -n "$objcc" && echo "objc = [$(meson_quote $objcc $CPU_CFLAGS)]" >> $cross
  echo "ar = [$(meson_quote $ar)]" >> $cross
  echo "nm = [$(meson_quote $nm)]" >> $cross
  echo "pkgconfig = [$(meson_quote $pkg_config_exe)]" >> $cross
  echo "ranlib = [$(meson_quote $ranlib)]" >> $cross
  if has $sdl2_config; then
    echo "sdl2-config = [$(meson_quote $sdl2_config)]" >> $cross
  fi
  echo "strip = [$(meson_quote $strip)]" >> $cross
  echo "windres = [$(meson_quote $windres)]" >> $cross
  if test "$cross_compile" = "yes"; then
    cross_arg="--cross-file config-meson.cross"
    echo "[host_machine]" >> $cross
    echo "system = '$targetos'" >> $cross
    case "$cpu" in
        i386)
            echo "cpu_family = 'x86'" >> $cross
            ;;
        *)
            echo "cpu_family = '$cpu'" >> $cross
            ;;
    esac
    echo "cpu = '$cpu'" >> $cross
    if test "$bigendian" = "yes" ; then
        echo "endian = 'big'" >> $cross
    else
        echo "endian = 'little'" >> $cross
    fi
  else
    cross_arg="--native-file config-meson.cross"
  fi
  mv $cross config-meson.cross

  rm -rf meson-private meson-info meson-logs
  run_meson() {
    NINJA=$ninja $meson setup \
        --prefix "$prefix" \
        --libdir "$libdir" \
        --libexecdir "$libexecdir" \
        --bindir "$bindir" \
        --includedir "$includedir" \
        --datadir "$datadir" \
        --mandir "$mandir" \
        --sysconfdir "$sysconfdir" \
        --localedir "$localedir" \
        --localstatedir "$local_statedir" \
        -Daudio_drv_list=$audio_drv_list \
        -Ddefault_devices=$default_devices \
        -Ddocdir="$docdir" \
        -Diasl="$($iasl -h >/dev/null 2>&1 && printf %s "$iasl")" \
        -Dqemu_firmwarepath="$firmwarepath" \
        -Dqemu_suffix="$qemu_suffix" \
        -Dsmbd="$smbd" \
        -Dsphinx_build="$sphinx_build" \
        -Dtrace_file="$trace_file" \
        -Doptimization=$(if test "$debug" = yes; then echo 0; else echo 2; fi) \
        -Ddebug=$(if test "$debug_info" = yes; then echo true; else echo false; fi) \
        -Dwerror=$(if test "$werror" = yes; then echo true; else echo false; fi) \
        -Db_pie=$(if test "$pie" = yes; then echo true; else echo false; fi) \
        -Db_coverage=$(if test "$gcov" = yes; then echo true; else echo false; fi) \
        -Db_lto=$lto -Dcfi=$cfi -Dtcg=$tcg -Dxen=$xen \
        -Dcapstone=$capstone -Dfdt=$fdt -Dslirp=$slirp \
        $(test -n "${LIB_FUZZING_ENGINE+xxx}" && echo "-Dfuzzing_engine=$LIB_FUZZING_ENGINE") \
        $(if test "$default_feature" = no; then echo "-Dauto_features=disabled"; fi) \
        "$@" $cross_arg "$PWD" "$source_path"
  }
  eval run_meson $meson_options
  if test "$?" -ne 0 ; then
      error_exit "meson setup failed"
  fi
else
  if test -f meson-private/cmd_line.txt; then
    # Adjust old command line options whose type was changed
    # Avoids having to use "setup --wipe" when Meson is upgraded
    perl -i -ne '
      s/^gettext = true$/gettext = auto/;
      s/^gettext = false$/gettext = disabled/;
      /^b_staticpic/ && next;
      print;' meson-private/cmd_line.txt
  fi
fi

# Save the configure command line for later reuse.
cat <<EOD >config.status
#!/bin/sh
# Generated by configure.
# Run this file to recreate the current configuration.
# Compiler output produced by configure, useful for debugging
# configure, is in config.log if it exists.
EOD

preserve_env() {
    envname=$1

    eval envval=\$$envname

    if test -n "$envval"
    then
	echo "$envname='$envval'" >> config.status
	echo "export $envname" >> config.status
    else
	echo "unset $envname" >> config.status
    fi
}

# Preserve various env variables that influence what
# features/build target configure will detect
preserve_env AR
preserve_env AS
preserve_env CC
preserve_env CPP
preserve_env CFLAGS
preserve_env CXX
preserve_env CXXFLAGS
preserve_env INSTALL
preserve_env LD
preserve_env LDFLAGS
preserve_env LD_LIBRARY_PATH
preserve_env LIBTOOL
preserve_env MAKE
preserve_env NM
preserve_env OBJCOPY
preserve_env PATH
preserve_env PKG_CONFIG
preserve_env PKG_CONFIG_LIBDIR
preserve_env PKG_CONFIG_PATH
preserve_env PYTHON
preserve_env SDL2_CONFIG
preserve_env SMBD
preserve_env STRIP
preserve_env WINDRES

printf "exec" >>config.status
for i in "$0" "$@"; do
  test "$i" = --skip-meson || printf " %s" "$(quote_sh "$i")" >>config.status
done
echo ' "$@"' >>config.status
chmod +x config.status

rm -r "$TMPDIR1"
