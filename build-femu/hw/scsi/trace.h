/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_SCSI_GENERATED_TRACERS_H
#define TRACE_HW_SCSI_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_SCSI_REQ_ALLOC_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_CANCEL_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_DATA_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_DATA_CANCELED_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_DEQUEUE_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_CONTINUE_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_CONTINUE_CANCELED_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_PARSED_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_PARSED_LBA_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_PARSE_BAD_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_BUILD_SENSE_EVENT;
extern TraceEvent _TRACE_SCSI_DEVICE_SET_UA_EVENT;
extern TraceEvent _TRACE_SCSI_REPORT_LUNS_EVENT;
extern TraceEvent _TRACE_SCSI_INQUIRY_EVENT;
extern TraceEvent _TRACE_SCSI_TEST_UNIT_READY_EVENT;
extern TraceEvent _TRACE_SCSI_REQUEST_SENSE_EVENT;
extern TraceEvent _TRACE_MPTSAS_COMMAND_COMPLETE_EVENT;
extern TraceEvent _TRACE_MPTSAS_DIAG_READ_EVENT;
extern TraceEvent _TRACE_MPTSAS_DIAG_WRITE_EVENT;
extern TraceEvent _TRACE_MPTSAS_IRQ_INTX_EVENT;
extern TraceEvent _TRACE_MPTSAS_IRQ_MSI_EVENT;
extern TraceEvent _TRACE_MPTSAS_MMIO_READ_EVENT;
extern TraceEvent _TRACE_MPTSAS_MMIO_UNHANDLED_READ_EVENT;
extern TraceEvent _TRACE_MPTSAS_MMIO_UNHANDLED_WRITE_EVENT;
extern TraceEvent _TRACE_MPTSAS_MMIO_WRITE_EVENT;
extern TraceEvent _TRACE_MPTSAS_PROCESS_MESSAGE_EVENT;
extern TraceEvent _TRACE_MPTSAS_PROCESS_SCSI_IO_REQUEST_EVENT;
extern TraceEvent _TRACE_MPTSAS_RESET_EVENT;
extern TraceEvent _TRACE_MPTSAS_SCSI_OVERFLOW_EVENT;
extern TraceEvent _TRACE_MPTSAS_SGL_OVERFLOW_EVENT;
extern TraceEvent _TRACE_MPTSAS_UNHANDLED_CMD_EVENT;
extern TraceEvent _TRACE_MPTSAS_UNHANDLED_DOORBELL_CMD_EVENT;
extern TraceEvent _TRACE_MPTSAS_CONFIG_SAS_DEVICE_EVENT;
extern TraceEvent _TRACE_MPTSAS_CONFIG_SAS_PHY_EVENT;
extern TraceEvent _TRACE_MEGASAS_INIT_FIRMWARE_EVENT;
extern TraceEvent _TRACE_MEGASAS_INIT_QUEUE_EVENT;
extern TraceEvent _TRACE_MEGASAS_INITQ_MAP_FAILED_EVENT;
extern TraceEvent _TRACE_MEGASAS_INITQ_MAPPED_EVENT;
extern TraceEvent _TRACE_MEGASAS_INITQ_MISMATCH_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_MAPPED_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_NEW_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_BUSY_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_ENQUEUE_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_UPDATE_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_MAP_FAILED_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_COMPLETE_NOIRQ_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_COMPLETE_EVENT;
extern TraceEvent _TRACE_MEGASAS_FRAME_BUSY_EVENT;
extern TraceEvent _TRACE_MEGASAS_UNHANDLED_FRAME_CMD_EVENT;
extern TraceEvent _TRACE_MEGASAS_HANDLE_SCSI_EVENT;
extern TraceEvent _TRACE_MEGASAS_SCSI_TARGET_NOT_PRESENT_EVENT;
extern TraceEvent _TRACE_MEGASAS_SCSI_INVALID_CDB_LEN_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOV_READ_OVERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOV_WRITE_OVERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOV_READ_UNDERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOV_WRITE_UNDERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_SCSI_REQ_ALLOC_FAILED_EVENT;
extern TraceEvent _TRACE_MEGASAS_SCSI_READ_START_EVENT;
extern TraceEvent _TRACE_MEGASAS_SCSI_WRITE_START_EVENT;
extern TraceEvent _TRACE_MEGASAS_SCSI_NODATA_EVENT;
extern TraceEvent _TRACE_MEGASAS_SCSI_COMPLETE_EVENT;
extern TraceEvent _TRACE_MEGASAS_COMMAND_COMPLETE_EVENT;
extern TraceEvent _TRACE_MEGASAS_HANDLE_IO_EVENT;
extern TraceEvent _TRACE_MEGASAS_IO_TARGET_NOT_PRESENT_EVENT;
extern TraceEvent _TRACE_MEGASAS_IO_READ_START_EVENT;
extern TraceEvent _TRACE_MEGASAS_IO_WRITE_START_EVENT;
extern TraceEvent _TRACE_MEGASAS_IO_COMPLETE_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOVEC_SGL_OVERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOVEC_SGL_UNDERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOVEC_SGL_INVALID_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOVEC_OVERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOVEC_UNDERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_HANDLE_DCMD_EVENT;
extern TraceEvent _TRACE_MEGASAS_FINISH_DCMD_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_REQ_ALLOC_FAILED_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_INTERNAL_SUBMIT_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_INTERNAL_FINISH_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_INTERNAL_INVALID_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_UNHANDLED_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_ZERO_SGE_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_INVALID_SGE_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_INVALID_XFER_LEN_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_ENTER_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_DUMMY_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_SET_FW_TIME_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_PD_GET_LIST_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_LD_GET_LIST_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_LD_GET_INFO_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_LD_LIST_QUERY_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_PD_GET_INFO_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_PD_LIST_QUERY_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_RESET_LD_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_UNSUPPORTED_EVENT;
extern TraceEvent _TRACE_MEGASAS_ABORT_FRAME_EVENT;
extern TraceEvent _TRACE_MEGASAS_ABORT_NO_CMD_EVENT;
extern TraceEvent _TRACE_MEGASAS_ABORT_INVALID_CONTEXT_EVENT;
extern TraceEvent _TRACE_MEGASAS_RESET_EVENT;
extern TraceEvent _TRACE_MEGASAS_INIT_EVENT;
extern TraceEvent _TRACE_MEGASAS_MSIX_RAISE_EVENT;
extern TraceEvent _TRACE_MEGASAS_MSI_RAISE_EVENT;
extern TraceEvent _TRACE_MEGASAS_IRQ_LOWER_EVENT;
extern TraceEvent _TRACE_MEGASAS_IRQ_RAISE_EVENT;
extern TraceEvent _TRACE_MEGASAS_INTR_ENABLED_EVENT;
extern TraceEvent _TRACE_MEGASAS_INTR_DISABLED_EVENT;
extern TraceEvent _TRACE_MEGASAS_MSIX_ENABLED_EVENT;
extern TraceEvent _TRACE_MEGASAS_MSI_ENABLED_EVENT;
extern TraceEvent _TRACE_MEGASAS_MMIO_READL_EVENT;
extern TraceEvent _TRACE_MEGASAS_MMIO_INVALID_READL_EVENT;
extern TraceEvent _TRACE_MEGASAS_MMIO_WRITEL_EVENT;
extern TraceEvent _TRACE_MEGASAS_MMIO_INVALID_WRITEL_EVENT;
extern TraceEvent _TRACE_PVSCSI_RING_INIT_DATA_EVENT;
extern TraceEvent _TRACE_PVSCSI_RING_INIT_MSG_EVENT;
extern TraceEvent _TRACE_PVSCSI_RING_FLUSH_CMP_EVENT;
extern TraceEvent _TRACE_PVSCSI_RING_FLUSH_MSG_EVENT;
extern TraceEvent _TRACE_PVSCSI_UPDATE_IRQ_LEVEL_EVENT;
extern TraceEvent _TRACE_PVSCSI_UPDATE_IRQ_MSI_EVENT;
extern TraceEvent _TRACE_PVSCSI_CMP_RING_PUT_EVENT;
extern TraceEvent _TRACE_PVSCSI_MSG_RING_PUT_EVENT;
extern TraceEvent _TRACE_PVSCSI_COMPLETE_REQUEST_EVENT;
extern TraceEvent _TRACE_PVSCSI_GET_SG_LIST_EVENT;
extern TraceEvent _TRACE_PVSCSI_GET_NEXT_SG_ELEM_EVENT;
extern TraceEvent _TRACE_PVSCSI_COMMAND_COMPLETE_NOT_FOUND_EVENT;
extern TraceEvent _TRACE_PVSCSI_COMMAND_COMPLETE_DATA_RUN_EVENT;
extern TraceEvent _TRACE_PVSCSI_COMMAND_COMPLETE_SENSE_LEN_EVENT;
extern TraceEvent _TRACE_PVSCSI_CONVERT_SGLIST_EVENT;
extern TraceEvent _TRACE_PVSCSI_PROCESS_REQ_DESCR_EVENT;
extern TraceEvent _TRACE_PVSCSI_PROCESS_REQ_DESCR_UNKNOWN_DEVICE_EVENT;
extern TraceEvent _TRACE_PVSCSI_PROCESS_REQ_DESCR_INVALID_DIR_EVENT;
extern TraceEvent _TRACE_PVSCSI_PROCESS_IO_EVENT;
extern TraceEvent _TRACE_PVSCSI_ON_CMD_NOIMPL_EVENT;
extern TraceEvent _TRACE_PVSCSI_ON_CMD_RESET_DEV_EVENT;
extern TraceEvent _TRACE_PVSCSI_ON_CMD_ARRIVED_EVENT;
extern TraceEvent _TRACE_PVSCSI_ON_CMD_ABORT_EVENT;
extern TraceEvent _TRACE_PVSCSI_ON_CMD_UNKNOWN_EVENT;
extern TraceEvent _TRACE_PVSCSI_ON_CMD_UNKNOWN_DATA_EVENT;
extern TraceEvent _TRACE_PVSCSI_IO_WRITE_EVENT;
extern TraceEvent _TRACE_PVSCSI_IO_WRITE_UNKNOWN_EVENT;
extern TraceEvent _TRACE_PVSCSI_IO_READ_EVENT;
extern TraceEvent _TRACE_PVSCSI_IO_READ_UNKNOWN_EVENT;
extern TraceEvent _TRACE_PVSCSI_INIT_MSI_FAIL_EVENT;
extern TraceEvent _TRACE_PVSCSI_STATE_EVENT;
extern TraceEvent _TRACE_PVSCSI_TX_RINGS_PPN_EVENT;
extern TraceEvent _TRACE_PVSCSI_TX_RINGS_NUM_PAGES_EVENT;
extern TraceEvent _TRACE_ESP_ERROR_FIFO_OVERRUN_EVENT;
extern TraceEvent _TRACE_ESP_ERROR_UNHANDLED_COMMAND_EVENT;
extern TraceEvent _TRACE_ESP_ERROR_INVALID_WRITE_EVENT;
extern TraceEvent _TRACE_ESP_RAISE_IRQ_EVENT;
extern TraceEvent _TRACE_ESP_LOWER_IRQ_EVENT;
extern TraceEvent _TRACE_ESP_DMA_ENABLE_EVENT;
extern TraceEvent _TRACE_ESP_DMA_DISABLE_EVENT;
extern TraceEvent _TRACE_ESP_GET_CMD_EVENT;
extern TraceEvent _TRACE_ESP_DO_BUSID_CMD_EVENT;
extern TraceEvent _TRACE_ESP_HANDLE_SATN_STOP_EVENT;
extern TraceEvent _TRACE_ESP_WRITE_RESPONSE_EVENT;
extern TraceEvent _TRACE_ESP_DO_DMA_EVENT;
extern TraceEvent _TRACE_ESP_COMMAND_COMPLETE_EVENT;
extern TraceEvent _TRACE_ESP_COMMAND_COMPLETE_UNEXPECTED_EVENT;
extern TraceEvent _TRACE_ESP_COMMAND_COMPLETE_FAIL_EVENT;
extern TraceEvent _TRACE_ESP_TRANSFER_DATA_EVENT;
extern TraceEvent _TRACE_ESP_HANDLE_TI_EVENT;
extern TraceEvent _TRACE_ESP_HANDLE_TI_CMD_EVENT;
extern TraceEvent _TRACE_ESP_MEM_READB_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_NOP_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_FLUSH_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_RESET_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_BUS_RESET_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_ICCS_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_MSGACC_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_PAD_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_SATN_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_RSTATN_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_SEL_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_SELATN_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_SELATNS_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_ENSEL_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_DISSEL_EVENT;
extern TraceEvent _TRACE_ESP_PCI_ERROR_INVALID_DMA_DIRECTION_EVENT;
extern TraceEvent _TRACE_ESP_PCI_ERROR_INVALID_READ_EVENT;
extern TraceEvent _TRACE_ESP_PCI_ERROR_INVALID_WRITE_EVENT;
extern TraceEvent _TRACE_ESP_PCI_ERROR_INVALID_WRITE_DMA_EVENT;
extern TraceEvent _TRACE_ESP_PCI_DMA_READ_EVENT;
extern TraceEvent _TRACE_ESP_PCI_DMA_WRITE_EVENT;
extern TraceEvent _TRACE_ESP_PCI_DMA_IDLE_EVENT;
extern TraceEvent _TRACE_ESP_PCI_DMA_BLAST_EVENT;
extern TraceEvent _TRACE_ESP_PCI_DMA_ABORT_EVENT;
extern TraceEvent _TRACE_ESP_PCI_DMA_START_EVENT;
extern TraceEvent _TRACE_ESP_PCI_SBAC_READ_EVENT;
extern TraceEvent _TRACE_ESP_PCI_SBAC_WRITE_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_SEND_RSP_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_NO_DATA_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_DIRECT_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_RANGE_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_DMA_READ_ERROR_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_SEG_EXT_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_BOUNDARY_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_DONE_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_RW_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_BUF_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_SRP_TRANSFER_DATA_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_TRANSFER_DATA_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA1_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA2_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_STATUS_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_SAVE_REQUEST_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_LOAD_REQUEST_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_PROCESS_LOGIN_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_QUEUE_CMD_NO_DRIVE_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_QUEUE_CMD_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_DO_CRQ_EVENT;
extern uint16_t _TRACE_SCSI_REQ_ALLOC_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_CANCEL_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_DATA_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_DATA_CANCELED_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_DEQUEUE_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_CONTINUE_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_CONTINUE_CANCELED_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_PARSED_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_PARSED_LBA_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_PARSE_BAD_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_BUILD_SENSE_DSTATE;
extern uint16_t _TRACE_SCSI_DEVICE_SET_UA_DSTATE;
extern uint16_t _TRACE_SCSI_REPORT_LUNS_DSTATE;
extern uint16_t _TRACE_SCSI_INQUIRY_DSTATE;
extern uint16_t _TRACE_SCSI_TEST_UNIT_READY_DSTATE;
extern uint16_t _TRACE_SCSI_REQUEST_SENSE_DSTATE;
extern uint16_t _TRACE_MPTSAS_COMMAND_COMPLETE_DSTATE;
extern uint16_t _TRACE_MPTSAS_DIAG_READ_DSTATE;
extern uint16_t _TRACE_MPTSAS_DIAG_WRITE_DSTATE;
extern uint16_t _TRACE_MPTSAS_IRQ_INTX_DSTATE;
extern uint16_t _TRACE_MPTSAS_IRQ_MSI_DSTATE;
extern uint16_t _TRACE_MPTSAS_MMIO_READ_DSTATE;
extern uint16_t _TRACE_MPTSAS_MMIO_UNHANDLED_READ_DSTATE;
extern uint16_t _TRACE_MPTSAS_MMIO_UNHANDLED_WRITE_DSTATE;
extern uint16_t _TRACE_MPTSAS_MMIO_WRITE_DSTATE;
extern uint16_t _TRACE_MPTSAS_PROCESS_MESSAGE_DSTATE;
extern uint16_t _TRACE_MPTSAS_PROCESS_SCSI_IO_REQUEST_DSTATE;
extern uint16_t _TRACE_MPTSAS_RESET_DSTATE;
extern uint16_t _TRACE_MPTSAS_SCSI_OVERFLOW_DSTATE;
extern uint16_t _TRACE_MPTSAS_SGL_OVERFLOW_DSTATE;
extern uint16_t _TRACE_MPTSAS_UNHANDLED_CMD_DSTATE;
extern uint16_t _TRACE_MPTSAS_UNHANDLED_DOORBELL_CMD_DSTATE;
extern uint16_t _TRACE_MPTSAS_CONFIG_SAS_DEVICE_DSTATE;
extern uint16_t _TRACE_MPTSAS_CONFIG_SAS_PHY_DSTATE;
extern uint16_t _TRACE_MEGASAS_INIT_FIRMWARE_DSTATE;
extern uint16_t _TRACE_MEGASAS_INIT_QUEUE_DSTATE;
extern uint16_t _TRACE_MEGASAS_INITQ_MAP_FAILED_DSTATE;
extern uint16_t _TRACE_MEGASAS_INITQ_MAPPED_DSTATE;
extern uint16_t _TRACE_MEGASAS_INITQ_MISMATCH_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_MAPPED_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_NEW_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_BUSY_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_ENQUEUE_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_UPDATE_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_MAP_FAILED_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_COMPLETE_NOIRQ_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_COMPLETE_DSTATE;
extern uint16_t _TRACE_MEGASAS_FRAME_BUSY_DSTATE;
extern uint16_t _TRACE_MEGASAS_UNHANDLED_FRAME_CMD_DSTATE;
extern uint16_t _TRACE_MEGASAS_HANDLE_SCSI_DSTATE;
extern uint16_t _TRACE_MEGASAS_SCSI_TARGET_NOT_PRESENT_DSTATE;
extern uint16_t _TRACE_MEGASAS_SCSI_INVALID_CDB_LEN_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOV_READ_OVERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOV_WRITE_OVERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOV_READ_UNDERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOV_WRITE_UNDERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_SCSI_REQ_ALLOC_FAILED_DSTATE;
extern uint16_t _TRACE_MEGASAS_SCSI_READ_START_DSTATE;
extern uint16_t _TRACE_MEGASAS_SCSI_WRITE_START_DSTATE;
extern uint16_t _TRACE_MEGASAS_SCSI_NODATA_DSTATE;
extern uint16_t _TRACE_MEGASAS_SCSI_COMPLETE_DSTATE;
extern uint16_t _TRACE_MEGASAS_COMMAND_COMPLETE_DSTATE;
extern uint16_t _TRACE_MEGASAS_HANDLE_IO_DSTATE;
extern uint16_t _TRACE_MEGASAS_IO_TARGET_NOT_PRESENT_DSTATE;
extern uint16_t _TRACE_MEGASAS_IO_READ_START_DSTATE;
extern uint16_t _TRACE_MEGASAS_IO_WRITE_START_DSTATE;
extern uint16_t _TRACE_MEGASAS_IO_COMPLETE_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOVEC_SGL_OVERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOVEC_SGL_UNDERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOVEC_SGL_INVALID_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOVEC_OVERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOVEC_UNDERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_HANDLE_DCMD_DSTATE;
extern uint16_t _TRACE_MEGASAS_FINISH_DCMD_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_REQ_ALLOC_FAILED_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_INTERNAL_SUBMIT_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_INTERNAL_FINISH_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_INTERNAL_INVALID_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_UNHANDLED_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_ZERO_SGE_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_INVALID_SGE_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_INVALID_XFER_LEN_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_ENTER_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_DUMMY_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_SET_FW_TIME_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_PD_GET_LIST_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_LD_GET_LIST_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_LD_GET_INFO_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_LD_LIST_QUERY_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_PD_GET_INFO_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_PD_LIST_QUERY_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_RESET_LD_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_UNSUPPORTED_DSTATE;
extern uint16_t _TRACE_MEGASAS_ABORT_FRAME_DSTATE;
extern uint16_t _TRACE_MEGASAS_ABORT_NO_CMD_DSTATE;
extern uint16_t _TRACE_MEGASAS_ABORT_INVALID_CONTEXT_DSTATE;
extern uint16_t _TRACE_MEGASAS_RESET_DSTATE;
extern uint16_t _TRACE_MEGASAS_INIT_DSTATE;
extern uint16_t _TRACE_MEGASAS_MSIX_RAISE_DSTATE;
extern uint16_t _TRACE_MEGASAS_MSI_RAISE_DSTATE;
extern uint16_t _TRACE_MEGASAS_IRQ_LOWER_DSTATE;
extern uint16_t _TRACE_MEGASAS_IRQ_RAISE_DSTATE;
extern uint16_t _TRACE_MEGASAS_INTR_ENABLED_DSTATE;
extern uint16_t _TRACE_MEGASAS_INTR_DISABLED_DSTATE;
extern uint16_t _TRACE_MEGASAS_MSIX_ENABLED_DSTATE;
extern uint16_t _TRACE_MEGASAS_MSI_ENABLED_DSTATE;
extern uint16_t _TRACE_MEGASAS_MMIO_READL_DSTATE;
extern uint16_t _TRACE_MEGASAS_MMIO_INVALID_READL_DSTATE;
extern uint16_t _TRACE_MEGASAS_MMIO_WRITEL_DSTATE;
extern uint16_t _TRACE_MEGASAS_MMIO_INVALID_WRITEL_DSTATE;
extern uint16_t _TRACE_PVSCSI_RING_INIT_DATA_DSTATE;
extern uint16_t _TRACE_PVSCSI_RING_INIT_MSG_DSTATE;
extern uint16_t _TRACE_PVSCSI_RING_FLUSH_CMP_DSTATE;
extern uint16_t _TRACE_PVSCSI_RING_FLUSH_MSG_DSTATE;
extern uint16_t _TRACE_PVSCSI_UPDATE_IRQ_LEVEL_DSTATE;
extern uint16_t _TRACE_PVSCSI_UPDATE_IRQ_MSI_DSTATE;
extern uint16_t _TRACE_PVSCSI_CMP_RING_PUT_DSTATE;
extern uint16_t _TRACE_PVSCSI_MSG_RING_PUT_DSTATE;
extern uint16_t _TRACE_PVSCSI_COMPLETE_REQUEST_DSTATE;
extern uint16_t _TRACE_PVSCSI_GET_SG_LIST_DSTATE;
extern uint16_t _TRACE_PVSCSI_GET_NEXT_SG_ELEM_DSTATE;
extern uint16_t _TRACE_PVSCSI_COMMAND_COMPLETE_NOT_FOUND_DSTATE;
extern uint16_t _TRACE_PVSCSI_COMMAND_COMPLETE_DATA_RUN_DSTATE;
extern uint16_t _TRACE_PVSCSI_COMMAND_COMPLETE_SENSE_LEN_DSTATE;
extern uint16_t _TRACE_PVSCSI_CONVERT_SGLIST_DSTATE;
extern uint16_t _TRACE_PVSCSI_PROCESS_REQ_DESCR_DSTATE;
extern uint16_t _TRACE_PVSCSI_PROCESS_REQ_DESCR_UNKNOWN_DEVICE_DSTATE;
extern uint16_t _TRACE_PVSCSI_PROCESS_REQ_DESCR_INVALID_DIR_DSTATE;
extern uint16_t _TRACE_PVSCSI_PROCESS_IO_DSTATE;
extern uint16_t _TRACE_PVSCSI_ON_CMD_NOIMPL_DSTATE;
extern uint16_t _TRACE_PVSCSI_ON_CMD_RESET_DEV_DSTATE;
extern uint16_t _TRACE_PVSCSI_ON_CMD_ARRIVED_DSTATE;
extern uint16_t _TRACE_PVSCSI_ON_CMD_ABORT_DSTATE;
extern uint16_t _TRACE_PVSCSI_ON_CMD_UNKNOWN_DSTATE;
extern uint16_t _TRACE_PVSCSI_ON_CMD_UNKNOWN_DATA_DSTATE;
extern uint16_t _TRACE_PVSCSI_IO_WRITE_DSTATE;
extern uint16_t _TRACE_PVSCSI_IO_WRITE_UNKNOWN_DSTATE;
extern uint16_t _TRACE_PVSCSI_IO_READ_DSTATE;
extern uint16_t _TRACE_PVSCSI_IO_READ_UNKNOWN_DSTATE;
extern uint16_t _TRACE_PVSCSI_INIT_MSI_FAIL_DSTATE;
extern uint16_t _TRACE_PVSCSI_STATE_DSTATE;
extern uint16_t _TRACE_PVSCSI_TX_RINGS_PPN_DSTATE;
extern uint16_t _TRACE_PVSCSI_TX_RINGS_NUM_PAGES_DSTATE;
extern uint16_t _TRACE_ESP_ERROR_FIFO_OVERRUN_DSTATE;
extern uint16_t _TRACE_ESP_ERROR_UNHANDLED_COMMAND_DSTATE;
extern uint16_t _TRACE_ESP_ERROR_INVALID_WRITE_DSTATE;
extern uint16_t _TRACE_ESP_RAISE_IRQ_DSTATE;
extern uint16_t _TRACE_ESP_LOWER_IRQ_DSTATE;
extern uint16_t _TRACE_ESP_DMA_ENABLE_DSTATE;
extern uint16_t _TRACE_ESP_DMA_DISABLE_DSTATE;
extern uint16_t _TRACE_ESP_GET_CMD_DSTATE;
extern uint16_t _TRACE_ESP_DO_BUSID_CMD_DSTATE;
extern uint16_t _TRACE_ESP_HANDLE_SATN_STOP_DSTATE;
extern uint16_t _TRACE_ESP_WRITE_RESPONSE_DSTATE;
extern uint16_t _TRACE_ESP_DO_DMA_DSTATE;
extern uint16_t _TRACE_ESP_COMMAND_COMPLETE_DSTATE;
extern uint16_t _TRACE_ESP_COMMAND_COMPLETE_UNEXPECTED_DSTATE;
extern uint16_t _TRACE_ESP_COMMAND_COMPLETE_FAIL_DSTATE;
extern uint16_t _TRACE_ESP_TRANSFER_DATA_DSTATE;
extern uint16_t _TRACE_ESP_HANDLE_TI_DSTATE;
extern uint16_t _TRACE_ESP_HANDLE_TI_CMD_DSTATE;
extern uint16_t _TRACE_ESP_MEM_READB_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_NOP_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_FLUSH_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_RESET_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_BUS_RESET_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_ICCS_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_MSGACC_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_PAD_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_SATN_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_RSTATN_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_SEL_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_SELATN_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_SELATNS_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_ENSEL_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_DISSEL_DSTATE;
extern uint16_t _TRACE_ESP_PCI_ERROR_INVALID_DMA_DIRECTION_DSTATE;
extern uint16_t _TRACE_ESP_PCI_ERROR_INVALID_READ_DSTATE;
extern uint16_t _TRACE_ESP_PCI_ERROR_INVALID_WRITE_DSTATE;
extern uint16_t _TRACE_ESP_PCI_ERROR_INVALID_WRITE_DMA_DSTATE;
extern uint16_t _TRACE_ESP_PCI_DMA_READ_DSTATE;
extern uint16_t _TRACE_ESP_PCI_DMA_WRITE_DSTATE;
extern uint16_t _TRACE_ESP_PCI_DMA_IDLE_DSTATE;
extern uint16_t _TRACE_ESP_PCI_DMA_BLAST_DSTATE;
extern uint16_t _TRACE_ESP_PCI_DMA_ABORT_DSTATE;
extern uint16_t _TRACE_ESP_PCI_DMA_START_DSTATE;
extern uint16_t _TRACE_ESP_PCI_SBAC_READ_DSTATE;
extern uint16_t _TRACE_ESP_PCI_SBAC_WRITE_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_SEND_RSP_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_NO_DATA_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_DIRECT_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_RANGE_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_DMA_READ_ERROR_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_SEG_EXT_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_BOUNDARY_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_DONE_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_RW_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_BUF_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_SRP_TRANSFER_DATA_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_TRANSFER_DATA_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA1_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA2_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_STATUS_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_SAVE_REQUEST_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_LOAD_REQUEST_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_PROCESS_LOGIN_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_QUEUE_CMD_NO_DRIVE_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_QUEUE_CMD_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_DO_CRQ_DSTATE;
#define TRACE_SCSI_REQ_ALLOC_ENABLED 1
#define TRACE_SCSI_REQ_CANCEL_ENABLED 1
#define TRACE_SCSI_REQ_DATA_ENABLED 1
#define TRACE_SCSI_REQ_DATA_CANCELED_ENABLED 1
#define TRACE_SCSI_REQ_DEQUEUE_ENABLED 1
#define TRACE_SCSI_REQ_CONTINUE_ENABLED 1
#define TRACE_SCSI_REQ_CONTINUE_CANCELED_ENABLED 1
#define TRACE_SCSI_REQ_PARSED_ENABLED 1
#define TRACE_SCSI_REQ_PARSED_LBA_ENABLED 1
#define TRACE_SCSI_REQ_PARSE_BAD_ENABLED 1
#define TRACE_SCSI_REQ_BUILD_SENSE_ENABLED 1
#define TRACE_SCSI_DEVICE_SET_UA_ENABLED 1
#define TRACE_SCSI_REPORT_LUNS_ENABLED 1
#define TRACE_SCSI_INQUIRY_ENABLED 1
#define TRACE_SCSI_TEST_UNIT_READY_ENABLED 1
#define TRACE_SCSI_REQUEST_SENSE_ENABLED 1
#define TRACE_MPTSAS_COMMAND_COMPLETE_ENABLED 1
#define TRACE_MPTSAS_DIAG_READ_ENABLED 1
#define TRACE_MPTSAS_DIAG_WRITE_ENABLED 1
#define TRACE_MPTSAS_IRQ_INTX_ENABLED 1
#define TRACE_MPTSAS_IRQ_MSI_ENABLED 1
#define TRACE_MPTSAS_MMIO_READ_ENABLED 1
#define TRACE_MPTSAS_MMIO_UNHANDLED_READ_ENABLED 1
#define TRACE_MPTSAS_MMIO_UNHANDLED_WRITE_ENABLED 1
#define TRACE_MPTSAS_MMIO_WRITE_ENABLED 1
#define TRACE_MPTSAS_PROCESS_MESSAGE_ENABLED 1
#define TRACE_MPTSAS_PROCESS_SCSI_IO_REQUEST_ENABLED 1
#define TRACE_MPTSAS_RESET_ENABLED 1
#define TRACE_MPTSAS_SCSI_OVERFLOW_ENABLED 1
#define TRACE_MPTSAS_SGL_OVERFLOW_ENABLED 1
#define TRACE_MPTSAS_UNHANDLED_CMD_ENABLED 1
#define TRACE_MPTSAS_UNHANDLED_DOORBELL_CMD_ENABLED 1
#define TRACE_MPTSAS_CONFIG_SAS_DEVICE_ENABLED 1
#define TRACE_MPTSAS_CONFIG_SAS_PHY_ENABLED 1
#define TRACE_MEGASAS_INIT_FIRMWARE_ENABLED 1
#define TRACE_MEGASAS_INIT_QUEUE_ENABLED 1
#define TRACE_MEGASAS_INITQ_MAP_FAILED_ENABLED 1
#define TRACE_MEGASAS_INITQ_MAPPED_ENABLED 1
#define TRACE_MEGASAS_INITQ_MISMATCH_ENABLED 1
#define TRACE_MEGASAS_QF_MAPPED_ENABLED 1
#define TRACE_MEGASAS_QF_NEW_ENABLED 1
#define TRACE_MEGASAS_QF_BUSY_ENABLED 1
#define TRACE_MEGASAS_QF_ENQUEUE_ENABLED 1
#define TRACE_MEGASAS_QF_UPDATE_ENABLED 1
#define TRACE_MEGASAS_QF_MAP_FAILED_ENABLED 1
#define TRACE_MEGASAS_QF_COMPLETE_NOIRQ_ENABLED 1
#define TRACE_MEGASAS_QF_COMPLETE_ENABLED 1
#define TRACE_MEGASAS_FRAME_BUSY_ENABLED 1
#define TRACE_MEGASAS_UNHANDLED_FRAME_CMD_ENABLED 1
#define TRACE_MEGASAS_HANDLE_SCSI_ENABLED 1
#define TRACE_MEGASAS_SCSI_TARGET_NOT_PRESENT_ENABLED 1
#define TRACE_MEGASAS_SCSI_INVALID_CDB_LEN_ENABLED 1
#define TRACE_MEGASAS_IOV_READ_OVERFLOW_ENABLED 1
#define TRACE_MEGASAS_IOV_WRITE_OVERFLOW_ENABLED 1
#define TRACE_MEGASAS_IOV_READ_UNDERFLOW_ENABLED 1
#define TRACE_MEGASAS_IOV_WRITE_UNDERFLOW_ENABLED 1
#define TRACE_MEGASAS_SCSI_REQ_ALLOC_FAILED_ENABLED 1
#define TRACE_MEGASAS_SCSI_READ_START_ENABLED 1
#define TRACE_MEGASAS_SCSI_WRITE_START_ENABLED 1
#define TRACE_MEGASAS_SCSI_NODATA_ENABLED 1
#define TRACE_MEGASAS_SCSI_COMPLETE_ENABLED 1
#define TRACE_MEGASAS_COMMAND_COMPLETE_ENABLED 1
#define TRACE_MEGASAS_HANDLE_IO_ENABLED 1
#define TRACE_MEGASAS_IO_TARGET_NOT_PRESENT_ENABLED 1
#define TRACE_MEGASAS_IO_READ_START_ENABLED 1
#define TRACE_MEGASAS_IO_WRITE_START_ENABLED 1
#define TRACE_MEGASAS_IO_COMPLETE_ENABLED 1
#define TRACE_MEGASAS_IOVEC_SGL_OVERFLOW_ENABLED 1
#define TRACE_MEGASAS_IOVEC_SGL_UNDERFLOW_ENABLED 1
#define TRACE_MEGASAS_IOVEC_SGL_INVALID_ENABLED 1
#define TRACE_MEGASAS_IOVEC_OVERFLOW_ENABLED 1
#define TRACE_MEGASAS_IOVEC_UNDERFLOW_ENABLED 1
#define TRACE_MEGASAS_HANDLE_DCMD_ENABLED 1
#define TRACE_MEGASAS_FINISH_DCMD_ENABLED 1
#define TRACE_MEGASAS_DCMD_REQ_ALLOC_FAILED_ENABLED 1
#define TRACE_MEGASAS_DCMD_INTERNAL_SUBMIT_ENABLED 1
#define TRACE_MEGASAS_DCMD_INTERNAL_FINISH_ENABLED 1
#define TRACE_MEGASAS_DCMD_INTERNAL_INVALID_ENABLED 1
#define TRACE_MEGASAS_DCMD_UNHANDLED_ENABLED 1
#define TRACE_MEGASAS_DCMD_ZERO_SGE_ENABLED 1
#define TRACE_MEGASAS_DCMD_INVALID_SGE_ENABLED 1
#define TRACE_MEGASAS_DCMD_INVALID_XFER_LEN_ENABLED 1
#define TRACE_MEGASAS_DCMD_ENTER_ENABLED 1
#define TRACE_MEGASAS_DCMD_DUMMY_ENABLED 1
#define TRACE_MEGASAS_DCMD_SET_FW_TIME_ENABLED 1
#define TRACE_MEGASAS_DCMD_PD_GET_LIST_ENABLED 1
#define TRACE_MEGASAS_DCMD_LD_GET_LIST_ENABLED 1
#define TRACE_MEGASAS_DCMD_LD_GET_INFO_ENABLED 1
#define TRACE_MEGASAS_DCMD_LD_LIST_QUERY_ENABLED 1
#define TRACE_MEGASAS_DCMD_PD_GET_INFO_ENABLED 1
#define TRACE_MEGASAS_DCMD_PD_LIST_QUERY_ENABLED 1
#define TRACE_MEGASAS_DCMD_RESET_LD_ENABLED 1
#define TRACE_MEGASAS_DCMD_UNSUPPORTED_ENABLED 1
#define TRACE_MEGASAS_ABORT_FRAME_ENABLED 1
#define TRACE_MEGASAS_ABORT_NO_CMD_ENABLED 1
#define TRACE_MEGASAS_ABORT_INVALID_CONTEXT_ENABLED 1
#define TRACE_MEGASAS_RESET_ENABLED 1
#define TRACE_MEGASAS_INIT_ENABLED 1
#define TRACE_MEGASAS_MSIX_RAISE_ENABLED 1
#define TRACE_MEGASAS_MSI_RAISE_ENABLED 1
#define TRACE_MEGASAS_IRQ_LOWER_ENABLED 1
#define TRACE_MEGASAS_IRQ_RAISE_ENABLED 1
#define TRACE_MEGASAS_INTR_ENABLED_ENABLED 1
#define TRACE_MEGASAS_INTR_DISABLED_ENABLED 1
#define TRACE_MEGASAS_MSIX_ENABLED_ENABLED 1
#define TRACE_MEGASAS_MSI_ENABLED_ENABLED 1
#define TRACE_MEGASAS_MMIO_READL_ENABLED 1
#define TRACE_MEGASAS_MMIO_INVALID_READL_ENABLED 1
#define TRACE_MEGASAS_MMIO_WRITEL_ENABLED 1
#define TRACE_MEGASAS_MMIO_INVALID_WRITEL_ENABLED 1
#define TRACE_PVSCSI_RING_INIT_DATA_ENABLED 1
#define TRACE_PVSCSI_RING_INIT_MSG_ENABLED 1
#define TRACE_PVSCSI_RING_FLUSH_CMP_ENABLED 1
#define TRACE_PVSCSI_RING_FLUSH_MSG_ENABLED 1
#define TRACE_PVSCSI_UPDATE_IRQ_LEVEL_ENABLED 1
#define TRACE_PVSCSI_UPDATE_IRQ_MSI_ENABLED 1
#define TRACE_PVSCSI_CMP_RING_PUT_ENABLED 1
#define TRACE_PVSCSI_MSG_RING_PUT_ENABLED 1
#define TRACE_PVSCSI_COMPLETE_REQUEST_ENABLED 1
#define TRACE_PVSCSI_GET_SG_LIST_ENABLED 1
#define TRACE_PVSCSI_GET_NEXT_SG_ELEM_ENABLED 1
#define TRACE_PVSCSI_COMMAND_COMPLETE_NOT_FOUND_ENABLED 1
#define TRACE_PVSCSI_COMMAND_COMPLETE_DATA_RUN_ENABLED 1
#define TRACE_PVSCSI_COMMAND_COMPLETE_SENSE_LEN_ENABLED 1
#define TRACE_PVSCSI_CONVERT_SGLIST_ENABLED 1
#define TRACE_PVSCSI_PROCESS_REQ_DESCR_ENABLED 1
#define TRACE_PVSCSI_PROCESS_REQ_DESCR_UNKNOWN_DEVICE_ENABLED 1
#define TRACE_PVSCSI_PROCESS_REQ_DESCR_INVALID_DIR_ENABLED 1
#define TRACE_PVSCSI_PROCESS_IO_ENABLED 1
#define TRACE_PVSCSI_ON_CMD_NOIMPL_ENABLED 1
#define TRACE_PVSCSI_ON_CMD_RESET_DEV_ENABLED 1
#define TRACE_PVSCSI_ON_CMD_ARRIVED_ENABLED 1
#define TRACE_PVSCSI_ON_CMD_ABORT_ENABLED 1
#define TRACE_PVSCSI_ON_CMD_UNKNOWN_ENABLED 1
#define TRACE_PVSCSI_ON_CMD_UNKNOWN_DATA_ENABLED 1
#define TRACE_PVSCSI_IO_WRITE_ENABLED 1
#define TRACE_PVSCSI_IO_WRITE_UNKNOWN_ENABLED 1
#define TRACE_PVSCSI_IO_READ_ENABLED 1
#define TRACE_PVSCSI_IO_READ_UNKNOWN_ENABLED 1
#define TRACE_PVSCSI_INIT_MSI_FAIL_ENABLED 1
#define TRACE_PVSCSI_STATE_ENABLED 1
#define TRACE_PVSCSI_TX_RINGS_PPN_ENABLED 1
#define TRACE_PVSCSI_TX_RINGS_NUM_PAGES_ENABLED 1
#define TRACE_ESP_ERROR_FIFO_OVERRUN_ENABLED 1
#define TRACE_ESP_ERROR_UNHANDLED_COMMAND_ENABLED 1
#define TRACE_ESP_ERROR_INVALID_WRITE_ENABLED 1
#define TRACE_ESP_RAISE_IRQ_ENABLED 1
#define TRACE_ESP_LOWER_IRQ_ENABLED 1
#define TRACE_ESP_DMA_ENABLE_ENABLED 1
#define TRACE_ESP_DMA_DISABLE_ENABLED 1
#define TRACE_ESP_GET_CMD_ENABLED 1
#define TRACE_ESP_DO_BUSID_CMD_ENABLED 1
#define TRACE_ESP_HANDLE_SATN_STOP_ENABLED 1
#define TRACE_ESP_WRITE_RESPONSE_ENABLED 1
#define TRACE_ESP_DO_DMA_ENABLED 1
#define TRACE_ESP_COMMAND_COMPLETE_ENABLED 1
#define TRACE_ESP_COMMAND_COMPLETE_UNEXPECTED_ENABLED 1
#define TRACE_ESP_COMMAND_COMPLETE_FAIL_ENABLED 1
#define TRACE_ESP_TRANSFER_DATA_ENABLED 1
#define TRACE_ESP_HANDLE_TI_ENABLED 1
#define TRACE_ESP_HANDLE_TI_CMD_ENABLED 1
#define TRACE_ESP_MEM_READB_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_NOP_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_FLUSH_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_RESET_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_BUS_RESET_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_ICCS_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_MSGACC_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_PAD_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_SATN_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_RSTATN_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_SEL_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_SELATN_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_SELATNS_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_ENSEL_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_DISSEL_ENABLED 1
#define TRACE_ESP_PCI_ERROR_INVALID_DMA_DIRECTION_ENABLED 1
#define TRACE_ESP_PCI_ERROR_INVALID_READ_ENABLED 1
#define TRACE_ESP_PCI_ERROR_INVALID_WRITE_ENABLED 1
#define TRACE_ESP_PCI_ERROR_INVALID_WRITE_DMA_ENABLED 1
#define TRACE_ESP_PCI_DMA_READ_ENABLED 1
#define TRACE_ESP_PCI_DMA_WRITE_ENABLED 1
#define TRACE_ESP_PCI_DMA_IDLE_ENABLED 1
#define TRACE_ESP_PCI_DMA_BLAST_ENABLED 1
#define TRACE_ESP_PCI_DMA_ABORT_ENABLED 1
#define TRACE_ESP_PCI_DMA_START_ENABLED 1
#define TRACE_ESP_PCI_SBAC_READ_ENABLED 1
#define TRACE_ESP_PCI_SBAC_WRITE_ENABLED 1
#define TRACE_SPAPR_VSCSI_SEND_RSP_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_NO_DATA_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_DIRECT_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_RANGE_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_DMA_READ_ERROR_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_SEG_EXT_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_BOUNDARY_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_DONE_ENABLED 1
#define TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_ENABLED 1
#define TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_RW_ENABLED 1
#define TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_BUF_ENABLED 1
#define TRACE_SPAPR_VSCSI_SRP_TRANSFER_DATA_ENABLED 1
#define TRACE_SPAPR_VSCSI_TRANSFER_DATA_ENABLED 1
#define TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_ENABLED 1
#define TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA1_ENABLED 1
#define TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA2_ENABLED 1
#define TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_STATUS_ENABLED 1
#define TRACE_SPAPR_VSCSI_SAVE_REQUEST_ENABLED 1
#define TRACE_SPAPR_VSCSI_LOAD_REQUEST_ENABLED 1
#define TRACE_SPAPR_VSCSI_PROCESS_LOGIN_ENABLED 1
#define TRACE_SPAPR_VSCSI_QUEUE_CMD_NO_DRIVE_ENABLED 1
#define TRACE_SPAPR_VSCSI_QUEUE_CMD_ENABLED 1
#define TRACE_SPAPR_VSCSI_DO_CRQ_ENABLED 1
#include "qemu/log.h"


static inline void trace_scsi_req_alloc(int target, int lun, int tag)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_REQ_ALLOC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_req_alloc " "target %d lun %d tag %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, tag);
        }
    }
}

static inline void trace_scsi_req_cancel(int target, int lun, int tag)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_REQ_CANCEL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_req_cancel " "target %d lun %d tag %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, tag);
        }
    }
}

static inline void trace_scsi_req_data(int target, int lun, int tag, int len)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_REQ_DATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_req_data " "target %d lun %d tag %d len %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, tag, len);
        }
    }
}

static inline void trace_scsi_req_data_canceled(int target, int lun, int tag, int len)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_REQ_DATA_CANCELED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_req_data_canceled " "target %d lun %d tag %d len %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, tag, len);
        }
    }
}

static inline void trace_scsi_req_dequeue(int target, int lun, int tag)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_REQ_DEQUEUE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_req_dequeue " "target %d lun %d tag %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, tag);
        }
    }
}

static inline void trace_scsi_req_continue(int target, int lun, int tag)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_REQ_CONTINUE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_req_continue " "target %d lun %d tag %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, tag);
        }
    }
}

static inline void trace_scsi_req_continue_canceled(int target, int lun, int tag)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_REQ_CONTINUE_CANCELED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_req_continue_canceled " "target %d lun %d tag %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, tag);
        }
    }
}

static inline void trace_scsi_req_parsed(int target, int lun, int tag, int cmd, int mode, int xfer)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_REQ_PARSED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_req_parsed " "target %d lun %d tag %d command %d dir %d length %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, tag, cmd, mode, xfer);
        }
    }
}

static inline void trace_scsi_req_parsed_lba(int target, int lun, int tag, int cmd, uint64_t lba)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_REQ_PARSED_LBA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_req_parsed_lba " "target %d lun %d tag %d command %d lba %"PRIu64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, tag, cmd, lba);
        }
    }
}

static inline void trace_scsi_req_parse_bad(int target, int lun, int tag, int cmd)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_REQ_PARSE_BAD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_req_parse_bad " "target %d lun %d tag %d command %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, tag, cmd);
        }
    }
}

static inline void trace_scsi_req_build_sense(int target, int lun, int tag, int key, int asc, int ascq)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_REQ_BUILD_SENSE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_req_build_sense " "target %d lun %d tag %d key %#02x asc %#02x ascq %#02x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, tag, key, asc, ascq);
        }
    }
}

static inline void trace_scsi_device_set_ua(int target, int lun, int key, int asc, int ascq)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_DEVICE_SET_UA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_device_set_ua " "target %d lun %d key %#02x asc %#02x ascq %#02x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, key, asc, ascq);
        }
    }
}

static inline void trace_scsi_report_luns(int target, int lun, int tag)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_REPORT_LUNS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_report_luns " "target %d lun %d tag %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, tag);
        }
    }
}

static inline void trace_scsi_inquiry(int target, int lun, int tag, int cdb1, int cdb2)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_INQUIRY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_inquiry " "target %d lun %d tag %d page %#02x/%#02x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, tag, cdb1, cdb2);
        }
    }
}

static inline void trace_scsi_test_unit_ready(int target, int lun, int tag)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_TEST_UNIT_READY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_test_unit_ready " "target %d lun %d tag %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, tag);
        }
    }
}

static inline void trace_scsi_request_sense(int target, int lun, int tag)
{
    if (true) {
        if (trace_event_get_state(TRACE_SCSI_REQUEST_SENSE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:scsi_request_sense " "target %d lun %d tag %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , target, lun, tag);
        }
    }
}

static inline void trace_mptsas_command_complete(void * dev, uint32_t ctx, uint32_t status, uint32_t resid)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_COMMAND_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_command_complete " "dev %p context 0x%08x status %x resid %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, ctx, status, resid);
        }
    }
}

static inline void trace_mptsas_diag_read(void * dev, uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_DIAG_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_diag_read " "dev %p addr 0x%08x value 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, addr, val);
        }
    }
}

static inline void trace_mptsas_diag_write(void * dev, uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_DIAG_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_diag_write " "dev %p addr 0x%08x value 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, addr, val);
        }
    }
}

static inline void trace_mptsas_irq_intx(void * dev, int level)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_IRQ_INTX)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_irq_intx " "dev %p level %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, level);
        }
    }
}

static inline void trace_mptsas_irq_msi(void * dev)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_IRQ_MSI)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_irq_msi " "dev %p " "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev);
        }
    }
}

static inline void trace_mptsas_mmio_read(void * dev, uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_MMIO_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_mmio_read " "dev %p addr 0x%08x value 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, addr, val);
        }
    }
}

static inline void trace_mptsas_mmio_unhandled_read(void * dev, uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_MMIO_UNHANDLED_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_mmio_unhandled_read " "dev %p addr 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, addr);
        }
    }
}

static inline void trace_mptsas_mmio_unhandled_write(void * dev, uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_MMIO_UNHANDLED_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_mmio_unhandled_write " "dev %p addr 0x%08x value 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, addr, val);
        }
    }
}

static inline void trace_mptsas_mmio_write(void * dev, uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_MMIO_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_mmio_write " "dev %p addr 0x%08x value 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, addr, val);
        }
    }
}

static inline void trace_mptsas_process_message(void * dev, int msg, uint32_t ctx)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_PROCESS_MESSAGE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_process_message " "dev %p cmd %d context 0x%08x\n" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, msg, ctx);
        }
    }
}

static inline void trace_mptsas_process_scsi_io_request(void * dev, int bus, int target, int lun, uint64_t len)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_PROCESS_SCSI_IO_REQUEST)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_process_scsi_io_request " "dev %p dev %d:%d:%d length %"PRIu64"" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, bus, target, lun, len);
        }
    }
}

static inline void trace_mptsas_reset(void * dev)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_reset " "dev %p " "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev);
        }
    }
}

static inline void trace_mptsas_scsi_overflow(void * dev, uint32_t ctx, uint64_t req, uint64_t found)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_SCSI_OVERFLOW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_scsi_overflow " "dev %p context 0x%08x: %"PRIu64"/%"PRIu64"" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, ctx, req, found);
        }
    }
}

static inline void trace_mptsas_sgl_overflow(void * dev, uint32_t ctx, uint64_t req, uint64_t found)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_SGL_OVERFLOW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_sgl_overflow " "dev %p context 0x%08x: %"PRIu64"/%"PRIu64"" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, ctx, req, found);
        }
    }
}

static inline void trace_mptsas_unhandled_cmd(void * dev, uint32_t ctx, uint8_t msg_cmd)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_UNHANDLED_CMD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_unhandled_cmd " "dev %p context 0x%08x: Unhandled cmd %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, ctx, msg_cmd);
        }
    }
}

static inline void trace_mptsas_unhandled_doorbell_cmd(void * dev, int cmd)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_UNHANDLED_DOORBELL_CMD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_unhandled_doorbell_cmd " "dev %p value 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, cmd);
        }
    }
}

static inline void trace_mptsas_config_sas_device(void * dev, int address, int port, int phy_handle, int dev_handle, int page)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_CONFIG_SAS_DEVICE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_config_sas_device " "dev %p address %d (port %d, handles: phy %d dev %d) page %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, address, port, phy_handle, dev_handle, page);
        }
    }
}

static inline void trace_mptsas_config_sas_phy(void * dev, int address, int port, int phy_handle, int dev_handle, int page)
{
    if (true) {
        if (trace_event_get_state(TRACE_MPTSAS_CONFIG_SAS_PHY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mptsas_config_sas_phy " "dev %p address %d (port %d, handles: phy %d dev %d) page %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, address, port, phy_handle, dev_handle, page);
        }
    }
}

static inline void trace_megasas_init_firmware(uint64_t pa)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_INIT_FIRMWARE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_init_firmware " "pa %" PRIx64 " " "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , pa);
        }
    }
}

static inline void trace_megasas_init_queue(uint64_t queue_pa, int queue_len, uint64_t head, uint64_t tail, uint32_t flags)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_INIT_QUEUE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_init_queue " "queue at %" PRIx64 " len %d head %" PRIx64 " tail %" PRIx64 " flags %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , queue_pa, queue_len, head, tail, flags);
        }
    }
}

static inline void trace_megasas_initq_map_failed(int frame)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_INITQ_MAP_FAILED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_initq_map_failed " "scmd %d: failed to map queue" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , frame);
        }
    }
}

static inline void trace_megasas_initq_mapped(uint64_t pa)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_INITQ_MAPPED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_initq_mapped " "queue already mapped at %" PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , pa);
        }
    }
}

static inline void trace_megasas_initq_mismatch(int queue_len, int fw_cmds)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_INITQ_MISMATCH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_initq_mismatch " "queue size %d max fw cmds %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , queue_len, fw_cmds);
        }
    }
}

static inline void trace_megasas_qf_mapped(unsigned int index)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_QF_MAPPED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_qf_mapped " "skip mapped frame %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_megasas_qf_new(unsigned int index, uint64_t frame)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_QF_NEW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_qf_new " "frame %x addr %" PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, frame);
        }
    }
}

static inline void trace_megasas_qf_busy(unsigned long pa)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_QF_BUSY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_qf_busy " "all frames busy for frame %lx" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , pa);
        }
    }
}

static inline void trace_megasas_qf_enqueue(unsigned int index, unsigned int count, uint64_t context, unsigned int head, unsigned int tail, int busy)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_QF_ENQUEUE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_qf_enqueue " "frame %x count %d context %" PRIx64 " head %x tail %x busy %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, count, context, head, tail, busy);
        }
    }
}

static inline void trace_megasas_qf_update(unsigned int head, unsigned int tail, unsigned int busy)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_QF_UPDATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_qf_update " "head %x tail %x busy %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , head, tail, busy);
        }
    }
}

static inline void trace_megasas_qf_map_failed(int cmd, unsigned long frame)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_QF_MAP_FAILED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_qf_map_failed " "scmd %d: frame %lu" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, frame);
        }
    }
}

static inline void trace_megasas_qf_complete_noirq(uint64_t context)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_QF_COMPLETE_NOIRQ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_qf_complete_noirq " "context %" PRIx64 " " "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , context);
        }
    }
}

static inline void trace_megasas_qf_complete(uint64_t context, unsigned int head, unsigned int tail, int busy)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_QF_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_qf_complete " "context %" PRIx64 " head %x tail %x busy %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , context, head, tail, busy);
        }
    }
}

static inline void trace_megasas_frame_busy(uint64_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_FRAME_BUSY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_frame_busy " "frame %" PRIx64 " busy" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_megasas_unhandled_frame_cmd(int cmd, uint8_t frame_cmd)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_UNHANDLED_FRAME_CMD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_unhandled_frame_cmd " "scmd %d: MFI cmd %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, frame_cmd);
        }
    }
}

static inline void trace_megasas_handle_scsi(const char * frame, int bus, int dev, int lun, void * sdev, unsigned long size)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_HANDLE_SCSI)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_handle_scsi " "%s dev %x/%x/%x sdev %p xfer %lu" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , frame, bus, dev, lun, sdev, size);
        }
    }
}

static inline void trace_megasas_scsi_target_not_present(const char * frame, int bus, int dev, int lun)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_SCSI_TARGET_NOT_PRESENT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_scsi_target_not_present " "%s dev %x/%x/%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , frame, bus, dev, lun);
        }
    }
}

static inline void trace_megasas_scsi_invalid_cdb_len(const char * frame, int bus, int dev, int lun, int len)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_SCSI_INVALID_CDB_LEN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_scsi_invalid_cdb_len " "%s dev %x/%x/%x invalid cdb len %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , frame, bus, dev, lun, len);
        }
    }
}

static inline void trace_megasas_iov_read_overflow(int cmd, int bytes, int len)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_IOV_READ_OVERFLOW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_iov_read_overflow " "scmd %d: %d/%d bytes" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, bytes, len);
        }
    }
}

static inline void trace_megasas_iov_write_overflow(int cmd, int bytes, int len)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_IOV_WRITE_OVERFLOW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_iov_write_overflow " "scmd %d: %d/%d bytes" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, bytes, len);
        }
    }
}

static inline void trace_megasas_iov_read_underflow(int cmd, int bytes, int len)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_IOV_READ_UNDERFLOW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_iov_read_underflow " "scmd %d: %d/%d bytes" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, bytes, len);
        }
    }
}

static inline void trace_megasas_iov_write_underflow(int cmd, int bytes, int len)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_IOV_WRITE_UNDERFLOW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_iov_write_underflow " "scmd %d: %d/%d bytes" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, bytes, len);
        }
    }
}

static inline void trace_megasas_scsi_req_alloc_failed(const char * frame, int dev, int lun)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_SCSI_REQ_ALLOC_FAILED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_scsi_req_alloc_failed " "%s dev %x/%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , frame, dev, lun);
        }
    }
}

static inline void trace_megasas_scsi_read_start(int cmd, int len)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_SCSI_READ_START)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_scsi_read_start " "scmd %d: transfer %d bytes of data" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, len);
        }
    }
}

static inline void trace_megasas_scsi_write_start(int cmd, int len)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_SCSI_WRITE_START)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_scsi_write_start " "scmd %d: transfer %d bytes of data" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, len);
        }
    }
}

static inline void trace_megasas_scsi_nodata(int cmd)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_SCSI_NODATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_scsi_nodata " "scmd %d: no data to be transferred" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd);
        }
    }
}

static inline void trace_megasas_scsi_complete(int cmd, uint32_t status, int len, int xfer)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_SCSI_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_scsi_complete " "scmd %d: status %x, len %u/%u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, status, len, xfer);
        }
    }
}

static inline void trace_megasas_command_complete(int cmd, uint32_t status, uint32_t resid)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_COMMAND_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_command_complete " "scmd %d: status %x, residual %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, status, resid);
        }
    }
}

static inline void trace_megasas_handle_io(int cmd, const char * frame, int dev, int lun, unsigned long lba, unsigned long count)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_HANDLE_IO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_handle_io " "scmd %d: %s dev %x/%x lba %lx count %lu" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, frame, dev, lun, lba, count);
        }
    }
}

static inline void trace_megasas_io_target_not_present(int cmd, const char * frame, int dev, int lun)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_IO_TARGET_NOT_PRESENT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_io_target_not_present " "scmd %d: %s dev 1/%x/%x LUN not present" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, frame, dev, lun);
        }
    }
}

static inline void trace_megasas_io_read_start(int cmd, unsigned long lba, unsigned long count, unsigned long len)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_IO_READ_START)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_io_read_start " "scmd %d: start LBA %lx %lu blocks (%lu bytes)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, lba, count, len);
        }
    }
}

static inline void trace_megasas_io_write_start(int cmd, unsigned long lba, unsigned long count, unsigned long len)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_IO_WRITE_START)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_io_write_start " "scmd %d: start LBA %lx %lu blocks (%lu bytes)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, lba, count, len);
        }
    }
}

static inline void trace_megasas_io_complete(int cmd, uint32_t len)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_IO_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_io_complete " "scmd %d: %d bytes" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, len);
        }
    }
}

static inline void trace_megasas_iovec_sgl_overflow(int cmd, int index, int limit)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_IOVEC_SGL_OVERFLOW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_iovec_sgl_overflow " "scmd %d: iovec count %d limit %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, index, limit);
        }
    }
}

static inline void trace_megasas_iovec_sgl_underflow(int cmd, int index)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_IOVEC_SGL_UNDERFLOW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_iovec_sgl_underflow " "scmd %d: iovec count %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, index);
        }
    }
}

static inline void trace_megasas_iovec_sgl_invalid(int cmd, int index, uint64_t pa, uint32_t len)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_IOVEC_SGL_INVALID)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_iovec_sgl_invalid " "scmd %d: element %d pa %" PRIx64 " len %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, index, pa, len);
        }
    }
}

static inline void trace_megasas_iovec_overflow(int cmd, int len, int limit)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_IOVEC_OVERFLOW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_iovec_overflow " "scmd %d: len %d limit %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, len, limit);
        }
    }
}

static inline void trace_megasas_iovec_underflow(int cmd, int len, int limit)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_IOVEC_UNDERFLOW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_iovec_underflow " "scmd %d: len %d limit %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, len, limit);
        }
    }
}

static inline void trace_megasas_handle_dcmd(int cmd, int opcode)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_HANDLE_DCMD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_handle_dcmd " "scmd %d: MFI DCMD opcode %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, opcode);
        }
    }
}

static inline void trace_megasas_finish_dcmd(int cmd, int size)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_FINISH_DCMD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_finish_dcmd " "scmd %d: MFI DCMD wrote %d bytes" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, size);
        }
    }
}

static inline void trace_megasas_dcmd_req_alloc_failed(int cmd, const char * desc)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_REQ_ALLOC_FAILED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_req_alloc_failed " "scmd %d: %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, desc);
        }
    }
}

static inline void trace_megasas_dcmd_internal_submit(int cmd, const char * desc, int dev)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_INTERNAL_SUBMIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_internal_submit " "scmd %d: %s to dev %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, desc, dev);
        }
    }
}

static inline void trace_megasas_dcmd_internal_finish(int cmd, int opcode, int lun)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_INTERNAL_FINISH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_internal_finish " "scmd %d: cmd %x lun %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, opcode, lun);
        }
    }
}

static inline void trace_megasas_dcmd_internal_invalid(int cmd, int opcode)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_INTERNAL_INVALID)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_internal_invalid " "scmd %d: DCMD %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, opcode);
        }
    }
}

static inline void trace_megasas_dcmd_unhandled(int cmd, int opcode, int len)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_UNHANDLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_unhandled " "scmd %d: opcode %x, len %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, opcode, len);
        }
    }
}

static inline void trace_megasas_dcmd_zero_sge(int cmd)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_ZERO_SGE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_zero_sge " "scmd %d: zero DCMD sge count" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd);
        }
    }
}

static inline void trace_megasas_dcmd_invalid_sge(int cmd, int count)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_INVALID_SGE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_invalid_sge " "scmd %d: DCMD sge count %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, count);
        }
    }
}

static inline void trace_megasas_dcmd_invalid_xfer_len(int cmd, unsigned long size, unsigned long max)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_INVALID_XFER_LEN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_invalid_xfer_len " "scmd %d: xfer len %ld, max %ld" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, size, max);
        }
    }
}

static inline void trace_megasas_dcmd_enter(int cmd, const char * dcmd, int len)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_ENTER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_enter " "scmd %d: DCMD %s len %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, dcmd, len);
        }
    }
}

static inline void trace_megasas_dcmd_dummy(int cmd, unsigned long size)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_DUMMY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_dummy " "scmd %d: xfer len %ld" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, size);
        }
    }
}

static inline void trace_megasas_dcmd_set_fw_time(int cmd, unsigned long time)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_SET_FW_TIME)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_set_fw_time " "scmd %d: Set FW time %lx" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, time);
        }
    }
}

static inline void trace_megasas_dcmd_pd_get_list(int cmd, int num, int max, int offset)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_PD_GET_LIST)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_pd_get_list " "scmd %d: DCMD PD get list: %d / %d PDs, size %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, num, max, offset);
        }
    }
}

static inline void trace_megasas_dcmd_ld_get_list(int cmd, int num, int max)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_LD_GET_LIST)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_ld_get_list " "scmd %d: DCMD LD get list: found %d / %d LDs" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, num, max);
        }
    }
}

static inline void trace_megasas_dcmd_ld_get_info(int cmd, int ld_id)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_LD_GET_INFO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_ld_get_info " "scmd %d: dev %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, ld_id);
        }
    }
}

static inline void trace_megasas_dcmd_ld_list_query(int cmd, int flags)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_LD_LIST_QUERY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_ld_list_query " "scmd %d: query flags %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, flags);
        }
    }
}

static inline void trace_megasas_dcmd_pd_get_info(int cmd, int pd_id)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_PD_GET_INFO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_pd_get_info " "scmd %d: dev %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, pd_id);
        }
    }
}

static inline void trace_megasas_dcmd_pd_list_query(int cmd, int flags)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_PD_LIST_QUERY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_pd_list_query " "scmd %d: query flags %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, flags);
        }
    }
}

static inline void trace_megasas_dcmd_reset_ld(int cmd, int target_id)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_RESET_LD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_reset_ld " "scmd %d: dev %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, target_id);
        }
    }
}

static inline void trace_megasas_dcmd_unsupported(int cmd, unsigned long size)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_DCMD_UNSUPPORTED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_dcmd_unsupported " "scmd %d: set properties len %ld" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, size);
        }
    }
}

static inline void trace_megasas_abort_frame(int cmd, int abort_cmd)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_ABORT_FRAME)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_abort_frame " "scmd %d: frame %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, abort_cmd);
        }
    }
}

static inline void trace_megasas_abort_no_cmd(int cmd, uint64_t context)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_ABORT_NO_CMD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_abort_no_cmd " "scmd %d: no active command for frame context %" PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, context);
        }
    }
}

static inline void trace_megasas_abort_invalid_context(int cmd, uint64_t context, int abort_cmd)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_ABORT_INVALID_CONTEXT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_abort_invalid_context " "scmd %d: invalid frame context %" PRIx64 " for abort frame %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, context, abort_cmd);
        }
    }
}

static inline void trace_megasas_reset(int fw_state)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_reset " "firmware state %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , fw_state);
        }
    }
}

static inline void trace_megasas_init(int sges, int cmds, const char * mode)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_INIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_init " "Using %d sges, %d cmds, %s mode" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , sges, cmds, mode);
        }
    }
}

static inline void trace_megasas_msix_raise(int vector)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_MSIX_RAISE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_msix_raise " "vector %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , vector);
        }
    }
}

static inline void trace_megasas_msi_raise(int vector)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_MSI_RAISE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_msi_raise " "vector %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , vector);
        }
    }
}

static inline void trace_megasas_irq_lower(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_IRQ_LOWER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_irq_lower " "INTx" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_megasas_irq_raise(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_IRQ_RAISE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_irq_raise " "INTx" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_megasas_intr_enabled(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_INTR_ENABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_intr_enabled " "Interrupts enabled" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_megasas_intr_disabled(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_INTR_DISABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_intr_disabled " "Interrupts disabled" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_megasas_msix_enabled(int vector)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_MSIX_ENABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_msix_enabled " "vector %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , vector);
        }
    }
}

static inline void trace_megasas_msi_enabled(int vector)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_MSI_ENABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_msi_enabled " "vector %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , vector);
        }
    }
}

static inline void trace_megasas_mmio_readl(const char * reg, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_MMIO_READL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_mmio_readl " "reg %s: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , reg, val);
        }
    }
}

static inline void trace_megasas_mmio_invalid_readl(unsigned long addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_MMIO_INVALID_READL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_mmio_invalid_readl " "addr 0x%lx" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_megasas_mmio_writel(const char * reg, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_MMIO_WRITEL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_mmio_writel " "reg %s: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , reg, val);
        }
    }
}

static inline void trace_megasas_mmio_invalid_writel(uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_MEGASAS_MMIO_INVALID_WRITEL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:megasas_mmio_invalid_writel " "addr 0x%x: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_pvscsi_ring_init_data(uint32_t txr_len_log2, uint32_t rxr_len_log2)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_RING_INIT_DATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_ring_init_data " "TX/RX rings logarithms set to %d/%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , txr_len_log2, rxr_len_log2);
        }
    }
}

static inline void trace_pvscsi_ring_init_msg(uint32_t len_log2)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_RING_INIT_MSG)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_ring_init_msg " "MSG ring logarithm set to %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , len_log2);
        }
    }
}

static inline void trace_pvscsi_ring_flush_cmp(uint64_t filled_cmp_ptr)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_RING_FLUSH_CMP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_ring_flush_cmp " "new production counter of completion ring is 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , filled_cmp_ptr);
        }
    }
}

static inline void trace_pvscsi_ring_flush_msg(uint64_t filled_cmp_ptr)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_RING_FLUSH_MSG)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_ring_flush_msg " "new production counter of message ring is 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , filled_cmp_ptr);
        }
    }
}

static inline void trace_pvscsi_update_irq_level(bool raise, uint64_t mask, uint64_t status)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_UPDATE_IRQ_LEVEL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_update_irq_level " "interrupt level set to %d (MASK: 0x%"PRIx64", STATUS: 0x%"PRIx64")" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , raise, mask, status);
        }
    }
}

static inline void trace_pvscsi_update_irq_msi(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_UPDATE_IRQ_MSI)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_update_irq_msi " "sending MSI notification" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_pvscsi_cmp_ring_put(unsigned long addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_CMP_RING_PUT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_cmp_ring_put " "got completion descriptor 0x%lx" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_pvscsi_msg_ring_put(unsigned long addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_MSG_RING_PUT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_msg_ring_put " "got message descriptor 0x%lx" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_pvscsi_complete_request(uint64_t context, uint64_t len, uint8_t sense_key)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_COMPLETE_REQUEST)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_complete_request " "completion: ctx: 0x%"PRIx64", len: 0x%"PRIx64", sense key: %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , context, len, sense_key);
        }
    }
}

static inline void trace_pvscsi_get_sg_list(int nsg, size_t size)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_GET_SG_LIST)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_get_sg_list " "get SG list: depth: %u, size: %zu" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , nsg, size);
        }
    }
}

static inline void trace_pvscsi_get_next_sg_elem(uint32_t flags)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_GET_NEXT_SG_ELEM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_get_next_sg_elem " "unknown flags in SG element (val: 0x%x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , flags);
        }
    }
}

static inline void trace_pvscsi_command_complete_not_found(uint32_t tag)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_COMMAND_COMPLETE_NOT_FOUND)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_command_complete_not_found " "can't find request for tag 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , tag);
        }
    }
}

static inline void trace_pvscsi_command_complete_data_run(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_COMMAND_COMPLETE_DATA_RUN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_command_complete_data_run " "not all data required for command transferred" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_pvscsi_command_complete_sense_len(int len)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_COMMAND_COMPLETE_SENSE_LEN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_command_complete_sense_len " "sense information length is %d bytes" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , len);
        }
    }
}

static inline void trace_pvscsi_convert_sglist(uint64_t context, unsigned long addr, uint32_t resid)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_CONVERT_SGLIST)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_convert_sglist " "element: ctx: 0x%"PRIx64" addr: 0x%lx, len: %ul" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , context, addr, resid);
        }
    }
}

static inline void trace_pvscsi_process_req_descr(uint8_t cmd, uint64_t ctx)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_PROCESS_REQ_DESCR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_process_req_descr " "SCSI cmd 0x%x, ctx: 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, ctx);
        }
    }
}

static inline void trace_pvscsi_process_req_descr_unknown_device(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_PROCESS_REQ_DESCR_UNKNOWN_DEVICE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_process_req_descr_unknown_device " "command directed to unknown device rejected" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_pvscsi_process_req_descr_invalid_dir(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_PROCESS_REQ_DESCR_INVALID_DIR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_process_req_descr_invalid_dir " "command with invalid transfer direction rejected" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_pvscsi_process_io(unsigned long addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_PROCESS_IO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_process_io " "got descriptor 0x%lx" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_pvscsi_on_cmd_noimpl(const char* cmd)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_ON_CMD_NOIMPL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_on_cmd_noimpl " "unimplemented command %s ignored" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd);
        }
    }
}

static inline void trace_pvscsi_on_cmd_reset_dev(uint32_t tgt, int lun, void* dev)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_ON_CMD_RESET_DEV)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_on_cmd_reset_dev " "PVSCSI_CMD_RESET_DEVICE[target %u lun %d (dev 0x%p)]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , tgt, lun, dev);
        }
    }
}

static inline void trace_pvscsi_on_cmd_arrived(const char* cmd)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_ON_CMD_ARRIVED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_on_cmd_arrived " "command %s arrived" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd);
        }
    }
}

static inline void trace_pvscsi_on_cmd_abort(uint64_t ctx, uint32_t tgt)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_ON_CMD_ABORT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_on_cmd_abort " "command PVSCSI_CMD_ABORT_CMD for ctx 0x%"PRIx64", target %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ctx, tgt);
        }
    }
}

static inline void trace_pvscsi_on_cmd_unknown(uint64_t cmd_id)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_ON_CMD_UNKNOWN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_on_cmd_unknown " "unknown command %"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd_id);
        }
    }
}

static inline void trace_pvscsi_on_cmd_unknown_data(uint32_t data)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_ON_CMD_UNKNOWN_DATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_on_cmd_unknown_data " "data for unknown command 0x:%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , data);
        }
    }
}

static inline void trace_pvscsi_io_write(const char* cmd, uint64_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_IO_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_io_write " "%s write: %"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, val);
        }
    }
}

static inline void trace_pvscsi_io_write_unknown(unsigned long addr, unsigned sz, uint64_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_IO_WRITE_UNKNOWN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_io_write_unknown " "unknown write address: 0x%lx size: %u bytes value: 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, sz, val);
        }
    }
}

static inline void trace_pvscsi_io_read(const char* cmd, uint64_t status)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_IO_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_io_read " "%s read: 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, status);
        }
    }
}

static inline void trace_pvscsi_io_read_unknown(unsigned long addr, unsigned sz)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_IO_READ_UNKNOWN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_io_read_unknown " "unknown read address: 0x%lx size: %u bytes" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, sz);
        }
    }
}

static inline void trace_pvscsi_init_msi_fail(int res)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_INIT_MSI_FAIL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_init_msi_fail " "failed to initialize MSI, error %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , res);
        }
    }
}

static inline void trace_pvscsi_state(const char* state)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_STATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_state " "starting %s ..." "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , state);
        }
    }
}

static inline void trace_pvscsi_tx_rings_ppn(const char* label, uint64_t ppn)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_TX_RINGS_PPN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_tx_rings_ppn " "%s page: %"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , label, ppn);
        }
    }
}

static inline void trace_pvscsi_tx_rings_num_pages(const char* label, uint32_t num)
{
    if (true) {
        if (trace_event_get_state(TRACE_PVSCSI_TX_RINGS_NUM_PAGES)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pvscsi_tx_rings_num_pages " "Number of %s pages: %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , label, num);
        }
    }
}

static inline void trace_esp_error_fifo_overrun(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_ERROR_FIFO_OVERRUN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_error_fifo_overrun " "FIFO overrun" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_esp_error_unhandled_command(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_ERROR_UNHANDLED_COMMAND)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_error_unhandled_command " "unhandled command (%2.2x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_error_invalid_write(uint32_t val, uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_ERROR_INVALID_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_error_invalid_write " "invalid write of 0x%02x at [0x%x]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val, addr);
        }
    }
}

static inline void trace_esp_raise_irq(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_RAISE_IRQ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_raise_irq " "Raise IRQ" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_esp_lower_irq(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_LOWER_IRQ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_lower_irq " "Lower IRQ" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_esp_dma_enable(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_DMA_ENABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_dma_enable " "Raise enable" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_esp_dma_disable(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_DMA_DISABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_dma_disable " "Lower enable" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_esp_get_cmd(uint32_t dmalen, int target)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_GET_CMD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_get_cmd " "len %d target %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dmalen, target);
        }
    }
}

static inline void trace_esp_do_busid_cmd(uint8_t busid)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_DO_BUSID_CMD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_do_busid_cmd " "busid 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , busid);
        }
    }
}

static inline void trace_esp_handle_satn_stop(uint32_t cmdlen)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_HANDLE_SATN_STOP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_handle_satn_stop " "cmdlen %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmdlen);
        }
    }
}

static inline void trace_esp_write_response(uint32_t status)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_WRITE_RESPONSE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_write_response " "Transfer status (status=%d)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , status);
        }
    }
}

static inline void trace_esp_do_dma(uint32_t cmdlen, uint32_t len)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_DO_DMA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_do_dma " "command len %d + %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmdlen, len);
        }
    }
}

static inline void trace_esp_command_complete(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_COMMAND_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_command_complete " "SCSI Command complete" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_esp_command_complete_unexpected(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_COMMAND_COMPLETE_UNEXPECTED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_command_complete_unexpected " "SCSI command completed unexpectedly" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_esp_command_complete_fail(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_COMMAND_COMPLETE_FAIL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_command_complete_fail " "Command failed" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_esp_transfer_data(uint32_t dma_left, int32_t ti_size)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_TRANSFER_DATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_transfer_data " "transfer %d/%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dma_left, ti_size);
        }
    }
}

static inline void trace_esp_handle_ti(uint32_t minlen)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_HANDLE_TI)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_handle_ti " "Transfer Information len %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , minlen);
        }
    }
}

static inline void trace_esp_handle_ti_cmd(uint32_t cmdlen)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_HANDLE_TI_CMD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_handle_ti_cmd " "command len %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmdlen);
        }
    }
}

static inline void trace_esp_mem_readb(uint32_t saddr, uint8_t reg)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_READB)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_readb " "reg[%d]: 0x%2.2x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , saddr, reg);
        }
    }
}

static inline void trace_esp_mem_writeb(uint32_t saddr, uint8_t reg, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_WRITEB)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_writeb " "reg[%d]: 0x%2.2x -> 0x%2.2x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , saddr, reg, val);
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_nop(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_NOP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_writeb_cmd_nop " "NOP (%2.2x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_flush(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_FLUSH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_writeb_cmd_flush " "Flush FIFO (%2.2x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_reset(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_writeb_cmd_reset " "Chip reset (%2.2x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_bus_reset(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_BUS_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_writeb_cmd_bus_reset " "Bus reset (%2.2x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_iccs(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_ICCS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_writeb_cmd_iccs " "Initiator Command Complete Sequence (%2.2x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_msgacc(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_MSGACC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_writeb_cmd_msgacc " "Message Accepted (%2.2x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_pad(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_PAD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_writeb_cmd_pad " "Transfer padding (%2.2x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_satn(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_SATN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_writeb_cmd_satn " "Set ATN (%2.2x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_rstatn(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_RSTATN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_writeb_cmd_rstatn " "Reset ATN (%2.2x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_sel(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_SEL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_writeb_cmd_sel " "Select without ATN (%2.2x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_selatn(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_SELATN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_writeb_cmd_selatn " "Select with ATN (%2.2x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_selatns(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_SELATNS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_writeb_cmd_selatns " "Select with ATN & stop (%2.2x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_ensel(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_ENSEL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_writeb_cmd_ensel " "Enable selection (%2.2x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_dissel(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_DISSEL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_mem_writeb_cmd_dissel " "Disable selection (%2.2x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_pci_error_invalid_dma_direction(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_PCI_ERROR_INVALID_DMA_DIRECTION)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_pci_error_invalid_dma_direction " "invalid DMA transfer direction" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_esp_pci_error_invalid_read(uint32_t reg)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_PCI_ERROR_INVALID_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_pci_error_invalid_read " "read access outside bounds (reg 0x%x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , reg);
        }
    }
}

static inline void trace_esp_pci_error_invalid_write(uint32_t reg)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_PCI_ERROR_INVALID_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_pci_error_invalid_write " "write access outside bounds (reg 0x%x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , reg);
        }
    }
}

static inline void trace_esp_pci_error_invalid_write_dma(uint32_t val, uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_PCI_ERROR_INVALID_WRITE_DMA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_pci_error_invalid_write_dma " "invalid write of 0x%02x at [0x%x]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val, addr);
        }
    }
}

static inline void trace_esp_pci_dma_read(uint32_t saddr, uint32_t reg)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_PCI_DMA_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_pci_dma_read " "reg[%d]: 0x%8.8x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , saddr, reg);
        }
    }
}

static inline void trace_esp_pci_dma_write(uint32_t saddr, uint32_t reg, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_PCI_DMA_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_pci_dma_write " "reg[%d]: 0x%8.8x -> 0x%8.8x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , saddr, reg, val);
        }
    }
}

static inline void trace_esp_pci_dma_idle(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_PCI_DMA_IDLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_pci_dma_idle " "IDLE (%.8x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_pci_dma_blast(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_PCI_DMA_BLAST)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_pci_dma_blast " "BLAST (%.8x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_pci_dma_abort(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_PCI_DMA_ABORT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_pci_dma_abort " "ABORT (%.8x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_pci_dma_start(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_PCI_DMA_START)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_pci_dma_start " "START (%.8x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_esp_pci_sbac_read(uint32_t reg)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_PCI_SBAC_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_pci_sbac_read " "sbac: 0x%8.8x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , reg);
        }
    }
}

static inline void trace_esp_pci_sbac_write(uint32_t reg, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESP_PCI_SBAC_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:esp_pci_sbac_write " "sbac: 0x%8.8x -> 0x%8.8x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , reg, val);
        }
    }
}

static inline void trace_spapr_vscsi_send_rsp(uint8_t status, int32_t res_in, int32_t res_out)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_SEND_RSP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_send_rsp " "status: 0x%x, res_in: %"PRId32", res_out: %"PRId32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , status, res_in, res_out);
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_no_data(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_NO_DATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_fetch_desc_no_data " "no data descriptor" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_direct(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_DIRECT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_fetch_desc_direct " "direct segment" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_indirect(uint32_t qtag, unsigned desc, unsigned local_desc)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_fetch_desc_indirect " "indirect segment local tag=0x%"PRIx32" desc#%u/%u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , qtag, desc, local_desc);
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_out_of_range(unsigned desc, unsigned desc_offset)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_RANGE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_fetch_desc_out_of_range " "#%u is ouf of range (%u bytes)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , desc, desc_offset);
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_dma_read_error(int rc)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_DMA_READ_ERROR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_fetch_desc_dma_read_error " "spapr_vio_dma_read -> %d reading ext_desc" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , rc);
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_indirect_seg_ext(uint32_t qtag, unsigned n, unsigned desc, uint64_t va, uint32_t len)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_SEG_EXT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_fetch_desc_indirect_seg_ext " "indirect segment ext. tag=0x%"PRIx32" desc#%u/%u { va=0x%"PRIx64" len=0x%"PRIx32" }" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , qtag, n, desc, va, len);
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_out_of_desc(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_fetch_desc_out_of_desc " "Out of descriptors !" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_out_of_desc_boundary(unsigned offset, unsigned desc, uint32_t len)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_BOUNDARY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_fetch_desc_out_of_desc_boundary " "   offset=0x%x is out of a descriptor #%u boundary=%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , offset, desc, len);
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_done(unsigned desc_num, unsigned desc_offset, uint64_t va, uint32_t len)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_DONE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_fetch_desc_done " "   cur=%u offs=0x%x ret { va=0x%"PRIx64" len=0x%"PRIx32" }" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , desc_num, desc_offset, va, len);
        }
    }
}

static inline void trace_spapr_vscsi_srp_indirect_data(uint32_t len)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_srp_indirect_data " "indirect segment 0x%"PRIx32" bytes" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , len);
        }
    }
}

static inline void trace_spapr_vscsi_srp_indirect_data_rw(int writing, int rc)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_RW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_srp_indirect_data_rw " "spapr_vio_dma_r/w(%d) -> %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , writing, rc);
        }
    }
}

static inline void trace_spapr_vscsi_srp_indirect_data_buf(unsigned a, unsigned b, unsigned c, unsigned d)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_BUF)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_srp_indirect_data_buf " "     data: %02x %02x %02x %02x..." "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , a, b, c, d);
        }
    }
}

static inline void trace_spapr_vscsi_srp_transfer_data(uint32_t len)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_SRP_TRANSFER_DATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_srp_transfer_data " "no data desc transfer, skipping 0x%"PRIx32" bytes" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , len);
        }
    }
}

static inline void trace_spapr_vscsi_transfer_data(uint32_t tag, uint32_t len, void * req)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_TRANSFER_DATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_transfer_data " "SCSI xfer complete tag=0x%"PRIx32" len=0x%"PRIx32", req=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , tag, len, req);
        }
    }
}

static inline void trace_spapr_vscsi_command_complete(uint32_t tag, uint32_t status, void * req)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_COMMAND_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_command_complete " "SCSI cmd complete, tag=0x%"PRIx32" status=0x%"PRIx32", req=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , tag, status, req);
        }
    }
}

static inline void trace_spapr_vscsi_command_complete_sense_data1(uint32_t len, unsigned s0, unsigned s1, unsigned s2, unsigned s3, unsigned s4, unsigned s5, unsigned s6, unsigned s7)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA1)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_command_complete_sense_data1 " "Sense data, %d bytes: %02x %02x %02x %02x %02x %02x %02x %02x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , len, s0, s1, s2, s3, s4, s5, s6, s7);
        }
    }
}

static inline void trace_spapr_vscsi_command_complete_sense_data2(unsigned s8, unsigned s9, unsigned s10, unsigned s11, unsigned s12, unsigned s13, unsigned s14, unsigned s15)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA2)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_command_complete_sense_data2 " "                      %02x %02x %02x %02x %02x %02x %02x %02x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , s8, s9, s10, s11, s12, s13, s14, s15);
        }
    }
}

static inline void trace_spapr_vscsi_command_complete_status(uint32_t status)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_STATUS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_command_complete_status " "Command complete err=%"PRIu32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , status);
        }
    }
}

static inline void trace_spapr_vscsi_save_request(uint32_t qtag, unsigned desc, unsigned offset)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_SAVE_REQUEST)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_save_request " "saving tag=%"PRIu32", current desc#%u, offset=0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , qtag, desc, offset);
        }
    }
}

static inline void trace_spapr_vscsi_load_request(uint32_t qtag, unsigned desc, unsigned offset)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_LOAD_REQUEST)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_load_request " "restoring tag=%"PRIu32", current desc#%u, offset=0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , qtag, desc, offset);
        }
    }
}

static inline void trace_spapr_vscsi_process_login(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_PROCESS_LOGIN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_process_login " "Got login, sending response !" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_spapr_vscsi_queue_cmd_no_drive(uint64_t lun)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_QUEUE_CMD_NO_DRIVE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_queue_cmd_no_drive " "Command for lun %08" PRIx64 " with no drive" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , lun);
        }
    }
}

static inline void trace_spapr_vscsi_queue_cmd(uint32_t qtag, unsigned cdb, const char * cmd, int lun, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_QUEUE_CMD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_queue_cmd " "Queued command tag 0x%"PRIx32" CMD 0x%x=%s LUN %d ret: %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , qtag, cdb, cmd, lun, ret);
        }
    }
}

static inline void trace_spapr_vscsi_do_crq(unsigned c0, unsigned c1)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VSCSI_DO_CRQ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vscsi_do_crq " "crq: %02x %02x ..." "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , c0, c1);
        }
    }
}
#endif /* TRACE_HW_SCSI_GENERATED_TRACERS_H */
