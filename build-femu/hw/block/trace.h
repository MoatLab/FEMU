/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_BLOCK_GENERATED_TRACERS_H
#define TRACE_HW_BLOCK_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_VIRTIO_BLK_REQ_COMPLETE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_RW_COMPLETE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_WRITE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_READ_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_EVENT;
extern TraceEvent _TRACE_HD_GEOMETRY_LCHS_GUESS_EVENT;
extern TraceEvent _TRACE_HD_GEOMETRY_GUESS_EVENT;
extern TraceEvent _TRACE_NVME_MMIO_WRITE_EVENT;
extern TraceEvent _TRACE_NVME_MMIO_READ_EVENT;
extern TraceEvent _TRACE_NVME_CMB_WRITE_EVENT;
extern TraceEvent _TRACE_NVME_CMB_READ_EVENT;
extern uint16_t _TRACE_VIRTIO_BLK_REQ_COMPLETE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_RW_COMPLETE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_WRITE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_READ_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_DSTATE;
extern uint16_t _TRACE_HD_GEOMETRY_LCHS_GUESS_DSTATE;
extern uint16_t _TRACE_HD_GEOMETRY_GUESS_DSTATE;
extern uint16_t _TRACE_NVME_MMIO_WRITE_DSTATE;
extern uint16_t _TRACE_NVME_MMIO_READ_DSTATE;
extern uint16_t _TRACE_NVME_CMB_WRITE_DSTATE;
extern uint16_t _TRACE_NVME_CMB_READ_DSTATE;
#define TRACE_VIRTIO_BLK_REQ_COMPLETE_ENABLED 1
#define TRACE_VIRTIO_BLK_RW_COMPLETE_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_WRITE_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_READ_ENABLED 1
#define TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_ENABLED 1
#define TRACE_HD_GEOMETRY_LCHS_GUESS_ENABLED 1
#define TRACE_HD_GEOMETRY_GUESS_ENABLED 1
#define TRACE_NVME_MMIO_WRITE_ENABLED 1
#define TRACE_NVME_MMIO_READ_ENABLED 1
#define TRACE_NVME_CMB_WRITE_ENABLED 1
#define TRACE_NVME_CMB_READ_ENABLED 1
#include "qemu/log.h"


static inline void trace_virtio_blk_req_complete(void * req, int status)
{
    if (true) {
        if (trace_event_get_state(TRACE_VIRTIO_BLK_REQ_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:virtio_blk_req_complete " "req %p status %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , req, status);
        }
    }
}

static inline void trace_virtio_blk_rw_complete(void * req, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_VIRTIO_BLK_RW_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:virtio_blk_rw_complete " "req %p ret %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , req, ret);
        }
    }
}

static inline void trace_virtio_blk_handle_write(void * req, uint64_t sector, size_t nsectors)
{
    if (true) {
        if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:virtio_blk_handle_write " "req %p sector %"PRIu64" nsectors %zu" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , req, sector, nsectors);
        }
    }
}

static inline void trace_virtio_blk_handle_read(void * req, uint64_t sector, size_t nsectors)
{
    if (true) {
        if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:virtio_blk_handle_read " "req %p sector %"PRIu64" nsectors %zu" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , req, sector, nsectors);
        }
    }
}

static inline void trace_virtio_blk_submit_multireq(void * mrb, int start, int num_reqs, uint64_t offset, size_t size, bool is_write)
{
    if (true) {
        if (trace_event_get_state(TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:virtio_blk_submit_multireq " "mrb %p start %d num_reqs %d offset %"PRIu64" size %zu is_write %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , mrb, start, num_reqs, offset, size, is_write);
        }
    }
}

static inline void trace_hd_geometry_lchs_guess(void * blk, int cyls, int heads, int secs)
{
    if (true) {
        if (trace_event_get_state(TRACE_HD_GEOMETRY_LCHS_GUESS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:hd_geometry_lchs_guess " "blk %p LCHS %d %d %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , blk, cyls, heads, secs);
        }
    }
}

static inline void trace_hd_geometry_guess(void * blk, uint32_t cyls, uint32_t heads, uint32_t secs, int trans)
{
    if (true) {
        if (trace_event_get_state(TRACE_HD_GEOMETRY_GUESS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:hd_geometry_guess " "blk %p CHS %u %u %u trans %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , blk, cyls, heads, secs, trans);
        }
    }
}

static inline void trace_nvme_mmio_write(uint64_t addr, unsigned size, uint64_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_NVME_MMIO_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:nvme_mmio_write " "nvme mmio write addr %" PRIx64 " size %d <- %" PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, size, value);
        }
    }
}

static inline void trace_nvme_mmio_read(uint64_t addr, unsigned size, uint64_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_NVME_MMIO_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:nvme_mmio_read " "nvme mmio read addr %" PRIx64 " size %d -> %" PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, size, value);
        }
    }
}

static inline void trace_nvme_cmb_write(uint64_t addr, unsigned size, uint64_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_NVME_CMB_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:nvme_cmb_write " "nvme cmb write addr %" PRIx64 " size %d <- %" PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, size, value);
        }
    }
}

static inline void trace_nvme_cmb_read(uint64_t addr, unsigned size, uint64_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_NVME_CMB_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:nvme_cmb_read " "nvme cmb read addr %" PRIx64 " size %d -> %" PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, size, value);
        }
    }
}
#endif /* TRACE_HW_BLOCK_GENERATED_TRACERS_H */
