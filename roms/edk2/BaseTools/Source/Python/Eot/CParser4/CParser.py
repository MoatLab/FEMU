# Generated from C.g4 by ANTLR 4.7.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


## @file
# The file defines the parser for C source files.
#
# THIS FILE IS AUTO-GENENERATED. PLEASE DON NOT MODIFY THIS FILE.
# This file is generated by running:
# java org.antlr.Tool C.g
#
# Copyright (c) 2009 - 2010, Intel Corporation  All rights reserved.
#
# SPDX-License-Identifier: BSD-2-Clause-Patent
#
##

import Ecc.CodeFragment as CodeFragment
import Ecc.FileProfile as FileProfile

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3k")
        buf.write("\u0380\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\3\2\7\2\u0092\n\2\f\2\16\2\u0095")
        buf.write("\13\2\3\3\5\3\u0098\n\3\3\3\3\3\7\3\u009c\n\3\f\3\16\3")
        buf.write("\u009f\13\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3\u00a7\n\3\5\3")
        buf.write("\u00a9\n\3\3\4\5\4\u00ac\n\4\3\4\3\4\6\4\u00b0\n\4\r\4")
        buf.write("\16\4\u00b1\3\4\3\4\3\4\5\4\u00b7\n\4\3\4\3\4\3\5\3\5")
        buf.write("\3\5\6\5\u00be\n\5\r\5\16\5\u00bf\3\6\3\6\5\6\u00c4\n")
        buf.write("\6\3\6\3\6\3\6\3\6\3\6\3\6\5\6\u00cc\n\6\3\6\3\6\3\6\5")
        buf.write("\6\u00d1\n\6\3\7\3\7\3\7\7\7\u00d6\n\7\f\7\16\7\u00d9")
        buf.write("\13\7\3\b\3\b\3\b\5\b\u00de\n\b\3\t\3\t\3\n\3\n\3\n\3")
        buf.write("\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n")
        buf.write("\7\n\u00f3\n\n\f\n\16\n\u00f6\13\n\3\n\3\n\5\n\u00fa\n")
        buf.write("\n\3\13\3\13\3\f\3\f\5\f\u0100\n\f\3\f\3\f\3\f\3\f\3\f")
        buf.write("\3\f\3\f\5\f\u0109\n\f\3\r\3\r\3\16\6\16\u010e\n\16\r")
        buf.write("\16\16\16\u010f\3\17\3\17\3\17\3\17\3\20\3\20\6\20\u0118")
        buf.write("\n\20\r\20\16\20\u0119\3\21\3\21\3\21\7\21\u011f\n\21")
        buf.write("\f\21\16\21\u0122\13\21\3\22\3\22\3\22\5\22\u0127\n\22")
        buf.write("\3\22\3\22\5\22\u012b\n\22\3\23\3\23\3\23\3\23\5\23\u0131")
        buf.write("\n\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\5\23\u013a\n")
        buf.write("\23\3\23\3\23\3\23\3\23\5\23\u0140\n\23\3\24\3\24\3\24")
        buf.write("\7\24\u0145\n\24\f\24\16\24\u0148\13\24\3\25\3\25\3\25")
        buf.write("\5\25\u014d\n\25\3\26\3\26\3\27\5\27\u0152\n\27\3\27\5")
        buf.write("\27\u0155\n\27\3\27\5\27\u0158\n\27\3\27\5\27\u015b\n")
        buf.write("\27\3\27\3\27\5\27\u015f\n\27\3\30\3\30\7\30\u0163\n\30")
        buf.write("\f\30\16\30\u0166\13\30\3\30\3\30\5\30\u016a\n\30\3\30")
        buf.write("\3\30\3\30\6\30\u016f\n\30\r\30\16\30\u0170\5\30\u0173")
        buf.write("\n\30\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31")
        buf.write("\3\31\3\31\3\31\3\31\3\31\3\31\5\31\u0185\n\31\3\32\3")
        buf.write("\32\6\32\u0189\n\32\r\32\16\32\u018a\3\32\5\32\u018e\n")
        buf.write("\32\3\32\3\32\3\32\5\32\u0193\n\32\3\33\3\33\3\33\5\33")
        buf.write("\u0198\n\33\3\33\5\33\u019b\n\33\3\34\3\34\3\34\5\34\u01a0")
        buf.write("\n\34\3\34\7\34\u01a3\n\34\f\34\16\34\u01a6\13\34\3\35")
        buf.write("\3\35\3\35\7\35\u01ab\n\35\f\35\16\35\u01ae\13\35\3\35")
        buf.write("\5\35\u01b1\n\35\3\35\7\35\u01b4\n\35\f\35\16\35\u01b7")
        buf.write("\13\35\3\35\5\35\u01ba\n\35\3\36\3\36\3\36\7\36\u01bf")
        buf.write("\n\36\f\36\16\36\u01c2\13\36\3\37\3\37\5\37\u01c6\n\37")
        buf.write("\3\37\5\37\u01c9\n\37\3 \3 \5 \u01cd\n \3 \5 \u01d0\n")
        buf.write(" \3!\3!\3!\3!\3!\5!\u01d7\n!\3!\7!\u01da\n!\f!\16!\u01dd")
        buf.write("\13!\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\5")
        buf.write("\"\u01eb\n\"\3#\3#\3#\3#\5#\u01f1\n#\3#\3#\5#\u01f5\n")
        buf.write("#\3$\3$\3$\7$\u01fa\n$\f$\16$\u01fd\13$\3%\3%\5%\u0201")
        buf.write("\n%\3%\3%\3%\5%\u0206\n%\7%\u0208\n%\f%\16%\u020b\13%")
        buf.write("\3&\3&\3&\3&\3&\7&\u0212\n&\f&\16&\u0215\13&\3\'\3\'\3")
        buf.write("\'\3\'\3\'\3\'\3\'\7\'\u021e\n\'\f\'\16\'\u0221\13\'\3")
        buf.write("(\3(\3(\3(\3(\3(\5(\u0229\n(\3)\3)\3)\3)\3)\3)\3)\3)\3")
        buf.write(")\3)\3)\3)\3)\3)\3)\5)\u023a\n)\3*\3*\3*\3*\3*\3*\3*\3")
        buf.write("*\3*\3*\3*\3*\3*\3*\3*\3*\3*\3*\3*\3*\3*\3*\3*\3*\3*\3")
        buf.write("*\3*\3*\3*\7*\u0259\n*\f*\16*\u025c\13*\3+\3+\3+\7+\u0261")
        buf.write("\n+\f+\16+\u0264\13+\3,\3,\3-\3-\3-\3-\3-\3-\5-\u026e")
        buf.write("\n-\3.\3.\3.\3.\3.\7.\u0275\n.\f.\16.\u0278\13.\3.\6.")
        buf.write("\u027b\n.\r.\16.\u027c\6.\u027f\n.\r.\16.\u0280\3.\7.")
        buf.write("\u0284\n.\f.\16.\u0287\13.\3.\5.\u028a\n.\3/\3/\3/\7/")
        buf.write("\u028f\n/\f/\16/\u0292\13/\3\60\3\60\3\61\3\61\3\61\3")
        buf.write("\61\3\61\5\61\u029b\n\61\3\62\3\62\3\63\3\63\3\64\3\64")
        buf.write("\3\64\3\64\3\64\3\64\3\64\5\64\u02a8\n\64\3\65\3\65\3")
        buf.write("\65\7\65\u02ad\n\65\f\65\16\65\u02b0\13\65\3\66\3\66\3")
        buf.write("\66\7\66\u02b5\n\66\f\66\16\66\u02b8\13\66\3\67\3\67\3")
        buf.write("\67\7\67\u02bd\n\67\f\67\16\67\u02c0\13\67\38\38\38\7")
        buf.write("8\u02c5\n8\f8\168\u02c8\138\39\39\39\79\u02cd\n9\f9\16")
        buf.write("9\u02d0\139\3:\3:\3:\7:\u02d5\n:\f:\16:\u02d8\13:\3;\3")
        buf.write(";\3;\7;\u02dd\n;\f;\16;\u02e0\13;\3<\3<\3<\7<\u02e5\n")
        buf.write("<\f<\16<\u02e8\13<\3=\3=\3=\3=\3=\3=\3=\3=\3=\3=\3=\5")
        buf.write("=\u02f5\n=\3>\5>\u02f8\n>\3>\3>\3>\7>\u02fd\n>\f>\16>")
        buf.write("\u0300\13>\3>\3>\3>\3?\3?\3?\7?\u0308\n?\f?\16?\u030b")
        buf.write("\13?\3?\3?\3@\3@\3@\7@\u0312\n@\f@\16@\u0315\13@\3@\3")
        buf.write("@\3A\3A\3A\7A\u031c\nA\fA\16A\u031f\13A\3A\5A\u0322\n")
        buf.write("A\3A\5A\u0325\nA\3A\3A\3B\3B\3B\3B\3B\3B\3B\3B\3B\3B\3")
        buf.write("B\5B\u0334\nB\3C\3C\7C\u0338\nC\fC\16C\u033b\13C\3C\5")
        buf.write("C\u033e\nC\3C\3C\3D\6D\u0343\nD\rD\16D\u0344\3E\3E\3E")
        buf.write("\3E\5E\u034b\nE\3F\3F\3F\3F\3F\3F\3F\3F\5F\u0355\nF\3")
        buf.write("F\3F\3F\3F\3F\3F\5F\u035d\nF\3G\3G\3G\3G\3G\3G\3G\3G\3")
        buf.write("G\3G\3G\3G\3G\3G\3G\3G\5G\u036f\nG\3H\3H\3H\3H\3H\3H\3")
        buf.write("H\3H\3H\3H\3H\3H\3H\5H\u037e\nH\3H\2\2I\2\4\6\b\n\f\16")
        buf.write("\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDF")
        buf.write("HJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082\u0084\u0086")
        buf.write("\u0088\u008a\u008c\u008e\2\f\3\2\b\f\3\2\27\30\3\2\33")
        buf.write("\'\5\2,,./\679\4\2\7\7:C\3\2IJ\3\2KN\3\2OP\3\2\4\4\3\2")
        buf.write("\26\26\2\u03d8\2\u0093\3\2\2\2\4\u00a8\3\2\2\2\6\u00ab")
        buf.write("\3\2\2\2\b\u00bd\3\2\2\2\n\u00d0\3\2\2\2\f\u00d2\3\2\2")
        buf.write("\2\16\u00da\3\2\2\2\20\u00df\3\2\2\2\22\u00f9\3\2\2\2")
        buf.write("\24\u00fb\3\2\2\2\26\u0108\3\2\2\2\30\u010a\3\2\2\2\32")
        buf.write("\u010d\3\2\2\2\34\u0111\3\2\2\2\36\u0117\3\2\2\2 \u011b")
        buf.write("\3\2\2\2\"\u012a\3\2\2\2$\u013f\3\2\2\2&\u0141\3\2\2\2")
        buf.write("(\u0149\3\2\2\2*\u014e\3\2\2\2,\u015e\3\2\2\2.\u0172\3")
        buf.write("\2\2\2\60\u0184\3\2\2\2\62\u0192\3\2\2\2\64\u0194\3\2")
        buf.write("\2\2\66\u019c\3\2\2\28\u01b9\3\2\2\2:\u01bb\3\2\2\2<\u01c8")
        buf.write("\3\2\2\2>\u01cf\3\2\2\2@\u01d6\3\2\2\2B\u01ea\3\2\2\2")
        buf.write("D\u01f4\3\2\2\2F\u01f6\3\2\2\2H\u01fe\3\2\2\2J\u020c\3")
        buf.write("\2\2\2L\u0216\3\2\2\2N\u0228\3\2\2\2P\u0239\3\2\2\2R\u023b")
        buf.write("\3\2\2\2T\u025d\3\2\2\2V\u0265\3\2\2\2X\u026d\3\2\2\2")
        buf.write("Z\u0289\3\2\2\2\\\u028b\3\2\2\2^\u0293\3\2\2\2`\u029a")
        buf.write("\3\2\2\2b\u029c\3\2\2\2d\u029e\3\2\2\2f\u02a0\3\2\2\2")
        buf.write("h\u02a9\3\2\2\2j\u02b1\3\2\2\2l\u02b9\3\2\2\2n\u02c1\3")
        buf.write("\2\2\2p\u02c9\3\2\2\2r\u02d1\3\2\2\2t\u02d9\3\2\2\2v\u02e1")
        buf.write("\3\2\2\2x\u02f4\3\2\2\2z\u02f7\3\2\2\2|\u0304\3\2\2\2")
        buf.write("~\u030e\3\2\2\2\u0080\u0318\3\2\2\2\u0082\u0333\3\2\2")
        buf.write("\2\u0084\u0335\3\2\2\2\u0086\u0342\3\2\2\2\u0088\u034a")
        buf.write("\3\2\2\2\u008a\u035c\3\2\2\2\u008c\u036e\3\2\2\2\u008e")
        buf.write("\u037d\3\2\2\2\u0090\u0092\5\4\3\2\u0091\u0090\3\2\2\2")
        buf.write("\u0092\u0095\3\2\2\2\u0093\u0091\3\2\2\2\u0093\u0094\3")
        buf.write("\2\2\2\u0094\3\3\2\2\2\u0095\u0093\3\2\2\2\u0096\u0098")
        buf.write("\5\b\5\2\u0097\u0096\3\2\2\2\u0097\u0098\3\2\2\2\u0098")
        buf.write("\u0099\3\2\2\2\u0099\u009d\5,\27\2\u009a\u009c\5\n\6\2")
        buf.write("\u009b\u009a\3\2\2\2\u009c\u009f\3\2\2\2\u009d\u009b\3")
        buf.write("\2\2\2\u009d\u009e\3\2\2\2\u009e\u00a0\3\2\2\2\u009f\u009d")
        buf.write("\3\2\2\2\u00a0\u00a1\7\3\2\2\u00a1\u00a9\3\2\2\2\u00a2")
        buf.write("\u00a9\5\6\4\2\u00a3\u00a9\5\n\6\2\u00a4\u00a6\5\u0080")
        buf.write("A\2\u00a5\u00a7\7\4\2\2\u00a6\u00a5\3\2\2\2\u00a6\u00a7")
        buf.write("\3\2\2\2\u00a7\u00a9\3\2\2\2\u00a8\u0097\3\2\2\2\u00a8")
        buf.write("\u00a2\3\2\2\2\u00a8\u00a3\3\2\2\2\u00a8\u00a4\3\2\2\2")
        buf.write("\u00a9\5\3\2\2\2\u00aa\u00ac\5\b\5\2\u00ab\u00aa\3\2\2")
        buf.write("\2\u00ab\u00ac\3\2\2\2\u00ac\u00ad\3\2\2\2\u00ad\u00b6")
        buf.write("\5,\27\2\u00ae\u00b0\5\n\6\2\u00af\u00ae\3\2\2\2\u00b0")
        buf.write("\u00b1\3\2\2\2\u00b1\u00af\3\2\2\2\u00b1\u00b2\3\2\2\2")
        buf.write("\u00b2\u00b3\3\2\2\2\u00b3\u00b4\5\u0084C\2\u00b4\u00b7")
        buf.write("\3\2\2\2\u00b5\u00b7\5\u0084C\2\u00b6\u00af\3\2\2\2\u00b6")
        buf.write("\u00b5\3\2\2\2\u00b7\u00b8\3\2\2\2\u00b8\u00b9\b\4\1\2")
        buf.write("\u00b9\7\3\2\2\2\u00ba\u00be\5\20\t\2\u00bb\u00be\5\22")
        buf.write("\n\2\u00bc\u00be\5*\26\2\u00bd\u00ba\3\2\2\2\u00bd\u00bb")
        buf.write("\3\2\2\2\u00bd\u00bc\3\2\2\2\u00be\u00bf\3\2\2\2\u00bf")
        buf.write("\u00bd\3\2\2\2\u00bf\u00c0\3\2\2\2\u00c0\t\3\2\2\2\u00c1")
        buf.write("\u00c3\7\5\2\2\u00c2\u00c4\5\b\5\2\u00c3\u00c2\3\2\2\2")
        buf.write("\u00c3\u00c4\3\2\2\2\u00c4\u00c5\3\2\2\2\u00c5\u00c6\5")
        buf.write("\f\7\2\u00c6\u00c7\7\4\2\2\u00c7\u00c8\b\6\1\2\u00c8\u00d1")
        buf.write("\3\2\2\2\u00c9\u00cb\5\b\5\2\u00ca\u00cc\5\f\7\2\u00cb")
        buf.write("\u00ca\3\2\2\2\u00cb\u00cc\3\2\2\2\u00cc\u00cd\3\2\2\2")
        buf.write("\u00cd\u00ce\7\4\2\2\u00ce\u00cf\b\6\1\2\u00cf\u00d1\3")
        buf.write("\2\2\2\u00d0\u00c1\3\2\2\2\u00d0\u00c9\3\2\2\2\u00d1\13")
        buf.write("\3\2\2\2\u00d2\u00d7\5\16\b\2\u00d3\u00d4\7\6\2\2\u00d4")
        buf.write("\u00d6\5\16\b\2\u00d5\u00d3\3\2\2\2\u00d6\u00d9\3\2\2")
        buf.write("\2\u00d7\u00d5\3\2\2\2\u00d7\u00d8\3\2\2\2\u00d8\r\3\2")
        buf.write("\2\2\u00d9\u00d7\3\2\2\2\u00da\u00dd\5,\27\2\u00db\u00dc")
        buf.write("\7\7\2\2\u00dc\u00de\5D#\2\u00dd\u00db\3\2\2\2\u00dd\u00de")
        buf.write("\3\2\2\2\u00de\17\3\2\2\2\u00df\u00e0\t\2\2\2\u00e0\21")
        buf.write("\3\2\2\2\u00e1\u00fa\7\r\2\2\u00e2\u00fa\7\16\2\2\u00e3")
        buf.write("\u00fa\7\17\2\2\u00e4\u00fa\7\20\2\2\u00e5\u00fa\7\21")
        buf.write("\2\2\u00e6\u00fa\7\22\2\2\u00e7\u00fa\7\23\2\2\u00e8\u00fa")
        buf.write("\7\24\2\2\u00e9\u00fa\7\25\2\2\u00ea\u00eb\5\26\f\2\u00eb")
        buf.write("\u00ec\b\n\1\2\u00ec\u00fa\3\2\2\2\u00ed\u00ee\5$\23\2")
        buf.write("\u00ee\u00ef\b\n\1\2\u00ef\u00fa\3\2\2\2\u00f0\u00f4\7")
        buf.write("_\2\2\u00f1\u00f3\5*\26\2\u00f2\u00f1\3\2\2\2\u00f3\u00f6")
        buf.write("\3\2\2\2\u00f4\u00f2\3\2\2\2\u00f4\u00f5\3\2\2\2\u00f5")
        buf.write("\u00f7\3\2\2\2\u00f6\u00f4\3\2\2\2\u00f7\u00fa\5,\27\2")
        buf.write("\u00f8\u00fa\5\24\13\2\u00f9\u00e1\3\2\2\2\u00f9\u00e2")
        buf.write("\3\2\2\2\u00f9\u00e3\3\2\2\2\u00f9\u00e4\3\2\2\2\u00f9")
        buf.write("\u00e5\3\2\2\2\u00f9\u00e6\3\2\2\2\u00f9\u00e7\3\2\2\2")
        buf.write("\u00f9\u00e8\3\2\2\2\u00f9\u00e9\3\2\2\2\u00f9\u00ea\3")
        buf.write("\2\2\2\u00f9\u00ed\3\2\2\2\u00f9\u00f0\3\2\2\2\u00f9\u00f8")
        buf.write("\3\2\2\2\u00fa\23\3\2\2\2\u00fb\u00fc\7_\2\2\u00fc\25")
        buf.write("\3\2\2\2\u00fd\u00ff\5\30\r\2\u00fe\u0100\7_\2\2\u00ff")
        buf.write("\u00fe\3\2\2\2\u00ff\u0100\3\2\2\2\u0100\u0101\3\2\2\2")
        buf.write("\u0101\u0102\7\3\2\2\u0102\u0103\5\32\16\2\u0103\u0104")
        buf.write("\7\26\2\2\u0104\u0109\3\2\2\2\u0105\u0106\5\30\r\2\u0106")
        buf.write("\u0107\7_\2\2\u0107\u0109\3\2\2\2\u0108\u00fd\3\2\2\2")
        buf.write("\u0108\u0105\3\2\2\2\u0109\27\3\2\2\2\u010a\u010b\t\3")
        buf.write("\2\2\u010b\31\3\2\2\2\u010c\u010e\5\34\17\2\u010d\u010c")
        buf.write("\3\2\2\2\u010e\u010f\3\2\2\2\u010f\u010d\3\2\2\2\u010f")
        buf.write("\u0110\3\2\2\2\u0110\33\3\2\2\2\u0111\u0112\5\36\20\2")
        buf.write("\u0112\u0113\5 \21\2\u0113\u0114\7\4\2\2\u0114\35\3\2")
        buf.write("\2\2\u0115\u0118\5*\26\2\u0116\u0118\5\22\n\2\u0117\u0115")
        buf.write("\3\2\2\2\u0117\u0116\3\2\2\2\u0118\u0119\3\2\2\2\u0119")
        buf.write("\u0117\3\2\2\2\u0119\u011a\3\2\2\2\u011a\37\3\2\2\2\u011b")
        buf.write("\u0120\5\"\22\2\u011c\u011d\7\6\2\2\u011d\u011f\5\"\22")
        buf.write("\2\u011e\u011c\3\2\2\2\u011f\u0122\3\2\2\2\u0120\u011e")
        buf.write("\3\2\2\2\u0120\u0121\3\2\2\2\u0121!\3\2\2\2\u0122\u0120")
        buf.write("\3\2\2\2\u0123\u0126\5,\27\2\u0124\u0125\7\31\2\2\u0125")
        buf.write("\u0127\5^\60\2\u0126\u0124\3\2\2\2\u0126\u0127\3\2\2\2")
        buf.write("\u0127\u012b\3\2\2\2\u0128\u0129\7\31\2\2\u0129\u012b")
        buf.write("\5^\60\2\u012a\u0123\3\2\2\2\u012a\u0128\3\2\2\2\u012b")
        buf.write("#\3\2\2\2\u012c\u012d\7\32\2\2\u012d\u012e\7\3\2\2\u012e")
        buf.write("\u0130\5&\24\2\u012f\u0131\7\6\2\2\u0130\u012f\3\2\2\2")
        buf.write("\u0130\u0131\3\2\2\2\u0131\u0132\3\2\2\2\u0132\u0133\7")
        buf.write("\26\2\2\u0133\u0140\3\2\2\2\u0134\u0135\7\32\2\2\u0135")
        buf.write("\u0136\7_\2\2\u0136\u0137\7\3\2\2\u0137\u0139\5&\24\2")
        buf.write("\u0138\u013a\7\6\2\2\u0139\u0138\3\2\2\2\u0139\u013a\3")
        buf.write("\2\2\2\u013a\u013b\3\2\2\2\u013b\u013c\7\26\2\2\u013c")
        buf.write("\u0140\3\2\2\2\u013d\u013e\7\32\2\2\u013e\u0140\7_\2\2")
        buf.write("\u013f\u012c\3\2\2\2\u013f\u0134\3\2\2\2\u013f\u013d\3")
        buf.write("\2\2\2\u0140%\3\2\2\2\u0141\u0146\5(\25\2\u0142\u0143")
        buf.write("\7\6\2\2\u0143\u0145\5(\25\2\u0144\u0142\3\2\2\2\u0145")
        buf.write("\u0148\3\2\2\2\u0146\u0144\3\2\2\2\u0146\u0147\3\2\2\2")
        buf.write("\u0147\'\3\2\2\2\u0148\u0146\3\2\2\2\u0149\u014c\7_\2")
        buf.write("\2\u014a\u014b\7\7\2\2\u014b\u014d\5^\60\2\u014c\u014a")
        buf.write("\3\2\2\2\u014c\u014d\3\2\2\2\u014d)\3\2\2\2\u014e\u014f")
        buf.write("\t\4\2\2\u014f+\3\2\2\2\u0150\u0152\5\62\32\2\u0151\u0150")
        buf.write("\3\2\2\2\u0151\u0152\3\2\2\2\u0152\u0154\3\2\2\2\u0153")
        buf.write("\u0155\7$\2\2\u0154\u0153\3\2\2\2\u0154\u0155\3\2\2\2")
        buf.write("\u0155\u0157\3\2\2\2\u0156\u0158\7%\2\2\u0157\u0156\3")
        buf.write("\2\2\2\u0157\u0158\3\2\2\2\u0158\u015a\3\2\2\2\u0159\u015b")
        buf.write("\7&\2\2\u015a\u0159\3\2\2\2\u015a\u015b\3\2\2\2\u015b")
        buf.write("\u015c\3\2\2\2\u015c\u015f\5.\30\2\u015d\u015f\5\62\32")
        buf.write("\2\u015e\u0151\3\2\2\2\u015e\u015d\3\2\2\2\u015f-\3\2")
        buf.write("\2\2\u0160\u0164\7_\2\2\u0161\u0163\5\60\31\2\u0162\u0161")
        buf.write("\3\2\2\2\u0163\u0166\3\2\2\2\u0164\u0162\3\2\2\2\u0164")
        buf.write("\u0165\3\2\2\2\u0165\u0173\3\2\2\2\u0166\u0164\3\2\2\2")
        buf.write("\u0167\u0169\7(\2\2\u0168\u016a\7$\2\2\u0169\u0168\3\2")
        buf.write("\2\2\u0169\u016a\3\2\2\2\u016a\u016b\3\2\2\2\u016b\u016c")
        buf.write("\5,\27\2\u016c\u016e\7)\2\2\u016d\u016f\5\60\31\2\u016e")
        buf.write("\u016d\3\2\2\2\u016f\u0170\3\2\2\2\u0170\u016e\3\2\2\2")
        buf.write("\u0170\u0171\3\2\2\2\u0171\u0173\3\2\2\2\u0172\u0160\3")
        buf.write("\2\2\2\u0172\u0167\3\2\2\2\u0173/\3\2\2\2\u0174\u0175")
        buf.write("\7*\2\2\u0175\u0176\5^\60\2\u0176\u0177\7+\2\2\u0177\u0185")
        buf.write("\3\2\2\2\u0178\u0179\7*\2\2\u0179\u0185\7+\2\2\u017a\u017b")
        buf.write("\7(\2\2\u017b\u017c\5\64\33\2\u017c\u017d\7)\2\2\u017d")
        buf.write("\u0185\3\2\2\2\u017e\u017f\7(\2\2\u017f\u0180\5:\36\2")
        buf.write("\u0180\u0181\7)\2\2\u0181\u0185\3\2\2\2\u0182\u0183\7")
        buf.write("(\2\2\u0183\u0185\7)\2\2\u0184\u0174\3\2\2\2\u0184\u0178")
        buf.write("\3\2\2\2\u0184\u017a\3\2\2\2\u0184\u017e\3\2\2\2\u0184")
        buf.write("\u0182\3\2\2\2\u0185\61\3\2\2\2\u0186\u0188\7,\2\2\u0187")
        buf.write("\u0189\5*\26\2\u0188\u0187\3\2\2\2\u0189\u018a\3\2\2\2")
        buf.write("\u018a\u0188\3\2\2\2\u018a\u018b\3\2\2\2\u018b\u018d\3")
        buf.write("\2\2\2\u018c\u018e\5\62\32\2\u018d\u018c\3\2\2\2\u018d")
        buf.write("\u018e\3\2\2\2\u018e\u0193\3\2\2\2\u018f\u0190\7,\2\2")
        buf.write("\u0190\u0193\5\62\32\2\u0191\u0193\7,\2\2\u0192\u0186")
        buf.write("\3\2\2\2\u0192\u018f\3\2\2\2\u0192\u0191\3\2\2\2\u0193")
        buf.write("\63\3\2\2\2\u0194\u019a\5\66\34\2\u0195\u0197\7\6\2\2")
        buf.write("\u0196\u0198\7\37\2\2\u0197\u0196\3\2\2\2\u0197\u0198")
        buf.write("\3\2\2\2\u0198\u0199\3\2\2\2\u0199\u019b\7-\2\2\u019a")
        buf.write("\u0195\3\2\2\2\u019a\u019b\3\2\2\2\u019b\65\3\2\2\2\u019c")
        buf.write("\u01a4\58\35\2\u019d\u019f\7\6\2\2\u019e\u01a0\7\37\2")
        buf.write("\2\u019f\u019e\3\2\2\2\u019f\u01a0\3\2\2\2\u01a0\u01a1")
        buf.write("\3\2\2\2\u01a1\u01a3\58\35\2\u01a2\u019d\3\2\2\2\u01a3")
        buf.write("\u01a6\3\2\2\2\u01a4\u01a2\3\2\2\2\u01a4\u01a5\3\2\2\2")
        buf.write("\u01a5\67\3\2\2\2\u01a6\u01a4\3\2\2\2\u01a7\u01ac\5\b")
        buf.write("\5\2\u01a8\u01ab\5,\27\2\u01a9\u01ab\5> \2\u01aa\u01a8")
        buf.write("\3\2\2\2\u01aa\u01a9\3\2\2\2\u01ab\u01ae\3\2\2\2\u01ac")
        buf.write("\u01aa\3\2\2\2\u01ac\u01ad\3\2\2\2\u01ad\u01b0\3\2\2\2")
        buf.write("\u01ae\u01ac\3\2\2\2\u01af\u01b1\7\37\2\2\u01b0\u01af")
        buf.write("\3\2\2\2\u01b0\u01b1\3\2\2\2\u01b1\u01ba\3\2\2\2\u01b2")
        buf.write("\u01b4\5\62\32\2\u01b3\u01b2\3\2\2\2\u01b4\u01b7\3\2\2")
        buf.write("\2\u01b5\u01b3\3\2\2\2\u01b5\u01b6\3\2\2\2\u01b6\u01b8")
        buf.write("\3\2\2\2\u01b7\u01b5\3\2\2\2\u01b8\u01ba\7_\2\2\u01b9")
        buf.write("\u01a7\3\2\2\2\u01b9\u01b5\3\2\2\2\u01ba9\3\2\2\2\u01bb")
        buf.write("\u01c0\7_\2\2\u01bc\u01bd\7\6\2\2\u01bd\u01bf\7_\2\2\u01be")
        buf.write("\u01bc\3\2\2\2\u01bf\u01c2\3\2\2\2\u01c0\u01be\3\2\2\2")
        buf.write("\u01c0\u01c1\3\2\2\2\u01c1;\3\2\2\2\u01c2\u01c0\3\2\2")
        buf.write("\2\u01c3\u01c5\5\36\20\2\u01c4\u01c6\5> \2\u01c5\u01c4")
        buf.write("\3\2\2\2\u01c5\u01c6\3\2\2\2\u01c6\u01c9\3\2\2\2\u01c7")
        buf.write("\u01c9\5\24\13\2\u01c8\u01c3\3\2\2\2\u01c8\u01c7\3\2\2")
        buf.write("\2\u01c9=\3\2\2\2\u01ca\u01cc\5\62\32\2\u01cb\u01cd\5")
        buf.write("@!\2\u01cc\u01cb\3\2\2\2\u01cc\u01cd\3\2\2\2\u01cd\u01d0")
        buf.write("\3\2\2\2\u01ce\u01d0\5@!\2\u01cf\u01ca\3\2\2\2\u01cf\u01ce")
        buf.write("\3\2\2\2\u01d0?\3\2\2\2\u01d1\u01d2\7(\2\2\u01d2\u01d3")
        buf.write("\5> \2\u01d3\u01d4\7)\2\2\u01d4\u01d7\3\2\2\2\u01d5\u01d7")
        buf.write("\5B\"\2\u01d6\u01d1\3\2\2\2\u01d6\u01d5\3\2\2\2\u01d7")
        buf.write("\u01db\3\2\2\2\u01d8\u01da\5B\"\2\u01d9\u01d8\3\2\2\2")
        buf.write("\u01da\u01dd\3\2\2\2\u01db\u01d9\3\2\2\2\u01db\u01dc\3")
        buf.write("\2\2\2\u01dcA\3\2\2\2\u01dd\u01db\3\2\2\2\u01de\u01df")
        buf.write("\7*\2\2\u01df\u01eb\7+\2\2\u01e0\u01e1\7*\2\2\u01e1\u01e2")
        buf.write("\5^\60\2\u01e2\u01e3\7+\2\2\u01e3\u01eb\3\2\2\2\u01e4")
        buf.write("\u01e5\7(\2\2\u01e5\u01eb\7)\2\2\u01e6\u01e7\7(\2\2\u01e7")
        buf.write("\u01e8\5\64\33\2\u01e8\u01e9\7)\2\2\u01e9\u01eb\3\2\2")
        buf.write("\2\u01ea\u01de\3\2\2\2\u01ea\u01e0\3\2\2\2\u01ea\u01e4")
        buf.write("\3\2\2\2\u01ea\u01e6\3\2\2\2\u01ebC\3\2\2\2\u01ec\u01f5")
        buf.write("\5`\61\2\u01ed\u01ee\7\3\2\2\u01ee\u01f0\5F$\2\u01ef\u01f1")
        buf.write("\7\6\2\2\u01f0\u01ef\3\2\2\2\u01f0\u01f1\3\2\2\2\u01f1")
        buf.write("\u01f2\3\2\2\2\u01f2\u01f3\7\26\2\2\u01f3\u01f5\3\2\2")
        buf.write("\2\u01f4\u01ec\3\2\2\2\u01f4\u01ed\3\2\2\2\u01f5E\3\2")
        buf.write("\2\2\u01f6\u01fb\5D#\2\u01f7\u01f8\7\6\2\2\u01f8\u01fa")
        buf.write("\5D#\2\u01f9\u01f7\3\2\2\2\u01fa\u01fd\3\2\2\2\u01fb\u01f9")
        buf.write("\3\2\2\2\u01fb\u01fc\3\2\2\2\u01fcG\3\2\2\2\u01fd\u01fb")
        buf.write("\3\2\2\2\u01fe\u0200\5`\61\2\u01ff\u0201\7\37\2\2\u0200")
        buf.write("\u01ff\3\2\2\2\u0200\u0201\3\2\2\2\u0201\u0209\3\2\2\2")
        buf.write("\u0202\u0203\7\6\2\2\u0203\u0205\5`\61\2\u0204\u0206\7")
        buf.write("\37\2\2\u0205\u0204\3\2\2\2\u0205\u0206\3\2\2\2\u0206")
        buf.write("\u0208\3\2\2\2\u0207\u0202\3\2\2\2\u0208\u020b\3\2\2\2")
        buf.write("\u0209\u0207\3\2\2\2\u0209\u020a\3\2\2\2\u020aI\3\2\2")
        buf.write("\2\u020b\u0209\3\2\2\2\u020c\u0213\5L\'\2\u020d\u020e")
        buf.write("\7.\2\2\u020e\u0212\5L\'\2\u020f\u0210\7/\2\2\u0210\u0212")
        buf.write("\5L\'\2\u0211\u020d\3\2\2\2\u0211\u020f\3\2\2\2\u0212")
        buf.write("\u0215\3\2\2\2\u0213\u0211\3\2\2\2\u0213\u0214\3\2\2\2")
        buf.write("\u0214K\3\2\2\2\u0215\u0213\3\2\2\2\u0216\u021f\5N(\2")
        buf.write("\u0217\u0218\7,\2\2\u0218\u021e\5N(\2\u0219\u021a\7\60")
        buf.write("\2\2\u021a\u021e\5N(\2\u021b\u021c\7\61\2\2\u021c\u021e")
        buf.write("\5N(\2\u021d\u0217\3\2\2\2\u021d\u0219\3\2\2\2\u021d\u021b")
        buf.write("\3\2\2\2\u021e\u0221\3\2\2\2\u021f\u021d\3\2\2\2\u021f")
        buf.write("\u0220\3\2\2\2\u0220M\3\2\2\2\u0221\u021f\3\2\2\2\u0222")
        buf.write("\u0223\7(\2\2\u0223\u0224\5<\37\2\u0224\u0225\7)\2\2\u0225")
        buf.write("\u0226\5N(\2\u0226\u0229\3\2\2\2\u0227\u0229\5P)\2\u0228")
        buf.write("\u0222\3\2\2\2\u0228\u0227\3\2\2\2\u0229O\3\2\2\2\u022a")
        buf.write("\u023a\5R*\2\u022b\u022c\7\62\2\2\u022c\u023a\5P)\2\u022d")
        buf.write("\u022e\7\63\2\2\u022e\u023a\5P)\2\u022f\u0230\5V,\2\u0230")
        buf.write("\u0231\5N(\2\u0231\u023a\3\2\2\2\u0232\u0233\7\64\2\2")
        buf.write("\u0233\u023a\5P)\2\u0234\u0235\7\64\2\2\u0235\u0236\7")
        buf.write("(\2\2\u0236\u0237\5<\37\2\u0237\u0238\7)\2\2\u0238\u023a")
        buf.write("\3\2\2\2\u0239\u022a\3\2\2\2\u0239\u022b\3\2\2\2\u0239")
        buf.write("\u022d\3\2\2\2\u0239\u022f\3\2\2\2\u0239\u0232\3\2\2\2")
        buf.write("\u0239\u0234\3\2\2\2\u023aQ\3\2\2\2\u023b\u023c\5X-\2")
        buf.write("\u023c\u025a\b*\1\2\u023d\u023e\7*\2\2\u023e\u023f\5\\")
        buf.write("/\2\u023f\u0240\7+\2\2\u0240\u0259\3\2\2\2\u0241\u0242")
        buf.write("\7(\2\2\u0242\u0243\7)\2\2\u0243\u0259\b*\1\2\u0244\u0245")
        buf.write("\7(\2\2\u0245\u0246\5H%\2\u0246\u0247\7)\2\2\u0247\u0248")
        buf.write("\b*\1\2\u0248\u0259\3\2\2\2\u0249\u024a\7(\2\2\u024a\u024b")
        buf.write("\5T+\2\u024b\u024c\7)\2\2\u024c\u0259\3\2\2\2\u024d\u024e")
        buf.write("\7\65\2\2\u024e\u024f\7_\2\2\u024f\u0259\b*\1\2\u0250")
        buf.write("\u0251\7,\2\2\u0251\u0252\7_\2\2\u0252\u0259\b*\1\2\u0253")
        buf.write("\u0254\7\66\2\2\u0254\u0255\7_\2\2\u0255\u0259\b*\1\2")
        buf.write("\u0256\u0259\7\62\2\2\u0257\u0259\7\63\2\2\u0258\u023d")
        buf.write("\3\2\2\2\u0258\u0241\3\2\2\2\u0258\u0244\3\2\2\2\u0258")
        buf.write("\u0249\3\2\2\2\u0258\u024d\3\2\2\2\u0258\u0250\3\2\2\2")
        buf.write("\u0258\u0253\3\2\2\2\u0258\u0256\3\2\2\2\u0258\u0257\3")
        buf.write("\2\2\2\u0259\u025c\3\2\2\2\u025a\u0258\3\2\2\2\u025a\u025b")
        buf.write("\3\2\2\2\u025bS\3\2\2\2\u025c\u025a\3\2\2\2\u025d\u0262")
        buf.write("\58\35\2\u025e\u025f\7\6\2\2\u025f\u0261\58\35\2\u0260")
        buf.write("\u025e\3\2\2\2\u0261\u0264\3\2\2\2\u0262\u0260\3\2\2\2")
        buf.write("\u0262\u0263\3\2\2\2\u0263U\3\2\2\2\u0264\u0262\3\2\2")
        buf.write("\2\u0265\u0266\t\5\2\2\u0266W\3\2\2\2\u0267\u026e\7_\2")
        buf.write("\2\u0268\u026e\5Z.\2\u0269\u026a\7(\2\2\u026a\u026b\5")
        buf.write("\\/\2\u026b\u026c\7)\2\2\u026c\u026e\3\2\2\2\u026d\u0267")
        buf.write("\3\2\2\2\u026d\u0268\3\2\2\2\u026d\u0269\3\2\2\2\u026e")
        buf.write("Y\3\2\2\2\u026f\u028a\7b\2\2\u0270\u028a\7d\2\2\u0271")
        buf.write("\u028a\7c\2\2\u0272\u028a\7`\2\2\u0273\u0275\7_\2\2\u0274")
        buf.write("\u0273\3\2\2\2\u0275\u0278\3\2\2\2\u0276\u0274\3\2\2\2")
        buf.write("\u0276\u0277\3\2\2\2\u0277\u027a\3\2\2\2\u0278\u0276\3")
        buf.write("\2\2\2\u0279\u027b\7a\2\2\u027a\u0279\3\2\2\2\u027b\u027c")
        buf.write("\3\2\2\2\u027c\u027a\3\2\2\2\u027c\u027d\3\2\2\2\u027d")
        buf.write("\u027f\3\2\2\2\u027e\u0276\3\2\2\2\u027f\u0280\3\2\2\2")
        buf.write("\u0280\u027e\3\2\2\2\u0280\u0281\3\2\2\2\u0281\u0285\3")
        buf.write("\2\2\2\u0282\u0284\7_\2\2\u0283\u0282\3\2\2\2\u0284\u0287")
        buf.write("\3\2\2\2\u0285\u0283\3\2\2\2\u0285\u0286\3\2\2\2\u0286")
        buf.write("\u028a\3\2\2\2\u0287\u0285\3\2\2\2\u0288\u028a\7e\2\2")
        buf.write("\u0289\u026f\3\2\2\2\u0289\u0270\3\2\2\2\u0289\u0271\3")
        buf.write("\2\2\2\u0289\u0272\3\2\2\2\u0289\u027e\3\2\2\2\u0289\u0288")
        buf.write("\3\2\2\2\u028a[\3\2\2\2\u028b\u0290\5`\61\2\u028c\u028d")
        buf.write("\7\6\2\2\u028d\u028f\5`\61\2\u028e\u028c\3\2\2\2\u028f")
        buf.write("\u0292\3\2\2\2\u0290\u028e\3\2\2\2\u0290\u0291\3\2\2\2")
        buf.write("\u0291]\3\2\2\2\u0292\u0290\3\2\2\2\u0293\u0294\5f\64")
        buf.write("\2\u0294_\3\2\2\2\u0295\u0296\5b\62\2\u0296\u0297\5d\63")
        buf.write("\2\u0297\u0298\5`\61\2\u0298\u029b\3\2\2\2\u0299\u029b")
        buf.write("\5f\64\2\u029a\u0295\3\2\2\2\u029a\u0299\3\2\2\2\u029b")
        buf.write("a\3\2\2\2\u029c\u029d\5P)\2\u029dc\3\2\2\2\u029e\u029f")
        buf.write("\t\6\2\2\u029fe\3\2\2\2\u02a0\u02a7\5h\65\2\u02a1\u02a2")
        buf.write("\7D\2\2\u02a2\u02a3\5\\/\2\u02a3\u02a4\7\31\2\2\u02a4")
        buf.write("\u02a5\5f\64\2\u02a5\u02a6\b\64\1\2\u02a6\u02a8\3\2\2")
        buf.write("\2\u02a7\u02a1\3\2\2\2\u02a7\u02a8\3\2\2\2\u02a8g\3\2")
        buf.write("\2\2\u02a9\u02ae\5j\66\2\u02aa\u02ab\7E\2\2\u02ab\u02ad")
        buf.write("\5j\66\2\u02ac\u02aa\3\2\2\2\u02ad\u02b0\3\2\2\2\u02ae")
        buf.write("\u02ac\3\2\2\2\u02ae\u02af\3\2\2\2\u02afi\3\2\2\2\u02b0")
        buf.write("\u02ae\3\2\2\2\u02b1\u02b6\5l\67\2\u02b2\u02b3\7F\2\2")
        buf.write("\u02b3\u02b5\5l\67\2\u02b4\u02b2\3\2\2\2\u02b5\u02b8\3")
        buf.write("\2\2\2\u02b6\u02b4\3\2\2\2\u02b6\u02b7\3\2\2\2\u02b7k")
        buf.write("\3\2\2\2\u02b8\u02b6\3\2\2\2\u02b9\u02be\5n8\2\u02ba\u02bb")
        buf.write("\7G\2\2\u02bb\u02bd\5n8\2\u02bc\u02ba\3\2\2\2\u02bd\u02c0")
        buf.write("\3\2\2\2\u02be\u02bc\3\2\2\2\u02be\u02bf\3\2\2\2\u02bf")
        buf.write("m\3\2\2\2\u02c0\u02be\3\2\2\2\u02c1\u02c6\5p9\2\u02c2")
        buf.write("\u02c3\7H\2\2\u02c3\u02c5\5p9\2\u02c4\u02c2\3\2\2\2\u02c5")
        buf.write("\u02c8\3\2\2\2\u02c6\u02c4\3\2\2\2\u02c6\u02c7\3\2\2\2")
        buf.write("\u02c7o\3\2\2\2\u02c8\u02c6\3\2\2\2\u02c9\u02ce\5r:\2")
        buf.write("\u02ca\u02cb\7\67\2\2\u02cb\u02cd\5r:\2\u02cc\u02ca\3")
        buf.write("\2\2\2\u02cd\u02d0\3\2\2\2\u02ce\u02cc\3\2\2\2\u02ce\u02cf")
        buf.write("\3\2\2\2\u02cfq\3\2\2\2\u02d0\u02ce\3\2\2\2\u02d1\u02d6")
        buf.write("\5t;\2\u02d2\u02d3\t\7\2\2\u02d3\u02d5\5t;\2\u02d4\u02d2")
        buf.write("\3\2\2\2\u02d5\u02d8\3\2\2\2\u02d6\u02d4\3\2\2\2\u02d6")
        buf.write("\u02d7\3\2\2\2\u02d7s\3\2\2\2\u02d8\u02d6\3\2\2\2\u02d9")
        buf.write("\u02de\5v<\2\u02da\u02db\t\b\2\2\u02db\u02dd\5v<\2\u02dc")
        buf.write("\u02da\3\2\2\2\u02dd\u02e0\3\2\2\2\u02de\u02dc\3\2\2\2")
        buf.write("\u02de\u02df\3\2\2\2\u02dfu\3\2\2\2\u02e0\u02de\3\2\2")
        buf.write("\2\u02e1\u02e6\5J&\2\u02e2\u02e3\t\t\2\2\u02e3\u02e5\5")
        buf.write("J&\2\u02e4\u02e2\3\2\2\2\u02e5\u02e8\3\2\2\2\u02e6\u02e4")
        buf.write("\3\2\2\2\u02e6\u02e7\3\2\2\2\u02e7w\3\2\2\2\u02e8\u02e6")
        buf.write("\3\2\2\2\u02e9\u02f5\5\u0082B\2\u02ea\u02f5\5\u0084C\2")
        buf.write("\u02eb\u02f5\5\u0088E\2\u02ec\u02f5\5\u008aF\2\u02ed\u02f5")
        buf.write("\5\u008cG\2\u02ee\u02f5\5\u008eH\2\u02ef\u02f5\5\u0080")
        buf.write("A\2\u02f0\u02f5\5z>\2\u02f1\u02f5\5|?\2\u02f2\u02f5\5")
        buf.write("~@\2\u02f3\u02f5\5\n\6\2\u02f4\u02e9\3\2\2\2\u02f4\u02ea")
        buf.write("\3\2\2\2\u02f4\u02eb\3\2\2\2\u02f4\u02ec\3\2\2\2\u02f4")
        buf.write("\u02ed\3\2\2\2\u02f4\u02ee\3\2\2\2\u02f4\u02ef\3\2\2\2")
        buf.write("\u02f4\u02f0\3\2\2\2\u02f4\u02f1\3\2\2\2\u02f4\u02f2\3")
        buf.write("\2\2\2\u02f4\u02f3\3\2\2\2\u02f5y\3\2\2\2\u02f6\u02f8")
        buf.write("\7Q\2\2\u02f7\u02f6\3\2\2\2\u02f7\u02f8\3\2\2\2\u02f8")
        buf.write("\u02f9\3\2\2\2\u02f9\u02fa\7_\2\2\u02fa\u02fe\7(\2\2\u02fb")
        buf.write("\u02fd\n\n\2\2\u02fc\u02fb\3\2\2\2\u02fd\u0300\3\2\2\2")
        buf.write("\u02fe\u02fc\3\2\2\2\u02fe\u02ff\3\2\2\2\u02ff\u0301\3")
        buf.write("\2\2\2\u0300\u02fe\3\2\2\2\u0301\u0302\7)\2\2\u0302\u0303")
        buf.write("\7\4\2\2\u0303{\3\2\2\2\u0304\u0305\7R\2\2\u0305\u0309")
        buf.write("\7\3\2\2\u0306\u0308\n\13\2\2\u0307\u0306\3\2\2\2\u0308")
        buf.write("\u030b\3\2\2\2\u0309\u0307\3\2\2\2\u0309\u030a\3\2\2\2")
        buf.write("\u030a\u030c\3\2\2\2\u030b\u0309\3\2\2\2\u030c\u030d\7")
        buf.write("\26\2\2\u030d}\3\2\2\2\u030e\u030f\7S\2\2\u030f\u0313")
        buf.write("\7\3\2\2\u0310\u0312\n\13\2\2\u0311\u0310\3\2\2\2\u0312")
        buf.write("\u0315\3\2\2\2\u0313\u0311\3\2\2\2\u0313\u0314\3\2\2\2")
        buf.write("\u0314\u0316\3\2\2\2\u0315\u0313\3\2\2\2\u0316\u0317\7")
        buf.write("\26\2\2\u0317\177\3\2\2\2\u0318\u0319\7_\2\2\u0319\u031d")
        buf.write("\7(\2\2\u031a\u031c\5\n\6\2\u031b\u031a\3\2\2\2\u031c")
        buf.write("\u031f\3\2\2\2\u031d\u031b\3\2\2\2\u031d\u031e\3\2\2\2")
        buf.write("\u031e\u0321\3\2\2\2\u031f\u031d\3\2\2\2\u0320\u0322\5")
        buf.write("\u0086D\2\u0321\u0320\3\2\2\2\u0321\u0322\3\2\2\2\u0322")
        buf.write("\u0324\3\2\2\2\u0323\u0325\5\\/\2\u0324\u0323\3\2\2\2")
        buf.write("\u0324\u0325\3\2\2\2\u0325\u0326\3\2\2\2\u0326\u0327\7")
        buf.write(")\2\2\u0327\u0081\3\2\2\2\u0328\u0329\7_\2\2\u0329\u032a")
        buf.write("\7\31\2\2\u032a\u0334\5x=\2\u032b\u032c\7T\2\2\u032c\u032d")
        buf.write("\5^\60\2\u032d\u032e\7\31\2\2\u032e\u032f\5x=\2\u032f")
        buf.write("\u0334\3\2\2\2\u0330\u0331\7U\2\2\u0331\u0332\7\31\2\2")
        buf.write("\u0332\u0334\5x=\2\u0333\u0328\3\2\2\2\u0333\u032b\3\2")
        buf.write("\2\2\u0333\u0330\3\2\2\2\u0334\u0083\3\2\2\2\u0335\u0339")
        buf.write("\7\3\2\2\u0336\u0338\5\n\6\2\u0337\u0336\3\2\2\2\u0338")
        buf.write("\u033b\3\2\2\2\u0339\u0337\3\2\2\2\u0339\u033a\3\2\2\2")
        buf.write("\u033a\u033d\3\2\2\2\u033b\u0339\3\2\2\2\u033c\u033e\5")
        buf.write("\u0086D\2\u033d\u033c\3\2\2\2\u033d\u033e\3\2\2\2\u033e")
        buf.write("\u033f\3\2\2\2\u033f\u0340\7\26\2\2\u0340\u0085\3\2\2")
        buf.write("\2\u0341\u0343\5x=\2\u0342\u0341\3\2\2\2\u0343\u0344\3")
        buf.write("\2\2\2\u0344\u0342\3\2\2\2\u0344\u0345\3\2\2\2\u0345\u0087")
        buf.write("\3\2\2\2\u0346\u034b\7\4\2\2\u0347\u0348\5\\/\2\u0348")
        buf.write("\u0349\7\4\2\2\u0349\u034b\3\2\2\2\u034a\u0346\3\2\2\2")
        buf.write("\u034a\u0347\3\2\2\2\u034b\u0089\3\2\2\2\u034c\u034d\7")
        buf.write("V\2\2\u034d\u034e\7(\2\2\u034e\u034f\5\\/\2\u034f\u0350")
        buf.write("\7)\2\2\u0350\u0351\bF\1\2\u0351\u0354\5x=\2\u0352\u0353")
        buf.write("\7W\2\2\u0353\u0355\5x=\2\u0354\u0352\3\2\2\2\u0354\u0355")
        buf.write("\3\2\2\2\u0355\u035d\3\2\2\2\u0356\u0357\7X\2\2\u0357")
        buf.write("\u0358\7(\2\2\u0358\u0359\5\\/\2\u0359\u035a\7)\2\2\u035a")
        buf.write("\u035b\5x=\2\u035b\u035d\3\2\2\2\u035c\u034c\3\2\2\2\u035c")
        buf.write("\u0356\3\2\2\2\u035d\u008b\3\2\2\2\u035e\u035f\7Y\2\2")
        buf.write("\u035f\u0360\7(\2\2\u0360\u0361\5\\/\2\u0361\u0362\7)")
        buf.write("\2\2\u0362\u0363\5x=\2\u0363\u0364\bG\1\2\u0364\u036f")
        buf.write("\3\2\2\2\u0365\u0366\7Z\2\2\u0366\u0367\5x=\2\u0367\u0368")
        buf.write("\7Y\2\2\u0368\u0369\7(\2\2\u0369\u036a\5\\/\2\u036a\u036b")
        buf.write("\7)\2\2\u036b\u036c\7\4\2\2\u036c\u036d\bG\1\2\u036d\u036f")
        buf.write("\3\2\2\2\u036e\u035e\3\2\2\2\u036e\u0365\3\2\2\2\u036f")
        buf.write("\u008d\3\2\2\2\u0370\u0371\7[\2\2\u0371\u0372\7_\2\2\u0372")
        buf.write("\u037e\7\4\2\2\u0373\u0374\7\\\2\2\u0374\u037e\7\4\2\2")
        buf.write("\u0375\u0376\7]\2\2\u0376\u037e\7\4\2\2\u0377\u0378\7")
        buf.write("^\2\2\u0378\u037e\7\4\2\2\u0379\u037a\7^\2\2\u037a\u037b")
        buf.write("\5\\/\2\u037b\u037c\7\4\2\2\u037c\u037e\3\2\2\2\u037d")
        buf.write("\u0370\3\2\2\2\u037d\u0373\3\2\2\2\u037d\u0375\3\2\2\2")
        buf.write("\u037d\u0377\3\2\2\2\u037d\u0379\3\2\2\2\u037e\u008f\3")
        buf.write("\2\2\2o\u0093\u0097\u009d\u00a6\u00a8\u00ab\u00b1\u00b6")
        buf.write("\u00bd\u00bf\u00c3\u00cb\u00d0\u00d7\u00dd\u00f4\u00f9")
        buf.write("\u00ff\u0108\u010f\u0117\u0119\u0120\u0126\u012a\u0130")
        buf.write("\u0139\u013f\u0146\u014c\u0151\u0154\u0157\u015a\u015e")
        buf.write("\u0164\u0169\u0170\u0172\u0184\u018a\u018d\u0192\u0197")
        buf.write("\u019a\u019f\u01a4\u01aa\u01ac\u01b0\u01b5\u01b9\u01c0")
        buf.write("\u01c5\u01c8\u01cc\u01cf\u01d6\u01db\u01ea\u01f0\u01f4")
        buf.write("\u01fb\u0200\u0205\u0209\u0211\u0213\u021d\u021f\u0228")
        buf.write("\u0239\u0258\u025a\u0262\u026d\u0276\u027c\u0280\u0285")
        buf.write("\u0289\u0290\u029a\u02a7\u02ae\u02b6\u02be\u02c6\u02ce")
        buf.write("\u02d6\u02de\u02e6\u02f4\u02f7\u02fe\u0309\u0313\u031d")
        buf.write("\u0321\u0324\u0333\u0339\u033d\u0344\u034a\u0354\u035c")
        buf.write("\u036e\u037d")
        return buf.getvalue()


class CParser ( Parser ):

    grammarFileName = "C.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'{'", "';'", "'typedef'", "','", "'='",
                     "'extern'", "'static'", "'auto'", "'register'", "'STATIC'",
                     "'void'", "'char'", "'short'", "'int'", "'long'", "'float'",
                     "'double'", "'signed'", "'unsigned'", "'}'", "'struct'",
                     "'union'", "':'", "'enum'", "'const'", "'volatile'",
                     "'IN'", "'OUT'", "'OPTIONAL'", "'CONST'", "'UNALIGNED'",
                     "'VOLATILE'", "'GLOBAL_REMOVE_IF_UNREFERENCED'", "'EFIAPI'",
                     "'EFI_BOOTSERVICE'", "'EFI_RUNTIMESERVICE'", "'PACKED'",
                     "'('", "')'", "'['", "']'", "'*'", "'...'", "'+'",
                     "'-'", "'/'", "'%'", "'++'", "'--'", "'sizeof'", "'.'",
                     "'->'", "'&'", "'~'", "'!'", "'*='", "'/='", "'%='",
                     "'+='", "'-='", "'<<='", "'>>='", "'&='", "'^='", "'|='",
                     "'?'", "'||'", "'&&'", "'|'", "'^'", "'=='", "'!='",
                     "'<'", "'>'", "'<='", "'>='", "'<<'", "'>>'", "'__asm__'",
                     "'_asm'", "'__asm'", "'case'", "'default'", "'if'",
                     "'else'", "'switch'", "'while'", "'do'", "'goto'",
                     "'continue'", "'break'", "'return'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                      "<INVALID>", "IDENTIFIER", "CHARACTER_LITERAL", "STRING_LITERAL",
                      "HEX_LITERAL", "DECIMAL_LITERAL", "OCTAL_LITERAL",
                      "FLOATING_POINT_LITERAL", "WS", "BS", "UnicodeVocabulary",
                      "COMMENT", "LINE_COMMENT", "LINE_COMMAND" ]

    RULE_translation_unit = 0
    RULE_external_declaration = 1
    RULE_function_definition = 2
    RULE_declaration_specifiers = 3
    RULE_declaration = 4
    RULE_init_declarator_list = 5
    RULE_init_declarator = 6
    RULE_storage_class_specifier = 7
    RULE_type_specifier = 8
    RULE_type_id = 9
    RULE_struct_or_union_specifier = 10
    RULE_struct_or_union = 11
    RULE_struct_declaration_list = 12
    RULE_struct_declaration = 13
    RULE_specifier_qualifier_list = 14
    RULE_struct_declarator_list = 15
    RULE_struct_declarator = 16
    RULE_enum_specifier = 17
    RULE_enumerator_list = 18
    RULE_enumerator = 19
    RULE_type_qualifier = 20
    RULE_declarator = 21
    RULE_direct_declarator = 22
    RULE_declarator_suffix = 23
    RULE_pointer = 24
    RULE_parameter_type_list = 25
    RULE_parameter_list = 26
    RULE_parameter_declaration = 27
    RULE_identifier_list = 28
    RULE_type_name = 29
    RULE_abstract_declarator = 30
    RULE_direct_abstract_declarator = 31
    RULE_abstract_declarator_suffix = 32
    RULE_initializer = 33
    RULE_initializer_list = 34
    RULE_argument_expression_list = 35
    RULE_additive_expression = 36
    RULE_multiplicative_expression = 37
    RULE_cast_expression = 38
    RULE_unary_expression = 39
    RULE_postfix_expression = 40
    RULE_macro_parameter_list = 41
    RULE_unary_operator = 42
    RULE_primary_expression = 43
    RULE_constant = 44
    RULE_expression = 45
    RULE_constant_expression = 46
    RULE_assignment_expression = 47
    RULE_lvalue = 48
    RULE_assignment_operator = 49
    RULE_conditional_expression = 50
    RULE_logical_or_expression = 51
    RULE_logical_and_expression = 52
    RULE_inclusive_or_expression = 53
    RULE_exclusive_or_expression = 54
    RULE_and_expression = 55
    RULE_equality_expression = 56
    RULE_relational_expression = 57
    RULE_shift_expression = 58
    RULE_statement = 59
    RULE_asm2_statement = 60
    RULE_asm1_statement = 61
    RULE_asm_statement = 62
    RULE_macro_statement = 63
    RULE_labeled_statement = 64
    RULE_compound_statement = 65
    RULE_statement_list = 66
    RULE_expression_statement = 67
    RULE_selection_statement = 68
    RULE_iteration_statement = 69
    RULE_jump_statement = 70

    ruleNames =  [ "translation_unit", "external_declaration", "function_definition",
                   "declaration_specifiers", "declaration", "init_declarator_list",
                   "init_declarator", "storage_class_specifier", "type_specifier",
                   "type_id", "struct_or_union_specifier", "struct_or_union",
                   "struct_declaration_list", "struct_declaration", "specifier_qualifier_list",
                   "struct_declarator_list", "struct_declarator", "enum_specifier",
                   "enumerator_list", "enumerator", "type_qualifier", "declarator",
                   "direct_declarator", "declarator_suffix", "pointer",
                   "parameter_type_list", "parameter_list", "parameter_declaration",
                   "identifier_list", "type_name", "abstract_declarator",
                   "direct_abstract_declarator", "abstract_declarator_suffix",
                   "initializer", "initializer_list", "argument_expression_list",
                   "additive_expression", "multiplicative_expression", "cast_expression",
                   "unary_expression", "postfix_expression", "macro_parameter_list",
                   "unary_operator", "primary_expression", "constant", "expression",
                   "constant_expression", "assignment_expression", "lvalue",
                   "assignment_operator", "conditional_expression", "logical_or_expression",
                   "logical_and_expression", "inclusive_or_expression",
                   "exclusive_or_expression", "and_expression", "equality_expression",
                   "relational_expression", "shift_expression", "statement",
                   "asm2_statement", "asm1_statement", "asm_statement",
                   "macro_statement", "labeled_statement", "compound_statement",
                   "statement_list", "expression_statement", "selection_statement",
                   "iteration_statement", "jump_statement" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    T__81=82
    T__82=83
    T__83=84
    T__84=85
    T__85=86
    T__86=87
    T__87=88
    T__88=89
    T__89=90
    T__90=91
    T__91=92
    IDENTIFIER=93
    CHARACTER_LITERAL=94
    STRING_LITERAL=95
    HEX_LITERAL=96
    DECIMAL_LITERAL=97
    OCTAL_LITERAL=98
    FLOATING_POINT_LITERAL=99
    WS=100
    BS=101
    UnicodeVocabulary=102
    COMMENT=103
    LINE_COMMENT=104
    LINE_COMMAND=105

    # @param  input Type: TokenStream
    # @param  output= sys.stdout Type: TextIO
    def __init__(self,input,output= sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    def printTokenInfo(self,line,offset,tokenText):
        print(str(line)+ ',' + str(offset) + ':' + str(tokenText))

    def StorePredicateExpression(self,StartLine,StartOffset,EndLine,EndOffset,Text):
        PredExp = CodeFragment.PredicateExpression(Text, (StartLine, StartOffset), (EndLine, EndOffset))
        FileProfile.PredicateExpressionList.append(PredExp)

    def StoreEnumerationDefinition(self,StartLine,StartOffset,EndLine,EndOffset,Text):
        EnumDef = CodeFragment.EnumerationDefinition(Text, (StartLine, StartOffset), (EndLine, EndOffset))
        FileProfile.EnumerationDefinitionList.append(EnumDef)

    def StoreStructUnionDefinition(self,StartLine,StartOffset,EndLine,EndOffset,Text):
        SUDef = CodeFragment.StructUnionDefinition(Text, (StartLine, StartOffset), (EndLine, EndOffset))
        FileProfile.StructUnionDefinitionList.append(SUDef)

    def StoreTypedefDefinition(self,StartLine,StartOffset,EndLine,EndOffset,FromText,ToText):
        Tdef = CodeFragment.TypedefDefinition(FromText, ToText, (StartLine, StartOffset), (EndLine, EndOffset))
        FileProfile.TypedefDefinitionList.append(Tdef)

    def StoreFunctionDefinition(self,StartLine,StartOffset,EndLine,EndOffset,ModifierText,DeclText,LeftBraceLine,LeftBraceOffset,DeclLine,DeclOffset):
        FuncDef = CodeFragment.FunctionDefinition(ModifierText, DeclText, (StartLine, StartOffset), (EndLine, EndOffset), (LeftBraceLine, LeftBraceOffset), (DeclLine, DeclOffset))
        FileProfile.FunctionDefinitionList.append(FuncDef)

    def StoreVariableDeclaration(self,StartLine,StartOffset,EndLine,EndOffset,ModifierText,DeclText):
        VarDecl = CodeFragment.VariableDeclaration(ModifierText, DeclText, (StartLine, StartOffset), (EndLine, EndOffset))
        FileProfile.VariableDeclarationList.append(VarDecl)

    def StoreFunctionCalling(self,StartLine,StartOffset,EndLine,EndOffset,FuncName,ParamList):
        FuncCall = CodeFragment.FunctionCalling(FuncName, ParamList, (StartLine, StartOffset), (EndLine, EndOffset))
        FileProfile.FunctionCallingList.append(FuncCall)



    class Translation_unitContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def external_declaration(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.External_declarationContext)
            else:
                return self.getTypedRuleContext(CParser.External_declarationContext,i)


        def getRuleIndex(self):
            return CParser.RULE_translation_unit

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterTranslation_unit" ):
                listener.enterTranslation_unit(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitTranslation_unit" ):
                listener.exitTranslation_unit(self)




    def translation_unit(self):

        localctx = CParser.Translation_unitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_translation_unit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 145
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CParser.T__2) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__10) | (1 << CParser.T__11) | (1 << CParser.T__12) | (1 << CParser.T__13) | (1 << CParser.T__14) | (1 << CParser.T__15) | (1 << CParser.T__16) | (1 << CParser.T__17) | (1 << CParser.T__18) | (1 << CParser.T__20) | (1 << CParser.T__21) | (1 << CParser.T__23) | (1 << CParser.T__24) | (1 << CParser.T__25) | (1 << CParser.T__26) | (1 << CParser.T__27) | (1 << CParser.T__28) | (1 << CParser.T__29) | (1 << CParser.T__30) | (1 << CParser.T__31) | (1 << CParser.T__32) | (1 << CParser.T__33) | (1 << CParser.T__34) | (1 << CParser.T__35) | (1 << CParser.T__36) | (1 << CParser.T__37) | (1 << CParser.T__41))) != 0) or _la==CParser.IDENTIFIER:
                self.state = 142
                self.external_declaration()
                self.state = 147
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class External_declarationContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declarator(self):
            return self.getTypedRuleContext(CParser.DeclaratorContext,0)


        def declaration_specifiers(self):
            return self.getTypedRuleContext(CParser.Declaration_specifiersContext,0)


        # @param  i=None Type: int
        def declaration(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.DeclarationContext)
            else:
                return self.getTypedRuleContext(CParser.DeclarationContext,i)


        def function_definition(self):
            return self.getTypedRuleContext(CParser.Function_definitionContext,0)


        def macro_statement(self):
            return self.getTypedRuleContext(CParser.Macro_statementContext,0)


        def getRuleIndex(self):
            return CParser.RULE_external_declaration

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterExternal_declaration" ):
                listener.enterExternal_declaration(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitExternal_declaration" ):
                listener.exitExternal_declaration(self)




    def external_declaration(self):

        localctx = CParser.External_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_external_declaration)
        self._la = 0 # Token type
        try:
            self.state = 166
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 149
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
                if la_ == 1:
                    self.state = 148
                    self.declaration_specifiers()


                self.state = 151
                self.declarator()
                self.state = 155
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CParser.T__2) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__10) | (1 << CParser.T__11) | (1 << CParser.T__12) | (1 << CParser.T__13) | (1 << CParser.T__14) | (1 << CParser.T__15) | (1 << CParser.T__16) | (1 << CParser.T__17) | (1 << CParser.T__18) | (1 << CParser.T__20) | (1 << CParser.T__21) | (1 << CParser.T__23) | (1 << CParser.T__24) | (1 << CParser.T__25) | (1 << CParser.T__26) | (1 << CParser.T__27) | (1 << CParser.T__28) | (1 << CParser.T__29) | (1 << CParser.T__30) | (1 << CParser.T__31) | (1 << CParser.T__32) | (1 << CParser.T__33) | (1 << CParser.T__34) | (1 << CParser.T__35) | (1 << CParser.T__36))) != 0) or _la==CParser.IDENTIFIER:
                    self.state = 152
                    self.declaration()
                    self.state = 157
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 158
                self.match(CParser.T__0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 160
                self.function_definition()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 161
                self.declaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 162
                self.macro_statement()
                self.state = 164
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CParser.T__1:
                    self.state = 163
                    self.match(CParser.T__1)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Function_definitionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ModifierText = ''
            self.DeclText = ''
            self.LBLine = 0
            self.LBOffset = 0
            self.DeclLine = 0
            self.DeclOffset = 0
            self.d = None # Declaration_specifiersContext
            self._declaration_specifiers = None # Declaration_specifiersContext
            self._declarator = None # DeclaratorContext
            self.a = None # Compound_statementContext
            self.b = None # Compound_statementContext

        def declarator(self):
            return self.getTypedRuleContext(CParser.DeclaratorContext,0)


        def compound_statement(self):
            return self.getTypedRuleContext(CParser.Compound_statementContext,0)


        def declaration_specifiers(self):
            return self.getTypedRuleContext(CParser.Declaration_specifiersContext,0)


        # @param  i=None Type: int
        def declaration(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.DeclarationContext)
            else:
                return self.getTypedRuleContext(CParser.DeclarationContext,i)


        def getRuleIndex(self):
            return CParser.RULE_function_definition

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterFunction_definition" ):
                listener.enterFunction_definition(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitFunction_definition" ):
                listener.exitFunction_definition(self)




    def function_definition(self):

        localctx = CParser.Function_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_function_definition)

        ModifierText = '';
        DeclText = '';
        LBLine = 0;
        LBOffset = 0;
        DeclLine = 0;
        DeclOffset = 0;

        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 169
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 168
                localctx.d = localctx._declaration_specifiers = self.declaration_specifiers()


            self.state = 171
            localctx._declarator = self.declarator()
            self.state = 180
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CParser.T__2, CParser.T__5, CParser.T__6, CParser.T__7, CParser.T__8, CParser.T__9, CParser.T__10, CParser.T__11, CParser.T__12, CParser.T__13, CParser.T__14, CParser.T__15, CParser.T__16, CParser.T__17, CParser.T__18, CParser.T__20, CParser.T__21, CParser.T__23, CParser.T__24, CParser.T__25, CParser.T__26, CParser.T__27, CParser.T__28, CParser.T__29, CParser.T__30, CParser.T__31, CParser.T__32, CParser.T__33, CParser.T__34, CParser.T__35, CParser.T__36, CParser.IDENTIFIER]:
                self.state = 173
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 172
                    self.declaration()
                    self.state = 175
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CParser.T__2) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__10) | (1 << CParser.T__11) | (1 << CParser.T__12) | (1 << CParser.T__13) | (1 << CParser.T__14) | (1 << CParser.T__15) | (1 << CParser.T__16) | (1 << CParser.T__17) | (1 << CParser.T__18) | (1 << CParser.T__20) | (1 << CParser.T__21) | (1 << CParser.T__23) | (1 << CParser.T__24) | (1 << CParser.T__25) | (1 << CParser.T__26) | (1 << CParser.T__27) | (1 << CParser.T__28) | (1 << CParser.T__29) | (1 << CParser.T__30) | (1 << CParser.T__31) | (1 << CParser.T__32) | (1 << CParser.T__33) | (1 << CParser.T__34) | (1 << CParser.T__35) | (1 << CParser.T__36))) != 0) or _la==CParser.IDENTIFIER):
                        break

                self.state = 177
                localctx.a = self.compound_statement()
                pass
            elif token in [CParser.T__0]:
                self.state = 179
                localctx.b = self.compound_statement()
                pass
            else:
                raise NoViableAltException(self)


            if localctx.d != None:
                ModifierText = (None if localctx._declaration_specifiers is None else self._input.getText((localctx._declaration_specifiers.start,localctx._declaration_specifiers.stop)))
            else:
                ModifierText = ''
            DeclText = (None if localctx._declarator is None else self._input.getText((localctx._declarator.start,localctx._declarator.stop)))
            DeclLine = (None if localctx._declarator is None else localctx._declarator.start).line
            DeclOffset = (None if localctx._declarator is None else localctx._declarator.start).column
            if localctx.a != None:
                LBLine = (None if localctx.a is None else localctx.a.start).line
                LBOffset = (None if localctx.a is None else localctx.a.start).column
            else:
                LBLine = (None if localctx.b is None else localctx.b.start).line
                LBOffset = (None if localctx.b is None else localctx.b.start).column

            self._ctx.stop = self._input.LT(-1)

            self.StoreFunctionDefinition(localctx.start.line, localctx.start.column, localctx.stop.line, localctx.stop.column, ModifierText, DeclText, LBLine, LBOffset, DeclLine, DeclOffset)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Declaration_specifiersContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def storage_class_specifier(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Storage_class_specifierContext)
            else:
                return self.getTypedRuleContext(CParser.Storage_class_specifierContext,i)


        # @param  i=None Type: int
        def type_specifier(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Type_specifierContext)
            else:
                return self.getTypedRuleContext(CParser.Type_specifierContext,i)


        # @param  i=None Type: int
        def type_qualifier(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Type_qualifierContext)
            else:
                return self.getTypedRuleContext(CParser.Type_qualifierContext,i)


        def getRuleIndex(self):
            return CParser.RULE_declaration_specifiers

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterDeclaration_specifiers" ):
                listener.enterDeclaration_specifiers(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitDeclaration_specifiers" ):
                listener.exitDeclaration_specifiers(self)




    def declaration_specifiers(self):

        localctx = CParser.Declaration_specifiersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_declaration_specifiers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 187
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 187
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [CParser.T__5, CParser.T__6, CParser.T__7, CParser.T__8, CParser.T__9]:
                        self.state = 184
                        self.storage_class_specifier()
                        pass
                    elif token in [CParser.T__10, CParser.T__11, CParser.T__12, CParser.T__13, CParser.T__14, CParser.T__15, CParser.T__16, CParser.T__17, CParser.T__18, CParser.T__20, CParser.T__21, CParser.T__23, CParser.IDENTIFIER]:
                        self.state = 185
                        self.type_specifier()
                        pass
                    elif token in [CParser.T__24, CParser.T__25, CParser.T__26, CParser.T__27, CParser.T__28, CParser.T__29, CParser.T__30, CParser.T__31, CParser.T__32, CParser.T__33, CParser.T__34, CParser.T__35, CParser.T__36]:
                        self.state = 186
                        self.type_qualifier()
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 189
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclarationContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.a = None # Token
            self.b = None # Declaration_specifiersContext
            self.c = None # Init_declarator_listContext
            self.d = None # Token
            self.s = None # Declaration_specifiersContext
            self.t = None # Init_declarator_listContext
            self.e = None # Token

        def init_declarator_list(self):
            return self.getTypedRuleContext(CParser.Init_declarator_listContext,0)


        def declaration_specifiers(self):
            return self.getTypedRuleContext(CParser.Declaration_specifiersContext,0)


        def getRuleIndex(self):
            return CParser.RULE_declaration

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterDeclaration" ):
                listener.enterDeclaration(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitDeclaration" ):
                listener.exitDeclaration(self)




    def declaration(self):

        localctx = CParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_declaration)
        self._la = 0 # Token type
        try:
            self.state = 206
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CParser.T__2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 191
                localctx.a = self.match(CParser.T__2)
                self.state = 193
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
                if la_ == 1:
                    self.state = 192
                    localctx.b = self.declaration_specifiers()


                self.state = 195
                localctx.c = self.init_declarator_list()
                self.state = 196
                localctx.d = self.match(CParser.T__1)

                if localctx.b is not None:
                    self.StoreTypedefDefinition(localctx.a.line, localctx.a.column, (0 if localctx.d is None else localctx.d.line), localctx.d.column, (None if localctx.b is None else self._input.getText((localctx.b.start,localctx.b.stop))), (None if localctx.c is None else self._input.getText((localctx.c.start,localctx.c.stop))))
                else:
                    self.StoreTypedefDefinition(localctx.a.line, localctx.a.column, (0 if localctx.d is None else localctx.d.line), localctx.d.column, '', (None if localctx.c is None else self._input.getText((localctx.c.start,localctx.c.stop))))

                pass
            elif token in [CParser.T__5, CParser.T__6, CParser.T__7, CParser.T__8, CParser.T__9, CParser.T__10, CParser.T__11, CParser.T__12, CParser.T__13, CParser.T__14, CParser.T__15, CParser.T__16, CParser.T__17, CParser.T__18, CParser.T__20, CParser.T__21, CParser.T__23, CParser.T__24, CParser.T__25, CParser.T__26, CParser.T__27, CParser.T__28, CParser.T__29, CParser.T__30, CParser.T__31, CParser.T__32, CParser.T__33, CParser.T__34, CParser.T__35, CParser.T__36, CParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 199
                localctx.s = self.declaration_specifiers()
                self.state = 201
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 34)) & ~0x3f) == 0 and ((1 << (_la - 34)) & ((1 << (CParser.T__33 - 34)) | (1 << (CParser.T__34 - 34)) | (1 << (CParser.T__35 - 34)) | (1 << (CParser.T__37 - 34)) | (1 << (CParser.T__41 - 34)) | (1 << (CParser.IDENTIFIER - 34)))) != 0):
                    self.state = 200
                    localctx.t = self.init_declarator_list()


                self.state = 203
                localctx.e = self.match(CParser.T__1)

                if localctx.t is not None:
                    self.StoreVariableDeclaration((None if localctx.s is None else localctx.s.start).line, (None if localctx.s is None else localctx.s.start).column, (None if localctx.t is None else localctx.t.start).line, (None if localctx.t is None else localctx.t.start).column, (None if localctx.s is None else self._input.getText((localctx.s.start,localctx.s.stop))), (None if localctx.t is None else self._input.getText((localctx.t.start,localctx.t.stop))))

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Init_declarator_listContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def init_declarator(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Init_declaratorContext)
            else:
                return self.getTypedRuleContext(CParser.Init_declaratorContext,i)


        def getRuleIndex(self):
            return CParser.RULE_init_declarator_list

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterInit_declarator_list" ):
                listener.enterInit_declarator_list(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitInit_declarator_list" ):
                listener.exitInit_declarator_list(self)




    def init_declarator_list(self):

        localctx = CParser.Init_declarator_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_init_declarator_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            self.init_declarator()
            self.state = 213
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CParser.T__3:
                self.state = 209
                self.match(CParser.T__3)
                self.state = 210
                self.init_declarator()
                self.state = 215
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Init_declaratorContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declarator(self):
            return self.getTypedRuleContext(CParser.DeclaratorContext,0)


        def initializer(self):
            return self.getTypedRuleContext(CParser.InitializerContext,0)


        def getRuleIndex(self):
            return CParser.RULE_init_declarator

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterInit_declarator" ):
                listener.enterInit_declarator(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitInit_declarator" ):
                listener.exitInit_declarator(self)




    def init_declarator(self):

        localctx = CParser.Init_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_init_declarator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 216
            self.declarator()
            self.state = 219
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CParser.T__4:
                self.state = 217
                self.match(CParser.T__4)
                self.state = 218
                self.initializer()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Storage_class_specifierContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CParser.RULE_storage_class_specifier

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterStorage_class_specifier" ):
                listener.enterStorage_class_specifier(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitStorage_class_specifier" ):
                listener.exitStorage_class_specifier(self)




    def storage_class_specifier(self):

        localctx = CParser.Storage_class_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_storage_class_specifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 221
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_specifierContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.s = None # Struct_or_union_specifierContext
            self.e = None # Enum_specifierContext

        def struct_or_union_specifier(self):
            return self.getTypedRuleContext(CParser.Struct_or_union_specifierContext,0)


        def enum_specifier(self):
            return self.getTypedRuleContext(CParser.Enum_specifierContext,0)


        def IDENTIFIER(self):
            return self.getToken(CParser.IDENTIFIER, 0)

        def declarator(self):
            return self.getTypedRuleContext(CParser.DeclaratorContext,0)


        # @param  i=None Type: int
        def type_qualifier(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Type_qualifierContext)
            else:
                return self.getTypedRuleContext(CParser.Type_qualifierContext,i)


        def type_id(self):
            return self.getTypedRuleContext(CParser.Type_idContext,0)


        def getRuleIndex(self):
            return CParser.RULE_type_specifier

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterType_specifier" ):
                listener.enterType_specifier(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitType_specifier" ):
                listener.exitType_specifier(self)




    def type_specifier(self):

        localctx = CParser.Type_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_type_specifier)
        try:
            self.state = 247
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 223
                self.match(CParser.T__10)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 224
                self.match(CParser.T__11)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 225
                self.match(CParser.T__12)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 226
                self.match(CParser.T__13)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 227
                self.match(CParser.T__14)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 228
                self.match(CParser.T__15)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 229
                self.match(CParser.T__16)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 230
                self.match(CParser.T__17)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 231
                self.match(CParser.T__18)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 232
                localctx.s = self.struct_or_union_specifier()

                if localctx.s.stop is not None:
                    self.StoreStructUnionDefinition((None if localctx.s is None else localctx.s.start).line, (None if localctx.s is None else localctx.s.start).column, (None if localctx.s is None else localctx.s.stop).line, (None if localctx.s is None else localctx.s.stop).column, (None if localctx.s is None else self._input.getText((localctx.s.start,localctx.s.stop))))

                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 235
                localctx.e = self.enum_specifier()

                if localctx.e.stop is not None:
                    self.StoreEnumerationDefinition((None if localctx.e is None else localctx.e.start).line, (None if localctx.e is None else localctx.e.start).column, (None if localctx.e is None else localctx.e.stop).line, (None if localctx.e is None else localctx.e.stop).column, (None if localctx.e is None else self._input.getText((localctx.e.start,localctx.e.stop))))

                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 238
                self.match(CParser.IDENTIFIER)
                self.state = 242
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 239
                        self.type_qualifier()
                    self.state = 244
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,15,self._ctx)

                self.state = 245
                self.declarator()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 246
                self.type_id()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_idContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(CParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return CParser.RULE_type_id

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterType_id" ):
                listener.enterType_id(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitType_id" ):
                listener.exitType_id(self)




    def type_id(self):

        localctx = CParser.Type_idContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_type_id)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            self.match(CParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Struct_or_union_specifierContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def struct_or_union(self):
            return self.getTypedRuleContext(CParser.Struct_or_unionContext,0)


        def struct_declaration_list(self):
            return self.getTypedRuleContext(CParser.Struct_declaration_listContext,0)


        def IDENTIFIER(self):
            return self.getToken(CParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return CParser.RULE_struct_or_union_specifier

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterStruct_or_union_specifier" ):
                listener.enterStruct_or_union_specifier(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitStruct_or_union_specifier" ):
                listener.exitStruct_or_union_specifier(self)




    def struct_or_union_specifier(self):

        localctx = CParser.Struct_or_union_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_struct_or_union_specifier)
        self._la = 0 # Token type
        try:
            self.state = 262
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 251
                self.struct_or_union()
                self.state = 253
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CParser.IDENTIFIER:
                    self.state = 252
                    self.match(CParser.IDENTIFIER)


                self.state = 255
                self.match(CParser.T__0)
                self.state = 256
                self.struct_declaration_list()
                self.state = 257
                self.match(CParser.T__19)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 259
                self.struct_or_union()
                self.state = 260
                self.match(CParser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Struct_or_unionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CParser.RULE_struct_or_union

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterStruct_or_union" ):
                listener.enterStruct_or_union(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitStruct_or_union" ):
                listener.exitStruct_or_union(self)




    def struct_or_union(self):

        localctx = CParser.Struct_or_unionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_struct_or_union)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            _la = self._input.LA(1)
            if not(_la==CParser.T__20 or _la==CParser.T__21):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Struct_declaration_listContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def struct_declaration(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Struct_declarationContext)
            else:
                return self.getTypedRuleContext(CParser.Struct_declarationContext,i)


        def getRuleIndex(self):
            return CParser.RULE_struct_declaration_list

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterStruct_declaration_list" ):
                listener.enterStruct_declaration_list(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitStruct_declaration_list" ):
                listener.exitStruct_declaration_list(self)




    def struct_declaration_list(self):

        localctx = CParser.Struct_declaration_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_struct_declaration_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 267
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 266
                self.struct_declaration()
                self.state = 269
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CParser.T__10) | (1 << CParser.T__11) | (1 << CParser.T__12) | (1 << CParser.T__13) | (1 << CParser.T__14) | (1 << CParser.T__15) | (1 << CParser.T__16) | (1 << CParser.T__17) | (1 << CParser.T__18) | (1 << CParser.T__20) | (1 << CParser.T__21) | (1 << CParser.T__23) | (1 << CParser.T__24) | (1 << CParser.T__25) | (1 << CParser.T__26) | (1 << CParser.T__27) | (1 << CParser.T__28) | (1 << CParser.T__29) | (1 << CParser.T__30) | (1 << CParser.T__31) | (1 << CParser.T__32) | (1 << CParser.T__33) | (1 << CParser.T__34) | (1 << CParser.T__35) | (1 << CParser.T__36))) != 0) or _la==CParser.IDENTIFIER):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Struct_declarationContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def specifier_qualifier_list(self):
            return self.getTypedRuleContext(CParser.Specifier_qualifier_listContext,0)


        def struct_declarator_list(self):
            return self.getTypedRuleContext(CParser.Struct_declarator_listContext,0)


        def getRuleIndex(self):
            return CParser.RULE_struct_declaration

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterStruct_declaration" ):
                listener.enterStruct_declaration(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitStruct_declaration" ):
                listener.exitStruct_declaration(self)




    def struct_declaration(self):

        localctx = CParser.Struct_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_struct_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 271
            self.specifier_qualifier_list()
            self.state = 272
            self.struct_declarator_list()
            self.state = 273
            self.match(CParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Specifier_qualifier_listContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def type_qualifier(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Type_qualifierContext)
            else:
                return self.getTypedRuleContext(CParser.Type_qualifierContext,i)


        # @param  i=None Type: int
        def type_specifier(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Type_specifierContext)
            else:
                return self.getTypedRuleContext(CParser.Type_specifierContext,i)


        def getRuleIndex(self):
            return CParser.RULE_specifier_qualifier_list

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterSpecifier_qualifier_list" ):
                listener.enterSpecifier_qualifier_list(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitSpecifier_qualifier_list" ):
                listener.exitSpecifier_qualifier_list(self)




    def specifier_qualifier_list(self):

        localctx = CParser.Specifier_qualifier_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_specifier_qualifier_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 277
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 277
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [CParser.T__24, CParser.T__25, CParser.T__26, CParser.T__27, CParser.T__28, CParser.T__29, CParser.T__30, CParser.T__31, CParser.T__32, CParser.T__33, CParser.T__34, CParser.T__35, CParser.T__36]:
                        self.state = 275
                        self.type_qualifier()
                        pass
                    elif token in [CParser.T__10, CParser.T__11, CParser.T__12, CParser.T__13, CParser.T__14, CParser.T__15, CParser.T__16, CParser.T__17, CParser.T__18, CParser.T__20, CParser.T__21, CParser.T__23, CParser.IDENTIFIER]:
                        self.state = 276
                        self.type_specifier()
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 279
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,21,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Struct_declarator_listContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def struct_declarator(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Struct_declaratorContext)
            else:
                return self.getTypedRuleContext(CParser.Struct_declaratorContext,i)


        def getRuleIndex(self):
            return CParser.RULE_struct_declarator_list

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterStruct_declarator_list" ):
                listener.enterStruct_declarator_list(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitStruct_declarator_list" ):
                listener.exitStruct_declarator_list(self)




    def struct_declarator_list(self):

        localctx = CParser.Struct_declarator_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_struct_declarator_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 281
            self.struct_declarator()
            self.state = 286
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CParser.T__3:
                self.state = 282
                self.match(CParser.T__3)
                self.state = 283
                self.struct_declarator()
                self.state = 288
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Struct_declaratorContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declarator(self):
            return self.getTypedRuleContext(CParser.DeclaratorContext,0)


        def constant_expression(self):
            return self.getTypedRuleContext(CParser.Constant_expressionContext,0)


        def getRuleIndex(self):
            return CParser.RULE_struct_declarator

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterStruct_declarator" ):
                listener.enterStruct_declarator(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitStruct_declarator" ):
                listener.exitStruct_declarator(self)




    def struct_declarator(self):

        localctx = CParser.Struct_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_struct_declarator)
        self._la = 0 # Token type
        try:
            self.state = 296
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CParser.T__33, CParser.T__34, CParser.T__35, CParser.T__37, CParser.T__41, CParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 289
                self.declarator()
                self.state = 292
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CParser.T__22:
                    self.state = 290
                    self.match(CParser.T__22)
                    self.state = 291
                    self.constant_expression()


                pass
            elif token in [CParser.T__22]:
                self.enterOuterAlt(localctx, 2)
                self.state = 294
                self.match(CParser.T__22)
                self.state = 295
                self.constant_expression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Enum_specifierContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumerator_list(self):
            return self.getTypedRuleContext(CParser.Enumerator_listContext,0)


        def IDENTIFIER(self):
            return self.getToken(CParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return CParser.RULE_enum_specifier

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterEnum_specifier" ):
                listener.enterEnum_specifier(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitEnum_specifier" ):
                listener.exitEnum_specifier(self)




    def enum_specifier(self):

        localctx = CParser.Enum_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_enum_specifier)
        self._la = 0 # Token type
        try:
            self.state = 317
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 298
                self.match(CParser.T__23)
                self.state = 299
                self.match(CParser.T__0)
                self.state = 300
                self.enumerator_list()
                self.state = 302
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CParser.T__3:
                    self.state = 301
                    self.match(CParser.T__3)


                self.state = 304
                self.match(CParser.T__19)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 306
                self.match(CParser.T__23)
                self.state = 307
                self.match(CParser.IDENTIFIER)
                self.state = 308
                self.match(CParser.T__0)
                self.state = 309
                self.enumerator_list()
                self.state = 311
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CParser.T__3:
                    self.state = 310
                    self.match(CParser.T__3)


                self.state = 313
                self.match(CParser.T__19)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 315
                self.match(CParser.T__23)
                self.state = 316
                self.match(CParser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Enumerator_listContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def enumerator(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.EnumeratorContext)
            else:
                return self.getTypedRuleContext(CParser.EnumeratorContext,i)


        def getRuleIndex(self):
            return CParser.RULE_enumerator_list

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterEnumerator_list" ):
                listener.enterEnumerator_list(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitEnumerator_list" ):
                listener.exitEnumerator_list(self)




    def enumerator_list(self):

        localctx = CParser.Enumerator_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_enumerator_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 319
            self.enumerator()
            self.state = 324
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,28,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 320
                    self.match(CParser.T__3)
                    self.state = 321
                    self.enumerator()
                self.state = 326
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,28,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EnumeratorContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(CParser.IDENTIFIER, 0)

        def constant_expression(self):
            return self.getTypedRuleContext(CParser.Constant_expressionContext,0)


        def getRuleIndex(self):
            return CParser.RULE_enumerator

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterEnumerator" ):
                listener.enterEnumerator(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitEnumerator" ):
                listener.exitEnumerator(self)




    def enumerator(self):

        localctx = CParser.EnumeratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_enumerator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 327
            self.match(CParser.IDENTIFIER)
            self.state = 330
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CParser.T__4:
                self.state = 328
                self.match(CParser.T__4)
                self.state = 329
                self.constant_expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_qualifierContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CParser.RULE_type_qualifier

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterType_qualifier" ):
                listener.enterType_qualifier(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitType_qualifier" ):
                listener.exitType_qualifier(self)




    def type_qualifier(self):

        localctx = CParser.Type_qualifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_type_qualifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 332
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CParser.T__24) | (1 << CParser.T__25) | (1 << CParser.T__26) | (1 << CParser.T__27) | (1 << CParser.T__28) | (1 << CParser.T__29) | (1 << CParser.T__30) | (1 << CParser.T__31) | (1 << CParser.T__32) | (1 << CParser.T__33) | (1 << CParser.T__34) | (1 << CParser.T__35) | (1 << CParser.T__36))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclaratorContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def direct_declarator(self):
            return self.getTypedRuleContext(CParser.Direct_declaratorContext,0)


        def pointer(self):
            return self.getTypedRuleContext(CParser.PointerContext,0)


        def getRuleIndex(self):
            return CParser.RULE_declarator

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterDeclarator" ):
                listener.enterDeclarator(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitDeclarator" ):
                listener.exitDeclarator(self)




    def declarator(self):

        localctx = CParser.DeclaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_declarator)
        self._la = 0 # Token type
        try:
            self.state = 348
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 335
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CParser.T__41:
                    self.state = 334
                    self.pointer()


                self.state = 338
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CParser.T__33:
                    self.state = 337
                    self.match(CParser.T__33)


                self.state = 341
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CParser.T__34:
                    self.state = 340
                    self.match(CParser.T__34)


                self.state = 344
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CParser.T__35:
                    self.state = 343
                    self.match(CParser.T__35)


                self.state = 346
                self.direct_declarator()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 347
                self.pointer()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Direct_declaratorContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(CParser.IDENTIFIER, 0)

        # @param  i=None Type: int
        def declarator_suffix(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Declarator_suffixContext)
            else:
                return self.getTypedRuleContext(CParser.Declarator_suffixContext,i)


        def declarator(self):
            return self.getTypedRuleContext(CParser.DeclaratorContext,0)


        def getRuleIndex(self):
            return CParser.RULE_direct_declarator

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterDirect_declarator" ):
                listener.enterDirect_declarator(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitDirect_declarator" ):
                listener.exitDirect_declarator(self)




    def direct_declarator(self):

        localctx = CParser.Direct_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_direct_declarator)
        try:
            self.state = 368
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 350
                self.match(CParser.IDENTIFIER)
                self.state = 354
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,35,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 351
                        self.declarator_suffix()
                    self.state = 356
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,35,self._ctx)

                pass
            elif token in [CParser.T__37]:
                self.enterOuterAlt(localctx, 2)
                self.state = 357
                self.match(CParser.T__37)
                self.state = 359
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
                if la_ == 1:
                    self.state = 358
                    self.match(CParser.T__33)


                self.state = 361
                self.declarator()
                self.state = 362
                self.match(CParser.T__38)
                self.state = 364
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 363
                        self.declarator_suffix()

                    else:
                        raise NoViableAltException(self)
                    self.state = 366
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,37,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Declarator_suffixContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant_expression(self):
            return self.getTypedRuleContext(CParser.Constant_expressionContext,0)


        def parameter_type_list(self):
            return self.getTypedRuleContext(CParser.Parameter_type_listContext,0)


        def identifier_list(self):
            return self.getTypedRuleContext(CParser.Identifier_listContext,0)


        def getRuleIndex(self):
            return CParser.RULE_declarator_suffix

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterDeclarator_suffix" ):
                listener.enterDeclarator_suffix(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitDeclarator_suffix" ):
                listener.exitDeclarator_suffix(self)




    def declarator_suffix(self):

        localctx = CParser.Declarator_suffixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_declarator_suffix)
        try:
            self.state = 386
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 370
                self.match(CParser.T__39)
                self.state = 371
                self.constant_expression()
                self.state = 372
                self.match(CParser.T__40)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 374
                self.match(CParser.T__39)
                self.state = 375
                self.match(CParser.T__40)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 376
                self.match(CParser.T__37)
                self.state = 377
                self.parameter_type_list()
                self.state = 378
                self.match(CParser.T__38)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 380
                self.match(CParser.T__37)
                self.state = 381
                self.identifier_list()
                self.state = 382
                self.match(CParser.T__38)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 384
                self.match(CParser.T__37)
                self.state = 385
                self.match(CParser.T__38)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PointerContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def type_qualifier(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Type_qualifierContext)
            else:
                return self.getTypedRuleContext(CParser.Type_qualifierContext,i)


        def pointer(self):
            return self.getTypedRuleContext(CParser.PointerContext,0)


        def getRuleIndex(self):
            return CParser.RULE_pointer

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterPointer" ):
                listener.enterPointer(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitPointer" ):
                listener.exitPointer(self)




    def pointer(self):

        localctx = CParser.PointerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_pointer)
        try:
            self.state = 400
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 388
                self.match(CParser.T__41)
                self.state = 390
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 389
                        self.type_qualifier()

                    else:
                        raise NoViableAltException(self)
                    self.state = 392
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,40,self._ctx)

                self.state = 395
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
                if la_ == 1:
                    self.state = 394
                    self.pointer()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 397
                self.match(CParser.T__41)
                self.state = 398
                self.pointer()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 399
                self.match(CParser.T__41)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_type_listContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameter_list(self):
            return self.getTypedRuleContext(CParser.Parameter_listContext,0)


        def getRuleIndex(self):
            return CParser.RULE_parameter_type_list

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterParameter_type_list" ):
                listener.enterParameter_type_list(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitParameter_type_list" ):
                listener.exitParameter_type_list(self)




    def parameter_type_list(self):

        localctx = CParser.Parameter_type_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_parameter_type_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 402
            self.parameter_list()
            self.state = 408
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CParser.T__3:
                self.state = 403
                self.match(CParser.T__3)
                self.state = 405
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CParser.T__28:
                    self.state = 404
                    self.match(CParser.T__28)


                self.state = 407
                self.match(CParser.T__42)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_listContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def parameter_declaration(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Parameter_declarationContext)
            else:
                return self.getTypedRuleContext(CParser.Parameter_declarationContext,i)


        def getRuleIndex(self):
            return CParser.RULE_parameter_list

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterParameter_list" ):
                listener.enterParameter_list(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitParameter_list" ):
                listener.exitParameter_list(self)




    def parameter_list(self):

        localctx = CParser.Parameter_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_parameter_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 410
            self.parameter_declaration()
            self.state = 418
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,46,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 411
                    self.match(CParser.T__3)
                    self.state = 413
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
                    if la_ == 1:
                        self.state = 412
                        self.match(CParser.T__28)


                    self.state = 415
                    self.parameter_declaration()
                self.state = 420
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,46,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_declarationContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declaration_specifiers(self):
            return self.getTypedRuleContext(CParser.Declaration_specifiersContext,0)


        # @param  i=None Type: int
        def declarator(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.DeclaratorContext)
            else:
                return self.getTypedRuleContext(CParser.DeclaratorContext,i)


        # @param  i=None Type: int
        def abstract_declarator(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Abstract_declaratorContext)
            else:
                return self.getTypedRuleContext(CParser.Abstract_declaratorContext,i)


        def IDENTIFIER(self):
            return self.getToken(CParser.IDENTIFIER, 0)

        # @param  i=None Type: int
        def pointer(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.PointerContext)
            else:
                return self.getTypedRuleContext(CParser.PointerContext,i)


        def getRuleIndex(self):
            return CParser.RULE_parameter_declaration

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterParameter_declaration" ):
                listener.enterParameter_declaration(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitParameter_declaration" ):
                listener.exitParameter_declaration(self)




    def parameter_declaration(self):

        localctx = CParser.Parameter_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_parameter_declaration)
        self._la = 0 # Token type
        try:
            self.state = 439
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 421
                self.declaration_specifiers()
                self.state = 426
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 34)) & ~0x3f) == 0 and ((1 << (_la - 34)) & ((1 << (CParser.T__33 - 34)) | (1 << (CParser.T__34 - 34)) | (1 << (CParser.T__35 - 34)) | (1 << (CParser.T__37 - 34)) | (1 << (CParser.T__39 - 34)) | (1 << (CParser.T__41 - 34)) | (1 << (CParser.IDENTIFIER - 34)))) != 0):
                    self.state = 424
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
                    if la_ == 1:
                        self.state = 422
                        self.declarator()
                        pass

                    elif la_ == 2:
                        self.state = 423
                        self.abstract_declarator()
                        pass


                    self.state = 428
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 430
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CParser.T__28:
                    self.state = 429
                    self.match(CParser.T__28)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 435
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CParser.T__41:
                    self.state = 432
                    self.pointer()
                    self.state = 437
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 438
                self.match(CParser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Identifier_listContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def IDENTIFIER(self,i=None):
            if i is None:
                return self.getTokens(CParser.IDENTIFIER)
            else:
                return self.getToken(CParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return CParser.RULE_identifier_list

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterIdentifier_list" ):
                listener.enterIdentifier_list(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitIdentifier_list" ):
                listener.exitIdentifier_list(self)




    def identifier_list(self):

        localctx = CParser.Identifier_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_identifier_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 441
            self.match(CParser.IDENTIFIER)
            self.state = 446
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CParser.T__3:
                self.state = 442
                self.match(CParser.T__3)
                self.state = 443
                self.match(CParser.IDENTIFIER)
                self.state = 448
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_nameContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def specifier_qualifier_list(self):
            return self.getTypedRuleContext(CParser.Specifier_qualifier_listContext,0)


        def abstract_declarator(self):
            return self.getTypedRuleContext(CParser.Abstract_declaratorContext,0)


        def type_id(self):
            return self.getTypedRuleContext(CParser.Type_idContext,0)


        def getRuleIndex(self):
            return CParser.RULE_type_name

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterType_name" ):
                listener.enterType_name(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitType_name" ):
                listener.exitType_name(self)




    def type_name(self):

        localctx = CParser.Type_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_type_name)
        self._la = 0 # Token type
        try:
            self.state = 454
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 449
                self.specifier_qualifier_list()
                self.state = 451
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CParser.T__37) | (1 << CParser.T__39) | (1 << CParser.T__41))) != 0):
                    self.state = 450
                    self.abstract_declarator()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 453
                self.type_id()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Abstract_declaratorContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pointer(self):
            return self.getTypedRuleContext(CParser.PointerContext,0)


        def direct_abstract_declarator(self):
            return self.getTypedRuleContext(CParser.Direct_abstract_declaratorContext,0)


        def getRuleIndex(self):
            return CParser.RULE_abstract_declarator

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterAbstract_declarator" ):
                listener.enterAbstract_declarator(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitAbstract_declarator" ):
                listener.exitAbstract_declarator(self)




    def abstract_declarator(self):

        localctx = CParser.Abstract_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_abstract_declarator)
        try:
            self.state = 461
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CParser.T__41]:
                self.enterOuterAlt(localctx, 1)
                self.state = 456
                self.pointer()
                self.state = 458
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
                if la_ == 1:
                    self.state = 457
                    self.direct_abstract_declarator()


                pass
            elif token in [CParser.T__37, CParser.T__39]:
                self.enterOuterAlt(localctx, 2)
                self.state = 460
                self.direct_abstract_declarator()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Direct_abstract_declaratorContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def abstract_declarator(self):
            return self.getTypedRuleContext(CParser.Abstract_declaratorContext,0)


        # @param  i=None Type: int
        def abstract_declarator_suffix(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Abstract_declarator_suffixContext)
            else:
                return self.getTypedRuleContext(CParser.Abstract_declarator_suffixContext,i)


        def getRuleIndex(self):
            return CParser.RULE_direct_abstract_declarator

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterDirect_abstract_declarator" ):
                listener.enterDirect_abstract_declarator(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitDirect_abstract_declarator" ):
                listener.exitDirect_abstract_declarator(self)



    def direct_abstract_declarator(self):

        localctx = CParser.Direct_abstract_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_direct_abstract_declarator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 468
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
            if la_ == 1:
                self.state = 463
                self.match(CParser.T__37)
                self.state = 464
                self.abstract_declarator()
                self.state = 465
                self.match(CParser.T__38)
                pass

            elif la_ == 2:
                self.state = 467
                self.abstract_declarator_suffix()
                pass


            self.state = 473
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,58,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 470
                    self.abstract_declarator_suffix()
                self.state = 475
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,58,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Abstract_declarator_suffixContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant_expression(self):
            return self.getTypedRuleContext(CParser.Constant_expressionContext,0)


        def parameter_type_list(self):
            return self.getTypedRuleContext(CParser.Parameter_type_listContext,0)


        def getRuleIndex(self):
            return CParser.RULE_abstract_declarator_suffix

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterAbstract_declarator_suffix" ):
                listener.enterAbstract_declarator_suffix(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitAbstract_declarator_suffix" ):
                listener.exitAbstract_declarator_suffix(self)




    def abstract_declarator_suffix(self):

        localctx = CParser.Abstract_declarator_suffixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_abstract_declarator_suffix)
        try:
            self.state = 488
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 476
                self.match(CParser.T__39)
                self.state = 477
                self.match(CParser.T__40)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 478
                self.match(CParser.T__39)
                self.state = 479
                self.constant_expression()
                self.state = 480
                self.match(CParser.T__40)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 482
                self.match(CParser.T__37)
                self.state = 483
                self.match(CParser.T__38)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 484
                self.match(CParser.T__37)
                self.state = 485
                self.parameter_type_list()
                self.state = 486
                self.match(CParser.T__38)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InitializerContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment_expression(self):
            return self.getTypedRuleContext(CParser.Assignment_expressionContext,0)


        def initializer_list(self):
            return self.getTypedRuleContext(CParser.Initializer_listContext,0)


        def getRuleIndex(self):
            return CParser.RULE_initializer

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterInitializer" ):
                listener.enterInitializer(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitInitializer" ):
                listener.exitInitializer(self)




    def initializer(self):

        localctx = CParser.InitializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_initializer)
        self._la = 0 # Token type
        try:
            self.state = 498
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CParser.T__37, CParser.T__41, CParser.T__43, CParser.T__44, CParser.T__47, CParser.T__48, CParser.T__49, CParser.T__52, CParser.T__53, CParser.T__54, CParser.IDENTIFIER, CParser.CHARACTER_LITERAL, CParser.STRING_LITERAL, CParser.HEX_LITERAL, CParser.DECIMAL_LITERAL, CParser.OCTAL_LITERAL, CParser.FLOATING_POINT_LITERAL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 490
                self.assignment_expression()
                pass
            elif token in [CParser.T__0]:
                self.enterOuterAlt(localctx, 2)
                self.state = 491
                self.match(CParser.T__0)
                self.state = 492
                self.initializer_list()
                self.state = 494
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CParser.T__3:
                    self.state = 493
                    self.match(CParser.T__3)


                self.state = 496
                self.match(CParser.T__19)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Initializer_listContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def initializer(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.InitializerContext)
            else:
                return self.getTypedRuleContext(CParser.InitializerContext,i)


        def getRuleIndex(self):
            return CParser.RULE_initializer_list

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterInitializer_list" ):
                listener.enterInitializer_list(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitInitializer_list" ):
                listener.exitInitializer_list(self)




    def initializer_list(self):

        localctx = CParser.Initializer_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_initializer_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 500
            self.initializer()
            self.state = 505
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,62,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 501
                    self.match(CParser.T__3)
                    self.state = 502
                    self.initializer()
                self.state = 507
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,62,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Argument_expression_listContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def assignment_expression(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Assignment_expressionContext)
            else:
                return self.getTypedRuleContext(CParser.Assignment_expressionContext,i)


        def getRuleIndex(self):
            return CParser.RULE_argument_expression_list

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterArgument_expression_list" ):
                listener.enterArgument_expression_list(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitArgument_expression_list" ):
                listener.exitArgument_expression_list(self)




    def argument_expression_list(self):

        localctx = CParser.Argument_expression_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_argument_expression_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 508
            self.assignment_expression()
            self.state = 510
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CParser.T__28:
                self.state = 509
                self.match(CParser.T__28)


            self.state = 519
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CParser.T__3:
                self.state = 512
                self.match(CParser.T__3)
                self.state = 513
                self.assignment_expression()
                self.state = 515
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CParser.T__28:
                    self.state = 514
                    self.match(CParser.T__28)


                self.state = 521
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Additive_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def multiplicative_expression(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Multiplicative_expressionContext)
            else:
                return self.getTypedRuleContext(CParser.Multiplicative_expressionContext,i)


        def getRuleIndex(self):
            return CParser.RULE_additive_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterAdditive_expression" ):
                listener.enterAdditive_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitAdditive_expression" ):
                listener.exitAdditive_expression(self)




    def additive_expression(self):

        localctx = CParser.Additive_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_additive_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 522
            self.multiplicative_expression()
            self.state = 529
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CParser.T__43 or _la==CParser.T__44:
                self.state = 527
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [CParser.T__43]:
                    self.state = 523
                    self.match(CParser.T__43)
                    self.state = 524
                    self.multiplicative_expression()
                    pass
                elif token in [CParser.T__44]:
                    self.state = 525
                    self.match(CParser.T__44)
                    self.state = 526
                    self.multiplicative_expression()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 531
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multiplicative_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def cast_expression(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Cast_expressionContext)
            else:
                return self.getTypedRuleContext(CParser.Cast_expressionContext,i)


        def getRuleIndex(self):
            return CParser.RULE_multiplicative_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterMultiplicative_expression" ):
                listener.enterMultiplicative_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitMultiplicative_expression" ):
                listener.exitMultiplicative_expression(self)




    def multiplicative_expression(self):

        localctx = CParser.Multiplicative_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_multiplicative_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 532
            self.cast_expression()
            self.state = 541
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CParser.T__41) | (1 << CParser.T__45) | (1 << CParser.T__46))) != 0):
                self.state = 539
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [CParser.T__41]:
                    self.state = 533
                    self.match(CParser.T__41)
                    self.state = 534
                    self.cast_expression()
                    pass
                elif token in [CParser.T__45]:
                    self.state = 535
                    self.match(CParser.T__45)
                    self.state = 536
                    self.cast_expression()
                    pass
                elif token in [CParser.T__46]:
                    self.state = 537
                    self.match(CParser.T__46)
                    self.state = 538
                    self.cast_expression()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 543
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Cast_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_name(self):
            return self.getTypedRuleContext(CParser.Type_nameContext,0)


        def cast_expression(self):
            return self.getTypedRuleContext(CParser.Cast_expressionContext,0)


        def unary_expression(self):
            return self.getTypedRuleContext(CParser.Unary_expressionContext,0)


        def getRuleIndex(self):
            return CParser.RULE_cast_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterCast_expression" ):
                listener.enterCast_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitCast_expression" ):
                listener.exitCast_expression(self)




    def cast_expression(self):

        localctx = CParser.Cast_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_cast_expression)
        try:
            self.state = 550
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 544
                self.match(CParser.T__37)
                self.state = 545
                self.type_name()
                self.state = 546
                self.match(CParser.T__38)
                self.state = 547
                self.cast_expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 549
                self.unary_expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Unary_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def postfix_expression(self):
            return self.getTypedRuleContext(CParser.Postfix_expressionContext,0)


        def unary_expression(self):
            return self.getTypedRuleContext(CParser.Unary_expressionContext,0)


        def unary_operator(self):
            return self.getTypedRuleContext(CParser.Unary_operatorContext,0)


        def cast_expression(self):
            return self.getTypedRuleContext(CParser.Cast_expressionContext,0)


        def type_name(self):
            return self.getTypedRuleContext(CParser.Type_nameContext,0)


        def getRuleIndex(self):
            return CParser.RULE_unary_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterUnary_expression" ):
                listener.enterUnary_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitUnary_expression" ):
                listener.exitUnary_expression(self)




    def unary_expression(self):

        localctx = CParser.Unary_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_unary_expression)
        try:
            self.state = 567
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 552
                self.postfix_expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 553
                self.match(CParser.T__47)
                self.state = 554
                self.unary_expression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 555
                self.match(CParser.T__48)
                self.state = 556
                self.unary_expression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 557
                self.unary_operator()
                self.state = 558
                self.cast_expression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 560
                self.match(CParser.T__49)
                self.state = 561
                self.unary_expression()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 562
                self.match(CParser.T__49)
                self.state = 563
                self.match(CParser.T__37)
                self.state = 564
                self.type_name()
                self.state = 565
                self.match(CParser.T__38)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Postfix_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.FuncCallText = ''
            self.p = None # Primary_expressionContext
            self.a = None # Token
            self.c = None # Argument_expression_listContext
            self.b = None # Token
            self.x = None # Token
            self.y = None # Token
            self.z = None # Token

        def primary_expression(self):
            return self.getTypedRuleContext(CParser.Primary_expressionContext,0)


        # @param  i=None Type: int
        def expression(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CParser.ExpressionContext,i)


        # @param  i=None Type: int
        def macro_parameter_list(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Macro_parameter_listContext)
            else:
                return self.getTypedRuleContext(CParser.Macro_parameter_listContext,i)


        # @param  i=None Type: int
        def argument_expression_list(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Argument_expression_listContext)
            else:
                return self.getTypedRuleContext(CParser.Argument_expression_listContext,i)


        # @param  i=None Type: int
        def IDENTIFIER(self,i=None):
            if i is None:
                return self.getTokens(CParser.IDENTIFIER)
            else:
                return self.getToken(CParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return CParser.RULE_postfix_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterPostfix_expression" ):
                listener.enterPostfix_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitPostfix_expression" ):
                listener.exitPostfix_expression(self)




    def postfix_expression(self):

        localctx = CParser.Postfix_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_postfix_expression)

        self.FuncCallText=''

        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 569
            localctx.p = self.primary_expression()
            self.FuncCallText += (None if localctx.p is None else self._input.getText((localctx.p.start,localctx.p.stop)))
            self.state = 600
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,73,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 598
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
                    if la_ == 1:
                        self.state = 571
                        self.match(CParser.T__39)
                        self.state = 572
                        self.expression()
                        self.state = 573
                        self.match(CParser.T__40)
                        pass

                    elif la_ == 2:
                        self.state = 575
                        self.match(CParser.T__37)
                        self.state = 576
                        localctx.a = self.match(CParser.T__38)
                        self.StoreFunctionCalling((None if localctx.p is None else localctx.p.start).line, (None if localctx.p is None else localctx.p.start).column, (0 if localctx.a is None else localctx.a.line), localctx.a.column, self.FuncCallText, '')
                        pass

                    elif la_ == 3:
                        self.state = 578
                        self.match(CParser.T__37)
                        self.state = 579
                        localctx.c = self.argument_expression_list()
                        self.state = 580
                        localctx.b = self.match(CParser.T__38)
                        self.StoreFunctionCalling((None if localctx.p is None else localctx.p.start).line, (None if localctx.p is None else localctx.p.start).column, (0 if localctx.b is None else localctx.b.line), localctx.b.column, self.FuncCallText, (None if localctx.c is None else self._input.getText((localctx.c.start,localctx.c.stop))))
                        pass

                    elif la_ == 4:
                        self.state = 583
                        self.match(CParser.T__37)
                        self.state = 584
                        self.macro_parameter_list()
                        self.state = 585
                        self.match(CParser.T__38)
                        pass

                    elif la_ == 5:
                        self.state = 587
                        self.match(CParser.T__50)
                        self.state = 588
                        localctx.x = self.match(CParser.IDENTIFIER)
                        self.FuncCallText += '.' + (None if localctx.x is None else localctx.x.text)
                        pass

                    elif la_ == 6:
                        self.state = 590
                        self.match(CParser.T__41)
                        self.state = 591
                        localctx.y = self.match(CParser.IDENTIFIER)
                        self.FuncCallText = (None if localctx.y is None else localctx.y.text)
                        pass

                    elif la_ == 7:
                        self.state = 593
                        self.match(CParser.T__51)
                        self.state = 594
                        localctx.z = self.match(CParser.IDENTIFIER)
                        self.FuncCallText += '->' + (None if localctx.z is None else localctx.z.text)
                        pass

                    elif la_ == 8:
                        self.state = 596
                        self.match(CParser.T__47)
                        pass

                    elif la_ == 9:
                        self.state = 597
                        self.match(CParser.T__48)
                        pass


                self.state = 602
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,73,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Macro_parameter_listContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def parameter_declaration(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Parameter_declarationContext)
            else:
                return self.getTypedRuleContext(CParser.Parameter_declarationContext,i)


        def getRuleIndex(self):
            return CParser.RULE_macro_parameter_list

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterMacro_parameter_list" ):
                listener.enterMacro_parameter_list(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitMacro_parameter_list" ):
                listener.exitMacro_parameter_list(self)




    def macro_parameter_list(self):

        localctx = CParser.Macro_parameter_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_macro_parameter_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 603
            self.parameter_declaration()
            self.state = 608
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CParser.T__3:
                self.state = 604
                self.match(CParser.T__3)
                self.state = 605
                self.parameter_declaration()
                self.state = 610
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Unary_operatorContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CParser.RULE_unary_operator

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterUnary_operator" ):
                listener.enterUnary_operator(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitUnary_operator" ):
                listener.exitUnary_operator(self)




    def unary_operator(self):

        localctx = CParser.Unary_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_unary_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 611
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CParser.T__41) | (1 << CParser.T__43) | (1 << CParser.T__44) | (1 << CParser.T__52) | (1 << CParser.T__53) | (1 << CParser.T__54))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Primary_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(CParser.IDENTIFIER, 0)

        def constant(self):
            return self.getTypedRuleContext(CParser.ConstantContext,0)


        def expression(self):
            return self.getTypedRuleContext(CParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CParser.RULE_primary_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterPrimary_expression" ):
                listener.enterPrimary_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitPrimary_expression" ):
                listener.exitPrimary_expression(self)




    def primary_expression(self):

        localctx = CParser.Primary_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_primary_expression)
        try:
            self.state = 619
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 613
                self.match(CParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 614
                self.constant()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 615
                self.match(CParser.T__37)
                self.state = 616
                self.expression()
                self.state = 617
                self.match(CParser.T__38)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HEX_LITERAL(self):
            return self.getToken(CParser.HEX_LITERAL, 0)

        def OCTAL_LITERAL(self):
            return self.getToken(CParser.OCTAL_LITERAL, 0)

        def DECIMAL_LITERAL(self):
            return self.getToken(CParser.DECIMAL_LITERAL, 0)

        def CHARACTER_LITERAL(self):
            return self.getToken(CParser.CHARACTER_LITERAL, 0)

        # @param  i=None Type: int
        def IDENTIFIER(self,i=None):
            if i is None:
                return self.getTokens(CParser.IDENTIFIER)
            else:
                return self.getToken(CParser.IDENTIFIER, i)

        # @param  i=None Type: int
        def STRING_LITERAL(self,i=None):
            if i is None:
                return self.getTokens(CParser.STRING_LITERAL)
            else:
                return self.getToken(CParser.STRING_LITERAL, i)

        def FLOATING_POINT_LITERAL(self):
            return self.getToken(CParser.FLOATING_POINT_LITERAL, 0)

        def getRuleIndex(self):
            return CParser.RULE_constant

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)




    def constant(self):

        localctx = CParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_constant)
        self._la = 0 # Token type
        try:
            self.state = 647
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CParser.HEX_LITERAL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 621
                self.match(CParser.HEX_LITERAL)
                pass
            elif token in [CParser.OCTAL_LITERAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 622
                self.match(CParser.OCTAL_LITERAL)
                pass
            elif token in [CParser.DECIMAL_LITERAL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 623
                self.match(CParser.DECIMAL_LITERAL)
                pass
            elif token in [CParser.CHARACTER_LITERAL]:
                self.enterOuterAlt(localctx, 4)
                self.state = 624
                self.match(CParser.CHARACTER_LITERAL)
                pass
            elif token in [CParser.IDENTIFIER, CParser.STRING_LITERAL]:
                self.enterOuterAlt(localctx, 5)
                self.state = 636
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 628
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==CParser.IDENTIFIER:
                            self.state = 625
                            self.match(CParser.IDENTIFIER)
                            self.state = 630
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        self.state = 632
                        self._errHandler.sync(self)
                        _alt = 1
                        while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                            if _alt == 1:
                                self.state = 631
                                self.match(CParser.STRING_LITERAL)

                            else:
                                raise NoViableAltException(self)
                            self.state = 634
                            self._errHandler.sync(self)
                            _alt = self._interp.adaptivePredict(self._input,77,self._ctx)


                    else:
                        raise NoViableAltException(self)
                    self.state = 638
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,78,self._ctx)

                self.state = 643
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CParser.IDENTIFIER:
                    self.state = 640
                    self.match(CParser.IDENTIFIER)
                    self.state = 645
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [CParser.FLOATING_POINT_LITERAL]:
                self.enterOuterAlt(localctx, 6)
                self.state = 646
                self.match(CParser.FLOATING_POINT_LITERAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def assignment_expression(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Assignment_expressionContext)
            else:
                return self.getTypedRuleContext(CParser.Assignment_expressionContext,i)


        def getRuleIndex(self):
            return CParser.RULE_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)




    def expression(self):

        localctx = CParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 649
            self.assignment_expression()
            self.state = 654
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CParser.T__3:
                self.state = 650
                self.match(CParser.T__3)
                self.state = 651
                self.assignment_expression()
                self.state = 656
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Constant_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditional_expression(self):
            return self.getTypedRuleContext(CParser.Conditional_expressionContext,0)


        def getRuleIndex(self):
            return CParser.RULE_constant_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterConstant_expression" ):
                listener.enterConstant_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitConstant_expression" ):
                listener.exitConstant_expression(self)




    def constant_expression(self):

        localctx = CParser.Constant_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_constant_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 657
            self.conditional_expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Assignment_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lvalue(self):
            return self.getTypedRuleContext(CParser.LvalueContext,0)


        def assignment_operator(self):
            return self.getTypedRuleContext(CParser.Assignment_operatorContext,0)


        def assignment_expression(self):
            return self.getTypedRuleContext(CParser.Assignment_expressionContext,0)


        def conditional_expression(self):
            return self.getTypedRuleContext(CParser.Conditional_expressionContext,0)


        def getRuleIndex(self):
            return CParser.RULE_assignment_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterAssignment_expression" ):
                listener.enterAssignment_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitAssignment_expression" ):
                listener.exitAssignment_expression(self)




    def assignment_expression(self):

        localctx = CParser.Assignment_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_assignment_expression)
        try:
            self.state = 664
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 659
                self.lvalue()
                self.state = 660
                self.assignment_operator()
                self.state = 661
                self.assignment_expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 663
                self.conditional_expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LvalueContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unary_expression(self):
            return self.getTypedRuleContext(CParser.Unary_expressionContext,0)


        def getRuleIndex(self):
            return CParser.RULE_lvalue

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterLvalue" ):
                listener.enterLvalue(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitLvalue" ):
                listener.exitLvalue(self)




    def lvalue(self):

        localctx = CParser.LvalueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_lvalue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 666
            self.unary_expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Assignment_operatorContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CParser.RULE_assignment_operator

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterAssignment_operator" ):
                listener.enterAssignment_operator(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitAssignment_operator" ):
                listener.exitAssignment_operator(self)




    def assignment_operator(self):

        localctx = CParser.Assignment_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_assignment_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 668
            _la = self._input.LA(1)
            if not(((((_la - 5)) & ~0x3f) == 0 and ((1 << (_la - 5)) & ((1 << (CParser.T__4 - 5)) | (1 << (CParser.T__55 - 5)) | (1 << (CParser.T__56 - 5)) | (1 << (CParser.T__57 - 5)) | (1 << (CParser.T__58 - 5)) | (1 << (CParser.T__59 - 5)) | (1 << (CParser.T__60 - 5)) | (1 << (CParser.T__61 - 5)) | (1 << (CParser.T__62 - 5)) | (1 << (CParser.T__63 - 5)) | (1 << (CParser.T__64 - 5)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Conditional_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.e = None # Logical_or_expressionContext

        def logical_or_expression(self):
            return self.getTypedRuleContext(CParser.Logical_or_expressionContext,0)


        def expression(self):
            return self.getTypedRuleContext(CParser.ExpressionContext,0)


        def conditional_expression(self):
            return self.getTypedRuleContext(CParser.Conditional_expressionContext,0)


        def getRuleIndex(self):
            return CParser.RULE_conditional_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterConditional_expression" ):
                listener.enterConditional_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitConditional_expression" ):
                listener.exitConditional_expression(self)




    def conditional_expression(self):

        localctx = CParser.Conditional_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_conditional_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 670
            localctx.e = self.logical_or_expression()
            self.state = 677
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CParser.T__65:
                self.state = 671
                self.match(CParser.T__65)
                self.state = 672
                self.expression()
                self.state = 673
                self.match(CParser.T__22)
                self.state = 674
                self.conditional_expression()
                self.StorePredicateExpression((None if localctx.e is None else localctx.e.start).line, (None if localctx.e is None else localctx.e.start).column, (None if localctx.e is None else localctx.e.stop).line, (None if localctx.e is None else localctx.e.stop).column, (None if localctx.e is None else self._input.getText((localctx.e.start,localctx.e.stop))))


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Logical_or_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def logical_and_expression(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Logical_and_expressionContext)
            else:
                return self.getTypedRuleContext(CParser.Logical_and_expressionContext,i)


        def getRuleIndex(self):
            return CParser.RULE_logical_or_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterLogical_or_expression" ):
                listener.enterLogical_or_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitLogical_or_expression" ):
                listener.exitLogical_or_expression(self)




    def logical_or_expression(self):

        localctx = CParser.Logical_or_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_logical_or_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 679
            self.logical_and_expression()
            self.state = 684
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CParser.T__66:
                self.state = 680
                self.match(CParser.T__66)
                self.state = 681
                self.logical_and_expression()
                self.state = 686
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Logical_and_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def inclusive_or_expression(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Inclusive_or_expressionContext)
            else:
                return self.getTypedRuleContext(CParser.Inclusive_or_expressionContext,i)


        def getRuleIndex(self):
            return CParser.RULE_logical_and_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterLogical_and_expression" ):
                listener.enterLogical_and_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitLogical_and_expression" ):
                listener.exitLogical_and_expression(self)




    def logical_and_expression(self):

        localctx = CParser.Logical_and_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_logical_and_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 687
            self.inclusive_or_expression()
            self.state = 692
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CParser.T__67:
                self.state = 688
                self.match(CParser.T__67)
                self.state = 689
                self.inclusive_or_expression()
                self.state = 694
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Inclusive_or_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def exclusive_or_expression(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Exclusive_or_expressionContext)
            else:
                return self.getTypedRuleContext(CParser.Exclusive_or_expressionContext,i)


        def getRuleIndex(self):
            return CParser.RULE_inclusive_or_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterInclusive_or_expression" ):
                listener.enterInclusive_or_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitInclusive_or_expression" ):
                listener.exitInclusive_or_expression(self)




    def inclusive_or_expression(self):

        localctx = CParser.Inclusive_or_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_inclusive_or_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 695
            self.exclusive_or_expression()
            self.state = 700
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CParser.T__68:
                self.state = 696
                self.match(CParser.T__68)
                self.state = 697
                self.exclusive_or_expression()
                self.state = 702
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Exclusive_or_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def and_expression(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.And_expressionContext)
            else:
                return self.getTypedRuleContext(CParser.And_expressionContext,i)


        def getRuleIndex(self):
            return CParser.RULE_exclusive_or_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterExclusive_or_expression" ):
                listener.enterExclusive_or_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitExclusive_or_expression" ):
                listener.exitExclusive_or_expression(self)




    def exclusive_or_expression(self):

        localctx = CParser.Exclusive_or_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_exclusive_or_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 703
            self.and_expression()
            self.state = 708
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CParser.T__69:
                self.state = 704
                self.match(CParser.T__69)
                self.state = 705
                self.and_expression()
                self.state = 710
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class And_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def equality_expression(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Equality_expressionContext)
            else:
                return self.getTypedRuleContext(CParser.Equality_expressionContext,i)


        def getRuleIndex(self):
            return CParser.RULE_and_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterAnd_expression" ):
                listener.enterAnd_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitAnd_expression" ):
                listener.exitAnd_expression(self)




    def and_expression(self):

        localctx = CParser.And_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_and_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 711
            self.equality_expression()
            self.state = 716
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CParser.T__52:
                self.state = 712
                self.match(CParser.T__52)
                self.state = 713
                self.equality_expression()
                self.state = 718
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Equality_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def relational_expression(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Relational_expressionContext)
            else:
                return self.getTypedRuleContext(CParser.Relational_expressionContext,i)


        def getRuleIndex(self):
            return CParser.RULE_equality_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterEquality_expression" ):
                listener.enterEquality_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitEquality_expression" ):
                listener.exitEquality_expression(self)




    def equality_expression(self):

        localctx = CParser.Equality_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_equality_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 719
            self.relational_expression()
            self.state = 724
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CParser.T__70 or _la==CParser.T__71:
                self.state = 720
                _la = self._input.LA(1)
                if not(_la==CParser.T__70 or _la==CParser.T__71):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 721
                self.relational_expression()
                self.state = 726
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Relational_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def shift_expression(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Shift_expressionContext)
            else:
                return self.getTypedRuleContext(CParser.Shift_expressionContext,i)


        def getRuleIndex(self):
            return CParser.RULE_relational_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterRelational_expression" ):
                listener.enterRelational_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitRelational_expression" ):
                listener.exitRelational_expression(self)




    def relational_expression(self):

        localctx = CParser.Relational_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_relational_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 727
            self.shift_expression()
            self.state = 732
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 73)) & ~0x3f) == 0 and ((1 << (_la - 73)) & ((1 << (CParser.T__72 - 73)) | (1 << (CParser.T__73 - 73)) | (1 << (CParser.T__74 - 73)) | (1 << (CParser.T__75 - 73)))) != 0):
                self.state = 728
                _la = self._input.LA(1)
                if not(((((_la - 73)) & ~0x3f) == 0 and ((1 << (_la - 73)) & ((1 << (CParser.T__72 - 73)) | (1 << (CParser.T__73 - 73)) | (1 << (CParser.T__74 - 73)) | (1 << (CParser.T__75 - 73)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 729
                self.shift_expression()
                self.state = 734
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Shift_expressionContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def additive_expression(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.Additive_expressionContext)
            else:
                return self.getTypedRuleContext(CParser.Additive_expressionContext,i)


        def getRuleIndex(self):
            return CParser.RULE_shift_expression

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterShift_expression" ):
                listener.enterShift_expression(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitShift_expression" ):
                listener.exitShift_expression(self)




    def shift_expression(self):

        localctx = CParser.Shift_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_shift_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 735
            self.additive_expression()
            self.state = 740
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CParser.T__76 or _la==CParser.T__77:
                self.state = 736
                _la = self._input.LA(1)
                if not(_la==CParser.T__76 or _la==CParser.T__77):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 737
                self.additive_expression()
                self.state = 742
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def labeled_statement(self):
            return self.getTypedRuleContext(CParser.Labeled_statementContext,0)


        def compound_statement(self):
            return self.getTypedRuleContext(CParser.Compound_statementContext,0)


        def expression_statement(self):
            return self.getTypedRuleContext(CParser.Expression_statementContext,0)


        def selection_statement(self):
            return self.getTypedRuleContext(CParser.Selection_statementContext,0)


        def iteration_statement(self):
            return self.getTypedRuleContext(CParser.Iteration_statementContext,0)


        def jump_statement(self):
            return self.getTypedRuleContext(CParser.Jump_statementContext,0)


        def macro_statement(self):
            return self.getTypedRuleContext(CParser.Macro_statementContext,0)


        def asm2_statement(self):
            return self.getTypedRuleContext(CParser.Asm2_statementContext,0)


        def asm1_statement(self):
            return self.getTypedRuleContext(CParser.Asm1_statementContext,0)


        def asm_statement(self):
            return self.getTypedRuleContext(CParser.Asm_statementContext,0)


        def declaration(self):
            return self.getTypedRuleContext(CParser.DeclarationContext,0)


        def getRuleIndex(self):
            return CParser.RULE_statement

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = CParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_statement)
        try:
            self.state = 754
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 743
                self.labeled_statement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 744
                self.compound_statement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 745
                self.expression_statement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 746
                self.selection_statement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 747
                self.iteration_statement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 748
                self.jump_statement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 749
                self.macro_statement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 750
                self.asm2_statement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 751
                self.asm1_statement()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 752
                self.asm_statement()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 753
                self.declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Asm2_statementContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(CParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return CParser.RULE_asm2_statement

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterAsm2_statement" ):
                listener.enterAsm2_statement(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitAsm2_statement" ):
                listener.exitAsm2_statement(self)




    def asm2_statement(self):

        localctx = CParser.Asm2_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_asm2_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 757
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CParser.T__78:
                self.state = 756
                self.match(CParser.T__78)


            self.state = 759
            self.match(CParser.IDENTIFIER)
            self.state = 760
            self.match(CParser.T__37)
            self.state = 764
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,94,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 761
                    _la = self._input.LA(1)
                    if _la <= 0 or _la==CParser.T__1:
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                self.state = 766
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,94,self._ctx)

            self.state = 767
            self.match(CParser.T__38)
            self.state = 768
            self.match(CParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Asm1_statementContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CParser.RULE_asm1_statement

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterAsm1_statement" ):
                listener.enterAsm1_statement(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitAsm1_statement" ):
                listener.exitAsm1_statement(self)




    def asm1_statement(self):

        localctx = CParser.Asm1_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_asm1_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 770
            self.match(CParser.T__79)
            self.state = 771
            self.match(CParser.T__0)
            self.state = 775
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2) | (1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__10) | (1 << CParser.T__11) | (1 << CParser.T__12) | (1 << CParser.T__13) | (1 << CParser.T__14) | (1 << CParser.T__15) | (1 << CParser.T__16) | (1 << CParser.T__17) | (1 << CParser.T__18) | (1 << CParser.T__20) | (1 << CParser.T__21) | (1 << CParser.T__22) | (1 << CParser.T__23) | (1 << CParser.T__24) | (1 << CParser.T__25) | (1 << CParser.T__26) | (1 << CParser.T__27) | (1 << CParser.T__28) | (1 << CParser.T__29) | (1 << CParser.T__30) | (1 << CParser.T__31) | (1 << CParser.T__32) | (1 << CParser.T__33) | (1 << CParser.T__34) | (1 << CParser.T__35) | (1 << CParser.T__36) | (1 << CParser.T__37) | (1 << CParser.T__38) | (1 << CParser.T__39) | (1 << CParser.T__40) | (1 << CParser.T__41) | (1 << CParser.T__42) | (1 << CParser.T__43) | (1 << CParser.T__44) | (1 << CParser.T__45) | (1 << CParser.T__46) | (1 << CParser.T__47) | (1 << CParser.T__48) | (1 << CParser.T__49) | (1 << CParser.T__50) | (1 << CParser.T__51) | (1 << CParser.T__52) | (1 << CParser.T__53) | (1 << CParser.T__54) | (1 << CParser.T__55) | (1 << CParser.T__56) | (1 << CParser.T__57) | (1 << CParser.T__58) | (1 << CParser.T__59) | (1 << CParser.T__60) | (1 << CParser.T__61) | (1 << CParser.T__62))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (CParser.T__63 - 64)) | (1 << (CParser.T__64 - 64)) | (1 << (CParser.T__65 - 64)) | (1 << (CParser.T__66 - 64)) | (1 << (CParser.T__67 - 64)) | (1 << (CParser.T__68 - 64)) | (1 << (CParser.T__69 - 64)) | (1 << (CParser.T__70 - 64)) | (1 << (CParser.T__71 - 64)) | (1 << (CParser.T__72 - 64)) | (1 << (CParser.T__73 - 64)) | (1 << (CParser.T__74 - 64)) | (1 << (CParser.T__75 - 64)) | (1 << (CParser.T__76 - 64)) | (1 << (CParser.T__77 - 64)) | (1 << (CParser.T__78 - 64)) | (1 << (CParser.T__79 - 64)) | (1 << (CParser.T__80 - 64)) | (1 << (CParser.T__81 - 64)) | (1 << (CParser.T__82 - 64)) | (1 << (CParser.T__83 - 64)) | (1 << (CParser.T__84 - 64)) | (1 << (CParser.T__85 - 64)) | (1 << (CParser.T__86 - 64)) | (1 << (CParser.T__87 - 64)) | (1 << (CParser.T__88 - 64)) | (1 << (CParser.T__89 - 64)) | (1 << (CParser.T__90 - 64)) | (1 << (CParser.T__91 - 64)) | (1 << (CParser.IDENTIFIER - 64)) | (1 << (CParser.CHARACTER_LITERAL - 64)) | (1 << (CParser.STRING_LITERAL - 64)) | (1 << (CParser.HEX_LITERAL - 64)) | (1 << (CParser.DECIMAL_LITERAL - 64)) | (1 << (CParser.OCTAL_LITERAL - 64)) | (1 << (CParser.FLOATING_POINT_LITERAL - 64)) | (1 << (CParser.WS - 64)) | (1 << (CParser.BS - 64)) | (1 << (CParser.UnicodeVocabulary - 64)) | (1 << (CParser.COMMENT - 64)) | (1 << (CParser.LINE_COMMENT - 64)) | (1 << (CParser.LINE_COMMAND - 64)))) != 0):
                self.state = 772
                _la = self._input.LA(1)
                if _la <= 0 or _la==CParser.T__19:
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 777
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 778
            self.match(CParser.T__19)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Asm_statementContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CParser.RULE_asm_statement

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterAsm_statement" ):
                listener.enterAsm_statement(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitAsm_statement" ):
                listener.exitAsm_statement(self)




    def asm_statement(self):

        localctx = CParser.Asm_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_asm_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 780
            self.match(CParser.T__80)
            self.state = 781
            self.match(CParser.T__0)
            self.state = 785
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2) | (1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__10) | (1 << CParser.T__11) | (1 << CParser.T__12) | (1 << CParser.T__13) | (1 << CParser.T__14) | (1 << CParser.T__15) | (1 << CParser.T__16) | (1 << CParser.T__17) | (1 << CParser.T__18) | (1 << CParser.T__20) | (1 << CParser.T__21) | (1 << CParser.T__22) | (1 << CParser.T__23) | (1 << CParser.T__24) | (1 << CParser.T__25) | (1 << CParser.T__26) | (1 << CParser.T__27) | (1 << CParser.T__28) | (1 << CParser.T__29) | (1 << CParser.T__30) | (1 << CParser.T__31) | (1 << CParser.T__32) | (1 << CParser.T__33) | (1 << CParser.T__34) | (1 << CParser.T__35) | (1 << CParser.T__36) | (1 << CParser.T__37) | (1 << CParser.T__38) | (1 << CParser.T__39) | (1 << CParser.T__40) | (1 << CParser.T__41) | (1 << CParser.T__42) | (1 << CParser.T__43) | (1 << CParser.T__44) | (1 << CParser.T__45) | (1 << CParser.T__46) | (1 << CParser.T__47) | (1 << CParser.T__48) | (1 << CParser.T__49) | (1 << CParser.T__50) | (1 << CParser.T__51) | (1 << CParser.T__52) | (1 << CParser.T__53) | (1 << CParser.T__54) | (1 << CParser.T__55) | (1 << CParser.T__56) | (1 << CParser.T__57) | (1 << CParser.T__58) | (1 << CParser.T__59) | (1 << CParser.T__60) | (1 << CParser.T__61) | (1 << CParser.T__62))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (CParser.T__63 - 64)) | (1 << (CParser.T__64 - 64)) | (1 << (CParser.T__65 - 64)) | (1 << (CParser.T__66 - 64)) | (1 << (CParser.T__67 - 64)) | (1 << (CParser.T__68 - 64)) | (1 << (CParser.T__69 - 64)) | (1 << (CParser.T__70 - 64)) | (1 << (CParser.T__71 - 64)) | (1 << (CParser.T__72 - 64)) | (1 << (CParser.T__73 - 64)) | (1 << (CParser.T__74 - 64)) | (1 << (CParser.T__75 - 64)) | (1 << (CParser.T__76 - 64)) | (1 << (CParser.T__77 - 64)) | (1 << (CParser.T__78 - 64)) | (1 << (CParser.T__79 - 64)) | (1 << (CParser.T__80 - 64)) | (1 << (CParser.T__81 - 64)) | (1 << (CParser.T__82 - 64)) | (1 << (CParser.T__83 - 64)) | (1 << (CParser.T__84 - 64)) | (1 << (CParser.T__85 - 64)) | (1 << (CParser.T__86 - 64)) | (1 << (CParser.T__87 - 64)) | (1 << (CParser.T__88 - 64)) | (1 << (CParser.T__89 - 64)) | (1 << (CParser.T__90 - 64)) | (1 << (CParser.T__91 - 64)) | (1 << (CParser.IDENTIFIER - 64)) | (1 << (CParser.CHARACTER_LITERAL - 64)) | (1 << (CParser.STRING_LITERAL - 64)) | (1 << (CParser.HEX_LITERAL - 64)) | (1 << (CParser.DECIMAL_LITERAL - 64)) | (1 << (CParser.OCTAL_LITERAL - 64)) | (1 << (CParser.FLOATING_POINT_LITERAL - 64)) | (1 << (CParser.WS - 64)) | (1 << (CParser.BS - 64)) | (1 << (CParser.UnicodeVocabulary - 64)) | (1 << (CParser.COMMENT - 64)) | (1 << (CParser.LINE_COMMENT - 64)) | (1 << (CParser.LINE_COMMAND - 64)))) != 0):
                self.state = 782
                _la = self._input.LA(1)
                if _la <= 0 or _la==CParser.T__19:
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 787
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 788
            self.match(CParser.T__19)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Macro_statementContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(CParser.IDENTIFIER, 0)

        # @param  i=None Type: int
        def declaration(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.DeclarationContext)
            else:
                return self.getTypedRuleContext(CParser.DeclarationContext,i)


        def statement_list(self):
            return self.getTypedRuleContext(CParser.Statement_listContext,0)


        def expression(self):
            return self.getTypedRuleContext(CParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CParser.RULE_macro_statement

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterMacro_statement" ):
                listener.enterMacro_statement(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitMacro_statement" ):
                listener.exitMacro_statement(self)




    def macro_statement(self):

        localctx = CParser.Macro_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_macro_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 790
            self.match(CParser.IDENTIFIER)
            self.state = 791
            self.match(CParser.T__37)
            self.state = 795
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,97,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 792
                    self.declaration()
                self.state = 797
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,97,self._ctx)

            self.state = 799
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,98,self._ctx)
            if la_ == 1:
                self.state = 798
                self.statement_list()


            self.state = 802
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 38)) & ~0x3f) == 0 and ((1 << (_la - 38)) & ((1 << (CParser.T__37 - 38)) | (1 << (CParser.T__41 - 38)) | (1 << (CParser.T__43 - 38)) | (1 << (CParser.T__44 - 38)) | (1 << (CParser.T__47 - 38)) | (1 << (CParser.T__48 - 38)) | (1 << (CParser.T__49 - 38)) | (1 << (CParser.T__52 - 38)) | (1 << (CParser.T__53 - 38)) | (1 << (CParser.T__54 - 38)) | (1 << (CParser.IDENTIFIER - 38)) | (1 << (CParser.CHARACTER_LITERAL - 38)) | (1 << (CParser.STRING_LITERAL - 38)) | (1 << (CParser.HEX_LITERAL - 38)) | (1 << (CParser.DECIMAL_LITERAL - 38)) | (1 << (CParser.OCTAL_LITERAL - 38)) | (1 << (CParser.FLOATING_POINT_LITERAL - 38)))) != 0):
                self.state = 801
                self.expression()


            self.state = 804
            self.match(CParser.T__38)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Labeled_statementContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(CParser.IDENTIFIER, 0)

        def statement(self):
            return self.getTypedRuleContext(CParser.StatementContext,0)


        def constant_expression(self):
            return self.getTypedRuleContext(CParser.Constant_expressionContext,0)


        def getRuleIndex(self):
            return CParser.RULE_labeled_statement

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterLabeled_statement" ):
                listener.enterLabeled_statement(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitLabeled_statement" ):
                listener.exitLabeled_statement(self)




    def labeled_statement(self):

        localctx = CParser.Labeled_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_labeled_statement)
        try:
            self.state = 817
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 806
                self.match(CParser.IDENTIFIER)
                self.state = 807
                self.match(CParser.T__22)
                self.state = 808
                self.statement()
                pass
            elif token in [CParser.T__81]:
                self.enterOuterAlt(localctx, 2)
                self.state = 809
                self.match(CParser.T__81)
                self.state = 810
                self.constant_expression()
                self.state = 811
                self.match(CParser.T__22)
                self.state = 812
                self.statement()
                pass
            elif token in [CParser.T__82]:
                self.enterOuterAlt(localctx, 3)
                self.state = 814
                self.match(CParser.T__82)
                self.state = 815
                self.match(CParser.T__22)
                self.state = 816
                self.statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Compound_statementContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def declaration(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.DeclarationContext)
            else:
                return self.getTypedRuleContext(CParser.DeclarationContext,i)


        def statement_list(self):
            return self.getTypedRuleContext(CParser.Statement_listContext,0)


        def getRuleIndex(self):
            return CParser.RULE_compound_statement

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterCompound_statement" ):
                listener.enterCompound_statement(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitCompound_statement" ):
                listener.exitCompound_statement(self)




    def compound_statement(self):

        localctx = CParser.Compound_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_compound_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 819
            self.match(CParser.T__0)
            self.state = 823
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,101,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 820
                    self.declaration()
                self.state = 825
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,101,self._ctx)

            self.state = 827
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__10) | (1 << CParser.T__11) | (1 << CParser.T__12) | (1 << CParser.T__13) | (1 << CParser.T__14) | (1 << CParser.T__15) | (1 << CParser.T__16) | (1 << CParser.T__17) | (1 << CParser.T__18) | (1 << CParser.T__20) | (1 << CParser.T__21) | (1 << CParser.T__23) | (1 << CParser.T__24) | (1 << CParser.T__25) | (1 << CParser.T__26) | (1 << CParser.T__27) | (1 << CParser.T__28) | (1 << CParser.T__29) | (1 << CParser.T__30) | (1 << CParser.T__31) | (1 << CParser.T__32) | (1 << CParser.T__33) | (1 << CParser.T__34) | (1 << CParser.T__35) | (1 << CParser.T__36) | (1 << CParser.T__37) | (1 << CParser.T__41) | (1 << CParser.T__43) | (1 << CParser.T__44) | (1 << CParser.T__47) | (1 << CParser.T__48) | (1 << CParser.T__49) | (1 << CParser.T__52) | (1 << CParser.T__53) | (1 << CParser.T__54))) != 0) or ((((_la - 79)) & ~0x3f) == 0 and ((1 << (_la - 79)) & ((1 << (CParser.T__78 - 79)) | (1 << (CParser.T__79 - 79)) | (1 << (CParser.T__80 - 79)) | (1 << (CParser.T__81 - 79)) | (1 << (CParser.T__82 - 79)) | (1 << (CParser.T__83 - 79)) | (1 << (CParser.T__85 - 79)) | (1 << (CParser.T__86 - 79)) | (1 << (CParser.T__87 - 79)) | (1 << (CParser.T__88 - 79)) | (1 << (CParser.T__89 - 79)) | (1 << (CParser.T__90 - 79)) | (1 << (CParser.T__91 - 79)) | (1 << (CParser.IDENTIFIER - 79)) | (1 << (CParser.CHARACTER_LITERAL - 79)) | (1 << (CParser.STRING_LITERAL - 79)) | (1 << (CParser.HEX_LITERAL - 79)) | (1 << (CParser.DECIMAL_LITERAL - 79)) | (1 << (CParser.OCTAL_LITERAL - 79)) | (1 << (CParser.FLOATING_POINT_LITERAL - 79)))) != 0):
                self.state = 826
                self.statement_list()


            self.state = 829
            self.match(CParser.T__19)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Statement_listContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        # @param  i=None Type: int
        def statement(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.StatementContext)
            else:
                return self.getTypedRuleContext(CParser.StatementContext,i)


        def getRuleIndex(self):
            return CParser.RULE_statement_list

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterStatement_list" ):
                listener.enterStatement_list(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitStatement_list" ):
                listener.exitStatement_list(self)




    def statement_list(self):

        localctx = CParser.Statement_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_statement_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 832
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 831
                    self.statement()

                else:
                    raise NoViableAltException(self)
                self.state = 834
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,103,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression_statementContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CParser.RULE_expression_statement

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterExpression_statement" ):
                listener.enterExpression_statement(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitExpression_statement" ):
                listener.exitExpression_statement(self)




    def expression_statement(self):

        localctx = CParser.Expression_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_expression_statement)
        try:
            self.state = 840
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CParser.T__1]:
                self.enterOuterAlt(localctx, 1)
                self.state = 836
                self.match(CParser.T__1)
                pass
            elif token in [CParser.T__37, CParser.T__41, CParser.T__43, CParser.T__44, CParser.T__47, CParser.T__48, CParser.T__49, CParser.T__52, CParser.T__53, CParser.T__54, CParser.IDENTIFIER, CParser.CHARACTER_LITERAL, CParser.STRING_LITERAL, CParser.HEX_LITERAL, CParser.DECIMAL_LITERAL, CParser.OCTAL_LITERAL, CParser.FLOATING_POINT_LITERAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 837
                self.expression()
                self.state = 838
                self.match(CParser.T__1)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Selection_statementContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.e = None # ExpressionContext

        # @param  i=None Type: int
        def statement(self,i=None):
            if i is None:
                return self.getTypedRuleContexts(CParser.StatementContext)
            else:
                return self.getTypedRuleContext(CParser.StatementContext,i)


        def expression(self):
            return self.getTypedRuleContext(CParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CParser.RULE_selection_statement

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterSelection_statement" ):
                listener.enterSelection_statement(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitSelection_statement" ):
                listener.exitSelection_statement(self)




    def selection_statement(self):

        localctx = CParser.Selection_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_selection_statement)
        try:
            self.state = 858
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CParser.T__83]:
                self.enterOuterAlt(localctx, 1)
                self.state = 842
                self.match(CParser.T__83)
                self.state = 843
                self.match(CParser.T__37)
                self.state = 844
                localctx.e = self.expression()
                self.state = 845
                self.match(CParser.T__38)
                self.StorePredicateExpression((None if localctx.e is None else localctx.e.start).line, (None if localctx.e is None else localctx.e.start).column, (None if localctx.e is None else localctx.e.stop).line, (None if localctx.e is None else localctx.e.stop).column, (None if localctx.e is None else self._input.getText((localctx.e.start,localctx.e.stop))))
                self.state = 847
                self.statement()
                self.state = 850
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,105,self._ctx)
                if la_ == 1:
                    self.state = 848
                    self.match(CParser.T__84)
                    self.state = 849
                    self.statement()


                pass
            elif token in [CParser.T__85]:
                self.enterOuterAlt(localctx, 2)
                self.state = 852
                self.match(CParser.T__85)
                self.state = 853
                self.match(CParser.T__37)
                self.state = 854
                self.expression()
                self.state = 855
                self.match(CParser.T__38)
                self.state = 856
                self.statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Iteration_statementContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.e = None # ExpressionContext

        def statement(self):
            return self.getTypedRuleContext(CParser.StatementContext,0)


        def expression(self):
            return self.getTypedRuleContext(CParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CParser.RULE_iteration_statement

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterIteration_statement" ):
                listener.enterIteration_statement(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitIteration_statement" ):
                listener.exitIteration_statement(self)




    def iteration_statement(self):

        localctx = CParser.Iteration_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_iteration_statement)
        try:
            self.state = 876
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CParser.T__86]:
                self.enterOuterAlt(localctx, 1)
                self.state = 860
                self.match(CParser.T__86)
                self.state = 861
                self.match(CParser.T__37)
                self.state = 862
                localctx.e = self.expression()
                self.state = 863
                self.match(CParser.T__38)
                self.state = 864
                self.statement()
                self.StorePredicateExpression((None if localctx.e is None else localctx.e.start).line, (None if localctx.e is None else localctx.e.start).column, (None if localctx.e is None else localctx.e.stop).line, (None if localctx.e is None else localctx.e.stop).column, (None if localctx.e is None else self._input.getText((localctx.e.start,localctx.e.stop))))
                pass
            elif token in [CParser.T__87]:
                self.enterOuterAlt(localctx, 2)
                self.state = 867
                self.match(CParser.T__87)
                self.state = 868
                self.statement()
                self.state = 869
                self.match(CParser.T__86)
                self.state = 870
                self.match(CParser.T__37)
                self.state = 871
                localctx.e = self.expression()
                self.state = 872
                self.match(CParser.T__38)
                self.state = 873
                self.match(CParser.T__1)
                self.StorePredicateExpression((None if localctx.e is None else localctx.e.start).line, (None if localctx.e is None else localctx.e.start).column, (None if localctx.e is None else localctx.e.stop).line, (None if localctx.e is None else localctx.e.stop).column, (None if localctx.e is None else self._input.getText((localctx.e.start,localctx.e.stop))))
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Jump_statementContext(ParserRuleContext):

        # @param  parent=None Type: ParserRuleContext
        # @param  invokingState=-1 Type: int
        def __init__(self,parser,parent=None,invokingState=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(CParser.IDENTIFIER, 0)

        def expression(self):
            return self.getTypedRuleContext(CParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CParser.RULE_jump_statement

        # @param  listener Type: ParseTreeListener
        def enterRule(self,listener):
            if hasattr( listener, "enterJump_statement" ):
                listener.enterJump_statement(self)

        # @param  listener Type: ParseTreeListener
        def exitRule(self,listener):
            if hasattr( listener, "exitJump_statement" ):
                listener.exitJump_statement(self)




    def jump_statement(self):

        localctx = CParser.Jump_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_jump_statement)
        try:
            self.state = 891
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 878
                self.match(CParser.T__88)
                self.state = 879
                self.match(CParser.IDENTIFIER)
                self.state = 880
                self.match(CParser.T__1)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 881
                self.match(CParser.T__89)
                self.state = 882
                self.match(CParser.T__1)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 883
                self.match(CParser.T__90)
                self.state = 884
                self.match(CParser.T__1)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 885
                self.match(CParser.T__91)
                self.state = 886
                self.match(CParser.T__1)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 887
                self.match(CParser.T__91)
                self.state = 888
                self.expression()
                self.state = 889
                self.match(CParser.T__1)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





